/* soapC.cpp
   Generated by gSOAP 2.7.7 from Generated/kegg_wsdl.h
   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.7 2006-04-27 13:54:17 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ArrayOfSubtype:
		return soap_in_ArrayOfSubtype(soap, NULL, NULL, "ns1:Subtype");
	case SOAP_TYPE_ns1__Subtype:
		return soap_in_ns1__Subtype(soap, NULL, NULL, "ns1:Subtype");
	case SOAP_TYPE_ArrayOfPathwayElementRelation:
		return soap_in_ArrayOfPathwayElementRelation(soap, NULL, NULL, "ns1:PathwayElementRelation");
	case SOAP_TYPE_ns1__PathwayElementRelation:
		return soap_in_ns1__PathwayElementRelation(soap, NULL, NULL, "ns1:PathwayElementRelation");
	case SOAP_TYPE_ArrayOfPathwayElement:
		return soap_in_ArrayOfPathwayElement(soap, NULL, NULL, "ns1:PathwayElement");
	case SOAP_TYPE_ns1__PathwayElement:
		return soap_in_ns1__PathwayElement(soap, NULL, NULL, "ns1:PathwayElement");
	case SOAP_TYPE_ArrayOfLinkDBRelation:
		return soap_in_ArrayOfLinkDBRelation(soap, NULL, NULL, "ns1:LinkDBRelation");
	case SOAP_TYPE_ns1__LinkDBRelation:
		return soap_in_ns1__LinkDBRelation(soap, NULL, NULL, "ns1:LinkDBRelation");
	case SOAP_TYPE_ArrayOfDefinition:
		return soap_in_ArrayOfDefinition(soap, NULL, NULL, "ns1:Definition");
	case SOAP_TYPE_ns1__Definition:
		return soap_in_ns1__Definition(soap, NULL, NULL, "ns1:Definition");
	case SOAP_TYPE_ArrayOfMotifResult:
		return soap_in_ArrayOfMotifResult(soap, NULL, NULL, "ns1:MotifResult");
	case SOAP_TYPE_ns1__MotifResult:
		return soap_in_ns1__MotifResult(soap, NULL, NULL, "ns1:MotifResult");
	case SOAP_TYPE_ArrayOfSSDBRelation:
		return soap_in_ArrayOfSSDBRelation(soap, NULL, NULL, "ns1:SSDBRelation");
	case SOAP_TYPE_ns1__SSDBRelation:
		return soap_in_ns1__SSDBRelation(soap, NULL, NULL, "ns1:SSDBRelation");
	case SOAP_TYPE_ArrayOfstring:
		return soap_in_ArrayOfstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ArrayOfint:
		return soap_in_ArrayOfint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkos:
		return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREkos(soap, NULL, NULL, "ns1:get_pathways_by_kos");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse:
		return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(soap, NULL, NULL, "ns1:get_pathways_by_kosResponse");
	case SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathway:
		return soap_in_ns1__get_USCOREkos_USCOREby_USCOREpathway(soap, NULL, NULL, "ns1:get_kos_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse:
		return soap_in_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, "ns1:get_kos_by_pathwayResponse");
	case SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcf:
		return soap_in_ns1__convert_USCOREmol_USCOREto_USCOREkcf(soap, NULL, NULL, "ns1:convert_mol_to_kcf");
	case SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse:
		return soap_in_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(soap, NULL, NULL, "ns1:convert_mol_to_kcfResponse");
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzyme:
		return soap_in_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(soap, NULL, NULL, "ns1:get_glycans_by_enzyme");
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse:
		return soap_in_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(soap, NULL, NULL, "ns1:get_glycans_by_enzymeResponse");
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme:
		return soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(soap, NULL, NULL, "ns1:get_compounds_by_enzyme");
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse:
		return soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(soap, NULL, NULL, "ns1:get_compounds_by_enzymeResponse");
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreaction:
		return soap_in_ns1__get_USCOREglycans_USCOREby_USCOREreaction(soap, NULL, NULL, "ns1:get_glycans_by_reaction");
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse:
		return soap_in_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(soap, NULL, NULL, "ns1:get_glycans_by_reactionResponse");
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreaction:
		return soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(soap, NULL, NULL, "ns1:get_compounds_by_reaction");
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse:
		return soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(soap, NULL, NULL, "ns1:get_compounds_by_reactionResponse");
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathway:
		return soap_in_ns1__get_USCOREglycans_USCOREby_USCOREpathway(soap, NULL, NULL, "ns1:get_glycans_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse:
		return soap_in_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, "ns1:get_glycans_by_pathwayResponse");
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathway:
		return soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(soap, NULL, NULL, "ns1:get_compounds_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse:
		return soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, "ns1:get_compounds_by_pathwayResponse");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycans:
		return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREglycans(soap, NULL, NULL, "ns1:get_pathways_by_glycans");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse:
		return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(soap, NULL, NULL, "ns1:get_pathways_by_glycansResponse");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompounds:
		return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(soap, NULL, NULL, "ns1:get_pathways_by_compounds");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse:
		return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(soap, NULL, NULL, "ns1:get_pathways_by_compoundsResponse");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompound:
		return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(soap, NULL, NULL, "ns1:get_enzymes_by_compound");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse:
		return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(soap, NULL, NULL, "ns1:get_enzymes_by_compoundResponse");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycan:
		return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(soap, NULL, NULL, "ns1:get_enzymes_by_glycan");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse:
		return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(soap, NULL, NULL, "ns1:get_enzymes_by_glycanResponse");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompound:
		return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREcompound(soap, NULL, NULL, "ns1:get_reactions_by_compound");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse:
		return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(soap, NULL, NULL, "ns1:get_reactions_by_compoundResponse");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycan:
		return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREglycan(soap, NULL, NULL, "ns1:get_reactions_by_glycan");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse:
		return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(soap, NULL, NULL, "ns1:get_reactions_by_glycanResponse");
	case SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism:
		return soap_in_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(soap, NULL, NULL, "ns1:get_number_of_genes_by_organism");
	case SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse:
		return soap_in_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(soap, NULL, NULL, "ns1:get_number_of_genes_by_organismResponse");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganism:
		return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREorganism(soap, NULL, NULL, "ns1:get_genes_by_organism");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse:
		return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(soap, NULL, NULL, "ns1:get_genes_by_organismResponse");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzyme:
		return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(soap, NULL, NULL, "ns1:get_reactions_by_enzyme");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse:
		return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(soap, NULL, NULL, "ns1:get_reactions_by_enzymeResponse");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreaction:
		return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(soap, NULL, NULL, "ns1:get_enzymes_by_reaction");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse:
		return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(soap, NULL, NULL, "ns1:get_enzymes_by_reactionResponse");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgene:
		return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREgene(soap, NULL, NULL, "ns1:get_enzymes_by_gene");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse:
		return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(soap, NULL, NULL, "ns1:get_enzymes_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzyme:
		return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(soap, NULL, NULL, "ns1:get_genes_by_enzyme");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse:
		return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(soap, NULL, NULL, "ns1:get_genes_by_enzymeResponse");
	case SOAP_TYPE_ns1__get_USCORElinked_USCOREpathways:
		return soap_in_ns1__get_USCORElinked_USCOREpathways(soap, NULL, NULL, "ns1:get_linked_pathways");
	case SOAP_TYPE_ns1__get_USCORElinked_USCOREpathwaysResponse:
		return soap_in_ns1__get_USCORElinked_USCOREpathwaysResponse(soap, NULL, NULL, "ns1:get_linked_pathwaysResponse");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactions:
		return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREreactions(soap, NULL, NULL, "ns1:get_pathways_by_reactions");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse:
		return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(soap, NULL, NULL, "ns1:get_pathways_by_reactionsResponse");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymes:
		return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(soap, NULL, NULL, "ns1:get_pathways_by_enzymes");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse:
		return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(soap, NULL, NULL, "ns1:get_pathways_by_enzymesResponse");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenes:
		return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREgenes(soap, NULL, NULL, "ns1:get_pathways_by_genes");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse:
		return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(soap, NULL, NULL, "ns1:get_pathways_by_genesResponse");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathway:
		return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREpathway(soap, NULL, NULL, "ns1:get_reactions_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse:
		return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, "ns1:get_reactions_by_pathwayResponse");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathway:
		return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(soap, NULL, NULL, "ns1:get_enzymes_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse:
		return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, "ns1:get_enzymes_by_pathwayResponse");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathway:
		return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREpathway(soap, NULL, NULL, "ns1:get_genes_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse:
		return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, "ns1:get_genes_by_pathwayResponse");
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects:
		return soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(soap, NULL, NULL, "ns1:get_html_of_colored_pathway_by_objects");
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse:
		return soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, NULL, NULL, "ns1:get_html_of_colored_pathway_by_objectsResponse");
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects:
		return soap_in_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(soap, NULL, NULL, "ns1:get_html_of_marked_pathway_by_objects");
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse:
		return soap_in_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, NULL, NULL, "ns1:get_html_of_marked_pathway_by_objectsResponse");
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjects:
		return soap_in_ns1__color_USCOREpathway_USCOREby_USCOREobjects(soap, NULL, NULL, "ns1:color_pathway_by_objects");
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse:
		return soap_in_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, NULL, NULL, "ns1:color_pathway_by_objectsResponse");
	case SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjects:
		return soap_in_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(soap, NULL, NULL, "ns1:mark_pathway_by_objects");
	case SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse:
		return soap_in_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, NULL, NULL, "ns1:mark_pathway_by_objectsResponse");
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements:
		return soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(soap, NULL, NULL, "ns1:get_html_of_colored_pathway_by_elements");
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse:
		return soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(soap, NULL, NULL, "ns1:get_html_of_colored_pathway_by_elementsResponse");
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelements:
		return soap_in_ns1__color_USCOREpathway_USCOREby_USCOREelements(soap, NULL, NULL, "ns1:color_pathway_by_elements");
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse:
		return soap_in_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(soap, NULL, NULL, "ns1:color_pathway_by_elementsResponse");
	case SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway:
		return soap_in_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(soap, NULL, NULL, "ns1:get_element_relations_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse:
		return soap_in_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, "ns1:get_element_relations_by_pathwayResponse");
	case SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathway:
		return soap_in_ns1__get_USCOREelements_USCOREby_USCOREpathway(soap, NULL, NULL, "ns1:get_elements_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse:
		return soap_in_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, "ns1:get_elements_by_pathwayResponse");
	case SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene:
		return soap_in_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(soap, NULL, NULL, "ns1:get_pc_members_by_gene");
	case SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse:
		return soap_in_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, NULL, NULL, "ns1:get_pc_members_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene:
		return soap_in_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(soap, NULL, NULL, "ns1:get_oc_members_by_gene");
	case SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse:
		return soap_in_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, NULL, NULL, "ns1:get_oc_members_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass:
		return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(soap, NULL, NULL, "ns1:get_genes_by_ko_class");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse:
		return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(soap, NULL, NULL, "ns1:get_genes_by_ko_classResponse");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko:
		return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREko(soap, NULL, NULL, "ns1:get_genes_by_ko");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse:
		return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(soap, NULL, NULL, "ns1:get_genes_by_koResponse");
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass:
		return soap_in_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(soap, NULL, NULL, "ns1:get_ko_by_ko_class");
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse:
		return soap_in_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(soap, NULL, NULL, "ns1:get_ko_by_ko_classResponse");
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgene:
		return soap_in_ns1__get_USCOREko_USCOREby_USCOREgene(soap, NULL, NULL, "ns1:get_ko_by_gene");
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgeneResponse:
		return soap_in_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(soap, NULL, NULL, "ns1:get_ko_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifs:
		return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(soap, NULL, NULL, "ns1:get_genes_by_motifs");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse:
		return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(soap, NULL, NULL, "ns1:get_genes_by_motifsResponse");
	case SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgene:
		return soap_in_ns1__get_USCOREmotifs_USCOREby_USCOREgene(soap, NULL, NULL, "ns1:get_motifs_by_gene");
	case SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse:
		return soap_in_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(soap, NULL, NULL, "ns1:get_motifs_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgene:
		return soap_in_ns1__get_USCOREparalogs_USCOREby_USCOREgene(soap, NULL, NULL, "ns1:get_paralogs_by_gene");
	case SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse:
		return soap_in_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(soap, NULL, NULL, "ns1:get_paralogs_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene:
		return soap_in_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, NULL, NULL, "ns1:get_reverse_best_neighbors_by_gene");
	case SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse:
		return soap_in_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, NULL, NULL, "ns1:get_reverse_best_neighbors_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene:
		return soap_in_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, NULL, NULL, "ns1:get_best_best_neighbors_by_gene");
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse:
		return soap_in_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, NULL, NULL, "ns1:get_best_best_neighbors_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene:
		return soap_in_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, NULL, NULL, "ns1:get_best_neighbors_by_gene");
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse:
		return soap_in_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, NULL, NULL, "ns1:get_best_neighbors_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentry:
		return soap_in_ns1__get_USCORElinkdb_USCOREby_USCOREentry(soap, NULL, NULL, "ns1:get_linkdb_by_entry");
	case SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse:
		return soap_in_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(soap, NULL, NULL, "ns1:get_linkdb_by_entryResponse");
	case SOAP_TYPE_ns1__bconv:
		return soap_in_ns1__bconv(soap, NULL, NULL, "ns1:bconv");
	case SOAP_TYPE_ns1__bconvResponse:
		return soap_in_ns1__bconvResponse(soap, NULL, NULL, "ns1:bconvResponse");
	case SOAP_TYPE_ns1__btit:
		return soap_in_ns1__btit(soap, NULL, NULL, "ns1:btit");
	case SOAP_TYPE_ns1__btitResponse:
		return soap_in_ns1__btitResponse(soap, NULL, NULL, "ns1:btitResponse");
	case SOAP_TYPE_ns1__bfind:
		return soap_in_ns1__bfind(soap, NULL, NULL, "ns1:bfind");
	case SOAP_TYPE_ns1__bfindResponse:
		return soap_in_ns1__bfindResponse(soap, NULL, NULL, "ns1:bfindResponse");
	case SOAP_TYPE_ns1__bget:
		return soap_in_ns1__bget(soap, NULL, NULL, "ns1:bget");
	case SOAP_TYPE_ns1__bgetResponse:
		return soap_in_ns1__bgetResponse(soap, NULL, NULL, "ns1:bgetResponse");
	case SOAP_TYPE_ns1__binfo:
		return soap_in_ns1__binfo(soap, NULL, NULL, "ns1:binfo");
	case SOAP_TYPE_ns1__binfoResponse:
		return soap_in_ns1__binfoResponse(soap, NULL, NULL, "ns1:binfoResponse");
	case SOAP_TYPE_ns1__list_USCOREko_USCOREclasses:
		return soap_in_ns1__list_USCOREko_USCOREclasses(soap, NULL, NULL, "ns1:list_ko_classes");
	case SOAP_TYPE_ns1__list_USCOREko_USCOREclassesResponse:
		return soap_in_ns1__list_USCOREko_USCOREclassesResponse(soap, NULL, NULL, "ns1:list_ko_classesResponse");
	case SOAP_TYPE_ns1__list_USCOREpathways:
		return soap_in_ns1__list_USCOREpathways(soap, NULL, NULL, "ns1:list_pathways");
	case SOAP_TYPE_ns1__list_USCOREpathwaysResponse:
		return soap_in_ns1__list_USCOREpathwaysResponse(soap, NULL, NULL, "ns1:list_pathwaysResponse");
	case SOAP_TYPE_ns1__list_USCOREorganisms:
		return soap_in_ns1__list_USCOREorganisms(soap, NULL, NULL, "ns1:list_organisms");
	case SOAP_TYPE_ns1__list_USCOREorganismsResponse:
		return soap_in_ns1__list_USCOREorganismsResponse(soap, NULL, NULL, "ns1:list_organismsResponse");
	case SOAP_TYPE_ns1__list_USCOREdatabases:
		return soap_in_ns1__list_USCOREdatabases(soap, NULL, NULL, "ns1:list_databases");
	case SOAP_TYPE_ns1__list_USCOREdatabasesResponse:
		return soap_in_ns1__list_USCOREdatabasesResponse(soap, NULL, NULL, "ns1:list_databasesResponse");
	case SOAP_TYPE_PointerToArrayOfPathwayElementRelation:
		return soap_in_PointerToArrayOfPathwayElementRelation(soap, NULL, NULL, "ns1:PathwayElementRelation");
	case SOAP_TYPE_PointerToArrayOfPathwayElement:
		return soap_in_PointerToArrayOfPathwayElement(soap, NULL, NULL, "ns1:PathwayElement");
	case SOAP_TYPE_PointerToArrayOfMotifResult:
		return soap_in_PointerToArrayOfMotifResult(soap, NULL, NULL, "ns1:MotifResult");
	case SOAP_TYPE_PointerToArrayOfSSDBRelation:
		return soap_in_PointerToArrayOfSSDBRelation(soap, NULL, NULL, "ns1:SSDBRelation");
	case SOAP_TYPE_PointerToArrayOfLinkDBRelation:
		return soap_in_PointerToArrayOfLinkDBRelation(soap, NULL, NULL, "ns1:LinkDBRelation");
	case SOAP_TYPE_PointerToArrayOfDefinition:
		return soap_in_PointerToArrayOfDefinition(soap, NULL, NULL, "ns1:Definition");
	case SOAP_TYPE_PointerToPointerTons1__Subtype:
		return soap_in_PointerToPointerTons1__Subtype(soap, NULL, NULL, "ns1:Subtype");
	case SOAP_TYPE_PointerTons1__Subtype:
		return soap_in_PointerTons1__Subtype(soap, NULL, NULL, "ns1:Subtype");
	case SOAP_TYPE_PointerToPointerTons1__PathwayElementRelation:
		return soap_in_PointerToPointerTons1__PathwayElementRelation(soap, NULL, NULL, "ns1:PathwayElementRelation");
	case SOAP_TYPE_PointerTons1__PathwayElementRelation:
		return soap_in_PointerTons1__PathwayElementRelation(soap, NULL, NULL, "ns1:PathwayElementRelation");
	case SOAP_TYPE_PointerToPointerTons1__PathwayElement:
		return soap_in_PointerToPointerTons1__PathwayElement(soap, NULL, NULL, "ns1:PathwayElement");
	case SOAP_TYPE_PointerTons1__PathwayElement:
		return soap_in_PointerTons1__PathwayElement(soap, NULL, NULL, "ns1:PathwayElement");
	case SOAP_TYPE_PointerToPointerTons1__LinkDBRelation:
		return soap_in_PointerToPointerTons1__LinkDBRelation(soap, NULL, NULL, "ns1:LinkDBRelation");
	case SOAP_TYPE_PointerTons1__LinkDBRelation:
		return soap_in_PointerTons1__LinkDBRelation(soap, NULL, NULL, "ns1:LinkDBRelation");
	case SOAP_TYPE_PointerToPointerTons1__Definition:
		return soap_in_PointerToPointerTons1__Definition(soap, NULL, NULL, "ns1:Definition");
	case SOAP_TYPE_PointerTons1__Definition:
		return soap_in_PointerTons1__Definition(soap, NULL, NULL, "ns1:Definition");
	case SOAP_TYPE_PointerToPointerTons1__MotifResult:
		return soap_in_PointerToPointerTons1__MotifResult(soap, NULL, NULL, "ns1:MotifResult");
	case SOAP_TYPE_PointerTons1__MotifResult:
		return soap_in_PointerTons1__MotifResult(soap, NULL, NULL, "ns1:MotifResult");
	case SOAP_TYPE_PointerToPointerTons1__SSDBRelation:
		return soap_in_PointerToPointerTons1__SSDBRelation(soap, NULL, NULL, "ns1:SSDBRelation");
	case SOAP_TYPE_PointerTons1__SSDBRelation:
		return soap_in_PointerTons1__SSDBRelation(soap, NULL, NULL, "ns1:SSDBRelation");
	case SOAP_TYPE_PointerToPointerTostd__string:
		return soap_in_PointerToPointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToArrayOfSubtype:
		return soap_in_PointerToArrayOfSubtype(soap, NULL, NULL, "ns1:Subtype");
	case SOAP_TYPE_PointerToArrayOfint:
		return soap_in_PointerToArrayOfint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToArrayOfstring:
		return soap_in_PointerToArrayOfstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:Subtype"))
		{	*type = SOAP_TYPE_ArrayOfSubtype;
			return soap_in_ArrayOfSubtype(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Subtype"))
		{	*type = SOAP_TYPE_ns1__Subtype;
			return soap_in_ns1__Subtype(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:PathwayElementRelation"))
		{	*type = SOAP_TYPE_ArrayOfPathwayElementRelation;
			return soap_in_ArrayOfPathwayElementRelation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PathwayElementRelation"))
		{	*type = SOAP_TYPE_ns1__PathwayElementRelation;
			return soap_in_ns1__PathwayElementRelation(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:PathwayElement"))
		{	*type = SOAP_TYPE_ArrayOfPathwayElement;
			return soap_in_ArrayOfPathwayElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PathwayElement"))
		{	*type = SOAP_TYPE_ns1__PathwayElement;
			return soap_in_ns1__PathwayElement(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:LinkDBRelation"))
		{	*type = SOAP_TYPE_ArrayOfLinkDBRelation;
			return soap_in_ArrayOfLinkDBRelation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LinkDBRelation"))
		{	*type = SOAP_TYPE_ns1__LinkDBRelation;
			return soap_in_ns1__LinkDBRelation(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:Definition"))
		{	*type = SOAP_TYPE_ArrayOfDefinition;
			return soap_in_ArrayOfDefinition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Definition"))
		{	*type = SOAP_TYPE_ns1__Definition;
			return soap_in_ns1__Definition(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:MotifResult"))
		{	*type = SOAP_TYPE_ArrayOfMotifResult;
			return soap_in_ArrayOfMotifResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MotifResult"))
		{	*type = SOAP_TYPE_ns1__MotifResult;
			return soap_in_ns1__MotifResult(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:SSDBRelation"))
		{	*type = SOAP_TYPE_ArrayOfSSDBRelation;
			return soap_in_ArrayOfSSDBRelation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SSDBRelation"))
		{	*type = SOAP_TYPE_ns1__SSDBRelation;
			return soap_in_ns1__SSDBRelation(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_ArrayOfstring;
			return soap_in_ArrayOfstring(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:int"))
		{	*type = SOAP_TYPE_ArrayOfint;
			return soap_in_ArrayOfint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_pathways_by_kos"))
		{	*type = SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkos;
			return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREkos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_pathways_by_kosResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse;
			return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_kos_by_pathway"))
		{	*type = SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathway;
			return soap_in_ns1__get_USCOREkos_USCOREby_USCOREpathway(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_kos_by_pathwayResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse;
			return soap_in_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:convert_mol_to_kcf"))
		{	*type = SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcf;
			return soap_in_ns1__convert_USCOREmol_USCOREto_USCOREkcf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:convert_mol_to_kcfResponse"))
		{	*type = SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse;
			return soap_in_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_glycans_by_enzyme"))
		{	*type = SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzyme;
			return soap_in_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_glycans_by_enzymeResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse;
			return soap_in_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_compounds_by_enzyme"))
		{	*type = SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme;
			return soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_compounds_by_enzymeResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse;
			return soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_glycans_by_reaction"))
		{	*type = SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreaction;
			return soap_in_ns1__get_USCOREglycans_USCOREby_USCOREreaction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_glycans_by_reactionResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse;
			return soap_in_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_compounds_by_reaction"))
		{	*type = SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreaction;
			return soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_compounds_by_reactionResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse;
			return soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_glycans_by_pathway"))
		{	*type = SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathway;
			return soap_in_ns1__get_USCOREglycans_USCOREby_USCOREpathway(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_glycans_by_pathwayResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse;
			return soap_in_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_compounds_by_pathway"))
		{	*type = SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathway;
			return soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_compounds_by_pathwayResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse;
			return soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_pathways_by_glycans"))
		{	*type = SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycans;
			return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREglycans(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_pathways_by_glycansResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse;
			return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_pathways_by_compounds"))
		{	*type = SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompounds;
			return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_pathways_by_compoundsResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse;
			return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_enzymes_by_compound"))
		{	*type = SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompound;
			return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_enzymes_by_compoundResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse;
			return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_enzymes_by_glycan"))
		{	*type = SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycan;
			return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_enzymes_by_glycanResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse;
			return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_reactions_by_compound"))
		{	*type = SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompound;
			return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREcompound(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_reactions_by_compoundResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse;
			return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_reactions_by_glycan"))
		{	*type = SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycan;
			return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREglycan(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_reactions_by_glycanResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse;
			return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_number_of_genes_by_organism"))
		{	*type = SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism;
			return soap_in_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_number_of_genes_by_organismResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse;
			return soap_in_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_genes_by_organism"))
		{	*type = SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganism;
			return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREorganism(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_genes_by_organismResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse;
			return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_reactions_by_enzyme"))
		{	*type = SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzyme;
			return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_reactions_by_enzymeResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse;
			return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_enzymes_by_reaction"))
		{	*type = SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreaction;
			return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_enzymes_by_reactionResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse;
			return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_enzymes_by_gene"))
		{	*type = SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgene;
			return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREgene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_enzymes_by_geneResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse;
			return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_genes_by_enzyme"))
		{	*type = SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzyme;
			return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_genes_by_enzymeResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse;
			return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_linked_pathways"))
		{	*type = SOAP_TYPE_ns1__get_USCORElinked_USCOREpathways;
			return soap_in_ns1__get_USCORElinked_USCOREpathways(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_linked_pathwaysResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCORElinked_USCOREpathwaysResponse;
			return soap_in_ns1__get_USCORElinked_USCOREpathwaysResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_pathways_by_reactions"))
		{	*type = SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactions;
			return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREreactions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_pathways_by_reactionsResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse;
			return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_pathways_by_enzymes"))
		{	*type = SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymes;
			return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_pathways_by_enzymesResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse;
			return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_pathways_by_genes"))
		{	*type = SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenes;
			return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREgenes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_pathways_by_genesResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse;
			return soap_in_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_reactions_by_pathway"))
		{	*type = SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathway;
			return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREpathway(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_reactions_by_pathwayResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse;
			return soap_in_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_enzymes_by_pathway"))
		{	*type = SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathway;
			return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_enzymes_by_pathwayResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse;
			return soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_genes_by_pathway"))
		{	*type = SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathway;
			return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREpathway(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_genes_by_pathwayResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse;
			return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_html_of_colored_pathway_by_objects"))
		{	*type = SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects;
			return soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_html_of_colored_pathway_by_objectsResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse;
			return soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_html_of_marked_pathway_by_objects"))
		{	*type = SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects;
			return soap_in_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_html_of_marked_pathway_by_objectsResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse;
			return soap_in_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:color_pathway_by_objects"))
		{	*type = SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjects;
			return soap_in_ns1__color_USCOREpathway_USCOREby_USCOREobjects(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:color_pathway_by_objectsResponse"))
		{	*type = SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse;
			return soap_in_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mark_pathway_by_objects"))
		{	*type = SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjects;
			return soap_in_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mark_pathway_by_objectsResponse"))
		{	*type = SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse;
			return soap_in_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_html_of_colored_pathway_by_elements"))
		{	*type = SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements;
			return soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_html_of_colored_pathway_by_elementsResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse;
			return soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:color_pathway_by_elements"))
		{	*type = SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelements;
			return soap_in_ns1__color_USCOREpathway_USCOREby_USCOREelements(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:color_pathway_by_elementsResponse"))
		{	*type = SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse;
			return soap_in_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_element_relations_by_pathway"))
		{	*type = SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway;
			return soap_in_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_element_relations_by_pathwayResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse;
			return soap_in_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_elements_by_pathway"))
		{	*type = SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathway;
			return soap_in_ns1__get_USCOREelements_USCOREby_USCOREpathway(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_elements_by_pathwayResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse;
			return soap_in_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_pc_members_by_gene"))
		{	*type = SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene;
			return soap_in_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_pc_members_by_geneResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse;
			return soap_in_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_oc_members_by_gene"))
		{	*type = SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene;
			return soap_in_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_oc_members_by_geneResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse;
			return soap_in_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_genes_by_ko_class"))
		{	*type = SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass;
			return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_genes_by_ko_classResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse;
			return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_genes_by_ko"))
		{	*type = SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko;
			return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREko(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_genes_by_koResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse;
			return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_ko_by_ko_class"))
		{	*type = SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass;
			return soap_in_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_ko_by_ko_classResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse;
			return soap_in_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_ko_by_gene"))
		{	*type = SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgene;
			return soap_in_ns1__get_USCOREko_USCOREby_USCOREgene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_ko_by_geneResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgeneResponse;
			return soap_in_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_genes_by_motifs"))
		{	*type = SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifs;
			return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_genes_by_motifsResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse;
			return soap_in_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_motifs_by_gene"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgene;
			return soap_in_ns1__get_USCOREmotifs_USCOREby_USCOREgene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_motifs_by_geneResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse;
			return soap_in_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_paralogs_by_gene"))
		{	*type = SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgene;
			return soap_in_ns1__get_USCOREparalogs_USCOREby_USCOREgene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_paralogs_by_geneResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse;
			return soap_in_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_reverse_best_neighbors_by_gene"))
		{	*type = SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene;
			return soap_in_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_reverse_best_neighbors_by_geneResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse;
			return soap_in_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_best_best_neighbors_by_gene"))
		{	*type = SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene;
			return soap_in_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_best_best_neighbors_by_geneResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse;
			return soap_in_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_best_neighbors_by_gene"))
		{	*type = SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene;
			return soap_in_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_best_neighbors_by_geneResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse;
			return soap_in_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_linkdb_by_entry"))
		{	*type = SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentry;
			return soap_in_ns1__get_USCORElinkdb_USCOREby_USCOREentry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_linkdb_by_entryResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse;
			return soap_in_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:bconv"))
		{	*type = SOAP_TYPE_ns1__bconv;
			return soap_in_ns1__bconv(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:bconvResponse"))
		{	*type = SOAP_TYPE_ns1__bconvResponse;
			return soap_in_ns1__bconvResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:btit"))
		{	*type = SOAP_TYPE_ns1__btit;
			return soap_in_ns1__btit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:btitResponse"))
		{	*type = SOAP_TYPE_ns1__btitResponse;
			return soap_in_ns1__btitResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:bfind"))
		{	*type = SOAP_TYPE_ns1__bfind;
			return soap_in_ns1__bfind(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:bfindResponse"))
		{	*type = SOAP_TYPE_ns1__bfindResponse;
			return soap_in_ns1__bfindResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:bget"))
		{	*type = SOAP_TYPE_ns1__bget;
			return soap_in_ns1__bget(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:bgetResponse"))
		{	*type = SOAP_TYPE_ns1__bgetResponse;
			return soap_in_ns1__bgetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:binfo"))
		{	*type = SOAP_TYPE_ns1__binfo;
			return soap_in_ns1__binfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:binfoResponse"))
		{	*type = SOAP_TYPE_ns1__binfoResponse;
			return soap_in_ns1__binfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:list_ko_classes"))
		{	*type = SOAP_TYPE_ns1__list_USCOREko_USCOREclasses;
			return soap_in_ns1__list_USCOREko_USCOREclasses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:list_ko_classesResponse"))
		{	*type = SOAP_TYPE_ns1__list_USCOREko_USCOREclassesResponse;
			return soap_in_ns1__list_USCOREko_USCOREclassesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:list_pathways"))
		{	*type = SOAP_TYPE_ns1__list_USCOREpathways;
			return soap_in_ns1__list_USCOREpathways(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:list_pathwaysResponse"))
		{	*type = SOAP_TYPE_ns1__list_USCOREpathwaysResponse;
			return soap_in_ns1__list_USCOREpathwaysResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:list_organisms"))
		{	*type = SOAP_TYPE_ns1__list_USCOREorganisms;
			return soap_in_ns1__list_USCOREorganisms(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:list_organismsResponse"))
		{	*type = SOAP_TYPE_ns1__list_USCOREorganismsResponse;
			return soap_in_ns1__list_USCOREorganismsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:list_databases"))
		{	*type = SOAP_TYPE_ns1__list_USCOREdatabases;
			return soap_in_ns1__list_USCOREdatabases(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:list_databasesResponse"))
		{	*type = SOAP_TYPE_ns1__list_USCOREdatabasesResponse;
			return soap_in_ns1__list_USCOREdatabasesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "SOAP-ENC:arrayType"))
		{	*type = SOAP_TYPE__SOAP_ENC__arrayType;
			return soap_in__SOAP_ENC__arrayType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
			return soap->error = SOAP_TAG_MISMATCH;
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ArrayOfSubtype:
		return ((ArrayOfSubtype *)ptr)->soap_out(soap, tag, id, "ns1:Subtype");
	case SOAP_TYPE_ns1__Subtype:
		return ((ns1__Subtype *)ptr)->soap_out(soap, tag, id, "ns1:Subtype");
	case SOAP_TYPE_ArrayOfPathwayElementRelation:
		return ((ArrayOfPathwayElementRelation *)ptr)->soap_out(soap, tag, id, "ns1:PathwayElementRelation");
	case SOAP_TYPE_ns1__PathwayElementRelation:
		return ((ns1__PathwayElementRelation *)ptr)->soap_out(soap, tag, id, "ns1:PathwayElementRelation");
	case SOAP_TYPE_ArrayOfPathwayElement:
		return ((ArrayOfPathwayElement *)ptr)->soap_out(soap, tag, id, "ns1:PathwayElement");
	case SOAP_TYPE_ns1__PathwayElement:
		return ((ns1__PathwayElement *)ptr)->soap_out(soap, tag, id, "ns1:PathwayElement");
	case SOAP_TYPE_ArrayOfLinkDBRelation:
		return ((ArrayOfLinkDBRelation *)ptr)->soap_out(soap, tag, id, "ns1:LinkDBRelation");
	case SOAP_TYPE_ns1__LinkDBRelation:
		return ((ns1__LinkDBRelation *)ptr)->soap_out(soap, tag, id, "ns1:LinkDBRelation");
	case SOAP_TYPE_ArrayOfDefinition:
		return ((ArrayOfDefinition *)ptr)->soap_out(soap, tag, id, "ns1:Definition");
	case SOAP_TYPE_ns1__Definition:
		return ((ns1__Definition *)ptr)->soap_out(soap, tag, id, "ns1:Definition");
	case SOAP_TYPE_ArrayOfMotifResult:
		return ((ArrayOfMotifResult *)ptr)->soap_out(soap, tag, id, "ns1:MotifResult");
	case SOAP_TYPE_ns1__MotifResult:
		return ((ns1__MotifResult *)ptr)->soap_out(soap, tag, id, "ns1:MotifResult");
	case SOAP_TYPE_ArrayOfSSDBRelation:
		return ((ArrayOfSSDBRelation *)ptr)->soap_out(soap, tag, id, "ns1:SSDBRelation");
	case SOAP_TYPE_ns1__SSDBRelation:
		return ((ns1__SSDBRelation *)ptr)->soap_out(soap, tag, id, "ns1:SSDBRelation");
	case SOAP_TYPE_ArrayOfstring:
		return ((ArrayOfstring *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_ArrayOfint:
		return ((ArrayOfint *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE__SOAP_ENC__arrayType:
		return soap_out__SOAP_ENC__arrayType(soap, "SOAP-ENC:arrayType", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkos:
		return soap_out_ns1__get_USCOREpathways_USCOREby_USCOREkos(soap, tag, id, (const struct ns1__get_USCOREpathways_USCOREby_USCOREkos *)ptr, "ns1:get_pathways_by_kos");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse:
		return soap_out_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(soap, tag, id, (const struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse *)ptr, "ns1:get_pathways_by_kosResponse");
	case SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathway:
		return soap_out_ns1__get_USCOREkos_USCOREby_USCOREpathway(soap, tag, id, (const struct ns1__get_USCOREkos_USCOREby_USCOREpathway *)ptr, "ns1:get_kos_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse:
		return soap_out_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(soap, tag, id, (const struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse *)ptr, "ns1:get_kos_by_pathwayResponse");
	case SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcf:
		return soap_out_ns1__convert_USCOREmol_USCOREto_USCOREkcf(soap, tag, id, (const struct ns1__convert_USCOREmol_USCOREto_USCOREkcf *)ptr, "ns1:convert_mol_to_kcf");
	case SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse:
		return soap_out_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(soap, tag, id, (const struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse *)ptr, "ns1:convert_mol_to_kcfResponse");
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzyme:
		return soap_out_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(soap, tag, id, (const struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme *)ptr, "ns1:get_glycans_by_enzyme");
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse:
		return soap_out_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(soap, tag, id, (const struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse *)ptr, "ns1:get_glycans_by_enzymeResponse");
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme:
		return soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(soap, tag, id, (const struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme *)ptr, "ns1:get_compounds_by_enzyme");
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse:
		return soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(soap, tag, id, (const struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse *)ptr, "ns1:get_compounds_by_enzymeResponse");
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreaction:
		return soap_out_ns1__get_USCOREglycans_USCOREby_USCOREreaction(soap, tag, id, (const struct ns1__get_USCOREglycans_USCOREby_USCOREreaction *)ptr, "ns1:get_glycans_by_reaction");
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse:
		return soap_out_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(soap, tag, id, (const struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse *)ptr, "ns1:get_glycans_by_reactionResponse");
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreaction:
		return soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(soap, tag, id, (const struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction *)ptr, "ns1:get_compounds_by_reaction");
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse:
		return soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(soap, tag, id, (const struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse *)ptr, "ns1:get_compounds_by_reactionResponse");
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathway:
		return soap_out_ns1__get_USCOREglycans_USCOREby_USCOREpathway(soap, tag, id, (const struct ns1__get_USCOREglycans_USCOREby_USCOREpathway *)ptr, "ns1:get_glycans_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse:
		return soap_out_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(soap, tag, id, (const struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse *)ptr, "ns1:get_glycans_by_pathwayResponse");
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathway:
		return soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(soap, tag, id, (const struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway *)ptr, "ns1:get_compounds_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse:
		return soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(soap, tag, id, (const struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse *)ptr, "ns1:get_compounds_by_pathwayResponse");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycans:
		return soap_out_ns1__get_USCOREpathways_USCOREby_USCOREglycans(soap, tag, id, (const struct ns1__get_USCOREpathways_USCOREby_USCOREglycans *)ptr, "ns1:get_pathways_by_glycans");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse:
		return soap_out_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(soap, tag, id, (const struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse *)ptr, "ns1:get_pathways_by_glycansResponse");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompounds:
		return soap_out_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(soap, tag, id, (const struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds *)ptr, "ns1:get_pathways_by_compounds");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse:
		return soap_out_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(soap, tag, id, (const struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse *)ptr, "ns1:get_pathways_by_compoundsResponse");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompound:
		return soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(soap, tag, id, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound *)ptr, "ns1:get_enzymes_by_compound");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse:
		return soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(soap, tag, id, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse *)ptr, "ns1:get_enzymes_by_compoundResponse");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycan:
		return soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(soap, tag, id, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan *)ptr, "ns1:get_enzymes_by_glycan");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse:
		return soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(soap, tag, id, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse *)ptr, "ns1:get_enzymes_by_glycanResponse");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompound:
		return soap_out_ns1__get_USCOREreactions_USCOREby_USCOREcompound(soap, tag, id, (const struct ns1__get_USCOREreactions_USCOREby_USCOREcompound *)ptr, "ns1:get_reactions_by_compound");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse:
		return soap_out_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(soap, tag, id, (const struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse *)ptr, "ns1:get_reactions_by_compoundResponse");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycan:
		return soap_out_ns1__get_USCOREreactions_USCOREby_USCOREglycan(soap, tag, id, (const struct ns1__get_USCOREreactions_USCOREby_USCOREglycan *)ptr, "ns1:get_reactions_by_glycan");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse:
		return soap_out_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(soap, tag, id, (const struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse *)ptr, "ns1:get_reactions_by_glycanResponse");
	case SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism:
		return soap_out_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(soap, tag, id, (const struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism *)ptr, "ns1:get_number_of_genes_by_organism");
	case SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse:
		return soap_out_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(soap, tag, id, (const struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse *)ptr, "ns1:get_number_of_genes_by_organismResponse");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganism:
		return soap_out_ns1__get_USCOREgenes_USCOREby_USCOREorganism(soap, tag, id, (const struct ns1__get_USCOREgenes_USCOREby_USCOREorganism *)ptr, "ns1:get_genes_by_organism");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse:
		return soap_out_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(soap, tag, id, (const struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse *)ptr, "ns1:get_genes_by_organismResponse");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzyme:
		return soap_out_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(soap, tag, id, (const struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme *)ptr, "ns1:get_reactions_by_enzyme");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse:
		return soap_out_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(soap, tag, id, (const struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse *)ptr, "ns1:get_reactions_by_enzymeResponse");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreaction:
		return soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(soap, tag, id, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction *)ptr, "ns1:get_enzymes_by_reaction");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse:
		return soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(soap, tag, id, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse *)ptr, "ns1:get_enzymes_by_reactionResponse");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgene:
		return soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREgene(soap, tag, id, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREgene *)ptr, "ns1:get_enzymes_by_gene");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse:
		return soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(soap, tag, id, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse *)ptr, "ns1:get_enzymes_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzyme:
		return soap_out_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(soap, tag, id, (const struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme *)ptr, "ns1:get_genes_by_enzyme");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse:
		return soap_out_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(soap, tag, id, (const struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse *)ptr, "ns1:get_genes_by_enzymeResponse");
	case SOAP_TYPE_ns1__get_USCORElinked_USCOREpathways:
		return soap_out_ns1__get_USCORElinked_USCOREpathways(soap, tag, id, (const struct ns1__get_USCORElinked_USCOREpathways *)ptr, "ns1:get_linked_pathways");
	case SOAP_TYPE_ns1__get_USCORElinked_USCOREpathwaysResponse:
		return soap_out_ns1__get_USCORElinked_USCOREpathwaysResponse(soap, tag, id, (const struct ns1__get_USCORElinked_USCOREpathwaysResponse *)ptr, "ns1:get_linked_pathwaysResponse");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactions:
		return soap_out_ns1__get_USCOREpathways_USCOREby_USCOREreactions(soap, tag, id, (const struct ns1__get_USCOREpathways_USCOREby_USCOREreactions *)ptr, "ns1:get_pathways_by_reactions");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse:
		return soap_out_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(soap, tag, id, (const struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse *)ptr, "ns1:get_pathways_by_reactionsResponse");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymes:
		return soap_out_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(soap, tag, id, (const struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes *)ptr, "ns1:get_pathways_by_enzymes");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse:
		return soap_out_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(soap, tag, id, (const struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse *)ptr, "ns1:get_pathways_by_enzymesResponse");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenes:
		return soap_out_ns1__get_USCOREpathways_USCOREby_USCOREgenes(soap, tag, id, (const struct ns1__get_USCOREpathways_USCOREby_USCOREgenes *)ptr, "ns1:get_pathways_by_genes");
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse:
		return soap_out_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(soap, tag, id, (const struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse *)ptr, "ns1:get_pathways_by_genesResponse");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathway:
		return soap_out_ns1__get_USCOREreactions_USCOREby_USCOREpathway(soap, tag, id, (const struct ns1__get_USCOREreactions_USCOREby_USCOREpathway *)ptr, "ns1:get_reactions_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse:
		return soap_out_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(soap, tag, id, (const struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse *)ptr, "ns1:get_reactions_by_pathwayResponse");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathway:
		return soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(soap, tag, id, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway *)ptr, "ns1:get_enzymes_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse:
		return soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(soap, tag, id, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse *)ptr, "ns1:get_enzymes_by_pathwayResponse");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathway:
		return soap_out_ns1__get_USCOREgenes_USCOREby_USCOREpathway(soap, tag, id, (const struct ns1__get_USCOREgenes_USCOREby_USCOREpathway *)ptr, "ns1:get_genes_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse:
		return soap_out_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(soap, tag, id, (const struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse *)ptr, "ns1:get_genes_by_pathwayResponse");
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects:
		return soap_out_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(soap, tag, id, (const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects *)ptr, "ns1:get_html_of_colored_pathway_by_objects");
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse:
		return soap_out_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, tag, id, (const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse *)ptr, "ns1:get_html_of_colored_pathway_by_objectsResponse");
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects:
		return soap_out_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(soap, tag, id, (const struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects *)ptr, "ns1:get_html_of_marked_pathway_by_objects");
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse:
		return soap_out_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, tag, id, (const struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse *)ptr, "ns1:get_html_of_marked_pathway_by_objectsResponse");
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjects:
		return soap_out_ns1__color_USCOREpathway_USCOREby_USCOREobjects(soap, tag, id, (const struct ns1__color_USCOREpathway_USCOREby_USCOREobjects *)ptr, "ns1:color_pathway_by_objects");
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse:
		return soap_out_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, tag, id, (const struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse *)ptr, "ns1:color_pathway_by_objectsResponse");
	case SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjects:
		return soap_out_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(soap, tag, id, (const struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects *)ptr, "ns1:mark_pathway_by_objects");
	case SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse:
		return soap_out_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, tag, id, (const struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse *)ptr, "ns1:mark_pathway_by_objectsResponse");
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements:
		return soap_out_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(soap, tag, id, (const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements *)ptr, "ns1:get_html_of_colored_pathway_by_elements");
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse:
		return soap_out_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(soap, tag, id, (const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse *)ptr, "ns1:get_html_of_colored_pathway_by_elementsResponse");
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelements:
		return soap_out_ns1__color_USCOREpathway_USCOREby_USCOREelements(soap, tag, id, (const struct ns1__color_USCOREpathway_USCOREby_USCOREelements *)ptr, "ns1:color_pathway_by_elements");
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse:
		return soap_out_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(soap, tag, id, (const struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse *)ptr, "ns1:color_pathway_by_elementsResponse");
	case SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway:
		return soap_out_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(soap, tag, id, (const struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway *)ptr, "ns1:get_element_relations_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse:
		return soap_out_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(soap, tag, id, (const struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse *)ptr, "ns1:get_element_relations_by_pathwayResponse");
	case SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathway:
		return soap_out_ns1__get_USCOREelements_USCOREby_USCOREpathway(soap, tag, id, (const struct ns1__get_USCOREelements_USCOREby_USCOREpathway *)ptr, "ns1:get_elements_by_pathway");
	case SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse:
		return soap_out_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(soap, tag, id, (const struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse *)ptr, "ns1:get_elements_by_pathwayResponse");
	case SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene:
		return soap_out_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(soap, tag, id, (const struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene *)ptr, "ns1:get_pc_members_by_gene");
	case SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse:
		return soap_out_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, tag, id, (const struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse *)ptr, "ns1:get_pc_members_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene:
		return soap_out_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(soap, tag, id, (const struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene *)ptr, "ns1:get_oc_members_by_gene");
	case SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse:
		return soap_out_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, tag, id, (const struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse *)ptr, "ns1:get_oc_members_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass:
		return soap_out_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(soap, tag, id, (const struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass *)ptr, "ns1:get_genes_by_ko_class");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse:
		return soap_out_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(soap, tag, id, (const struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse *)ptr, "ns1:get_genes_by_ko_classResponse");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko:
		return soap_out_ns1__get_USCOREgenes_USCOREby_USCOREko(soap, tag, id, (const struct ns1__get_USCOREgenes_USCOREby_USCOREko *)ptr, "ns1:get_genes_by_ko");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse:
		return soap_out_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(soap, tag, id, (const struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse *)ptr, "ns1:get_genes_by_koResponse");
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass:
		return soap_out_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(soap, tag, id, (const struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass *)ptr, "ns1:get_ko_by_ko_class");
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse:
		return soap_out_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(soap, tag, id, (const struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse *)ptr, "ns1:get_ko_by_ko_classResponse");
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgene:
		return soap_out_ns1__get_USCOREko_USCOREby_USCOREgene(soap, tag, id, (const struct ns1__get_USCOREko_USCOREby_USCOREgene *)ptr, "ns1:get_ko_by_gene");
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgeneResponse:
		return soap_out_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(soap, tag, id, (const struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse *)ptr, "ns1:get_ko_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifs:
		return soap_out_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(soap, tag, id, (const struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs *)ptr, "ns1:get_genes_by_motifs");
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse:
		return soap_out_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(soap, tag, id, (const struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse *)ptr, "ns1:get_genes_by_motifsResponse");
	case SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgene:
		return soap_out_ns1__get_USCOREmotifs_USCOREby_USCOREgene(soap, tag, id, (const struct ns1__get_USCOREmotifs_USCOREby_USCOREgene *)ptr, "ns1:get_motifs_by_gene");
	case SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse:
		return soap_out_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(soap, tag, id, (const struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse *)ptr, "ns1:get_motifs_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgene:
		return soap_out_ns1__get_USCOREparalogs_USCOREby_USCOREgene(soap, tag, id, (const struct ns1__get_USCOREparalogs_USCOREby_USCOREgene *)ptr, "ns1:get_paralogs_by_gene");
	case SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse:
		return soap_out_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(soap, tag, id, (const struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse *)ptr, "ns1:get_paralogs_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene:
		return soap_out_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, tag, id, (const struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *)ptr, "ns1:get_reverse_best_neighbors_by_gene");
	case SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse:
		return soap_out_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, tag, id, (const struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *)ptr, "ns1:get_reverse_best_neighbors_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene:
		return soap_out_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, tag, id, (const struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *)ptr, "ns1:get_best_best_neighbors_by_gene");
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse:
		return soap_out_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, tag, id, (const struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *)ptr, "ns1:get_best_best_neighbors_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene:
		return soap_out_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, tag, id, (const struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *)ptr, "ns1:get_best_neighbors_by_gene");
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse:
		return soap_out_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, tag, id, (const struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *)ptr, "ns1:get_best_neighbors_by_geneResponse");
	case SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentry:
		return soap_out_ns1__get_USCORElinkdb_USCOREby_USCOREentry(soap, tag, id, (const struct ns1__get_USCORElinkdb_USCOREby_USCOREentry *)ptr, "ns1:get_linkdb_by_entry");
	case SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse:
		return soap_out_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(soap, tag, id, (const struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse *)ptr, "ns1:get_linkdb_by_entryResponse");
	case SOAP_TYPE_ns1__bconv:
		return soap_out_ns1__bconv(soap, tag, id, (const struct ns1__bconv *)ptr, "ns1:bconv");
	case SOAP_TYPE_ns1__bconvResponse:
		return soap_out_ns1__bconvResponse(soap, tag, id, (const struct ns1__bconvResponse *)ptr, "ns1:bconvResponse");
	case SOAP_TYPE_ns1__btit:
		return soap_out_ns1__btit(soap, tag, id, (const struct ns1__btit *)ptr, "ns1:btit");
	case SOAP_TYPE_ns1__btitResponse:
		return soap_out_ns1__btitResponse(soap, tag, id, (const struct ns1__btitResponse *)ptr, "ns1:btitResponse");
	case SOAP_TYPE_ns1__bfind:
		return soap_out_ns1__bfind(soap, tag, id, (const struct ns1__bfind *)ptr, "ns1:bfind");
	case SOAP_TYPE_ns1__bfindResponse:
		return soap_out_ns1__bfindResponse(soap, tag, id, (const struct ns1__bfindResponse *)ptr, "ns1:bfindResponse");
	case SOAP_TYPE_ns1__bget:
		return soap_out_ns1__bget(soap, tag, id, (const struct ns1__bget *)ptr, "ns1:bget");
	case SOAP_TYPE_ns1__bgetResponse:
		return soap_out_ns1__bgetResponse(soap, tag, id, (const struct ns1__bgetResponse *)ptr, "ns1:bgetResponse");
	case SOAP_TYPE_ns1__binfo:
		return soap_out_ns1__binfo(soap, tag, id, (const struct ns1__binfo *)ptr, "ns1:binfo");
	case SOAP_TYPE_ns1__binfoResponse:
		return soap_out_ns1__binfoResponse(soap, tag, id, (const struct ns1__binfoResponse *)ptr, "ns1:binfoResponse");
	case SOAP_TYPE_ns1__list_USCOREko_USCOREclasses:
		return soap_out_ns1__list_USCOREko_USCOREclasses(soap, tag, id, (const struct ns1__list_USCOREko_USCOREclasses *)ptr, "ns1:list_ko_classes");
	case SOAP_TYPE_ns1__list_USCOREko_USCOREclassesResponse:
		return soap_out_ns1__list_USCOREko_USCOREclassesResponse(soap, tag, id, (const struct ns1__list_USCOREko_USCOREclassesResponse *)ptr, "ns1:list_ko_classesResponse");
	case SOAP_TYPE_ns1__list_USCOREpathways:
		return soap_out_ns1__list_USCOREpathways(soap, tag, id, (const struct ns1__list_USCOREpathways *)ptr, "ns1:list_pathways");
	case SOAP_TYPE_ns1__list_USCOREpathwaysResponse:
		return soap_out_ns1__list_USCOREpathwaysResponse(soap, tag, id, (const struct ns1__list_USCOREpathwaysResponse *)ptr, "ns1:list_pathwaysResponse");
	case SOAP_TYPE_ns1__list_USCOREorganisms:
		return soap_out_ns1__list_USCOREorganisms(soap, tag, id, (const struct ns1__list_USCOREorganisms *)ptr, "ns1:list_organisms");
	case SOAP_TYPE_ns1__list_USCOREorganismsResponse:
		return soap_out_ns1__list_USCOREorganismsResponse(soap, tag, id, (const struct ns1__list_USCOREorganismsResponse *)ptr, "ns1:list_organismsResponse");
	case SOAP_TYPE_ns1__list_USCOREdatabases:
		return soap_out_ns1__list_USCOREdatabases(soap, tag, id, (const struct ns1__list_USCOREdatabases *)ptr, "ns1:list_databases");
	case SOAP_TYPE_ns1__list_USCOREdatabasesResponse:
		return soap_out_ns1__list_USCOREdatabasesResponse(soap, tag, id, (const struct ns1__list_USCOREdatabasesResponse *)ptr, "ns1:list_databasesResponse");
	case SOAP_TYPE_PointerToArrayOfPathwayElementRelation:
		return soap_out_PointerToArrayOfPathwayElementRelation(soap, tag, id, (ArrayOfPathwayElementRelation *const*)ptr, "ns1:PathwayElementRelation");
	case SOAP_TYPE_PointerToArrayOfPathwayElement:
		return soap_out_PointerToArrayOfPathwayElement(soap, tag, id, (ArrayOfPathwayElement *const*)ptr, "ns1:PathwayElement");
	case SOAP_TYPE_PointerToArrayOfMotifResult:
		return soap_out_PointerToArrayOfMotifResult(soap, tag, id, (ArrayOfMotifResult *const*)ptr, "ns1:MotifResult");
	case SOAP_TYPE_PointerToArrayOfSSDBRelation:
		return soap_out_PointerToArrayOfSSDBRelation(soap, tag, id, (ArrayOfSSDBRelation *const*)ptr, "ns1:SSDBRelation");
	case SOAP_TYPE_PointerToArrayOfLinkDBRelation:
		return soap_out_PointerToArrayOfLinkDBRelation(soap, tag, id, (ArrayOfLinkDBRelation *const*)ptr, "ns1:LinkDBRelation");
	case SOAP_TYPE_PointerToArrayOfDefinition:
		return soap_out_PointerToArrayOfDefinition(soap, tag, id, (ArrayOfDefinition *const*)ptr, "ns1:Definition");
	case SOAP_TYPE_PointerToPointerTons1__Subtype:
		return soap_out_PointerToPointerTons1__Subtype(soap, tag, id, (ns1__Subtype **const*)ptr, "ns1:Subtype");
	case SOAP_TYPE_PointerTons1__Subtype:
		return soap_out_PointerTons1__Subtype(soap, tag, id, (ns1__Subtype *const*)ptr, "ns1:Subtype");
	case SOAP_TYPE_PointerToPointerTons1__PathwayElementRelation:
		return soap_out_PointerToPointerTons1__PathwayElementRelation(soap, tag, id, (ns1__PathwayElementRelation **const*)ptr, "ns1:PathwayElementRelation");
	case SOAP_TYPE_PointerTons1__PathwayElementRelation:
		return soap_out_PointerTons1__PathwayElementRelation(soap, tag, id, (ns1__PathwayElementRelation *const*)ptr, "ns1:PathwayElementRelation");
	case SOAP_TYPE_PointerToPointerTons1__PathwayElement:
		return soap_out_PointerToPointerTons1__PathwayElement(soap, tag, id, (ns1__PathwayElement **const*)ptr, "ns1:PathwayElement");
	case SOAP_TYPE_PointerTons1__PathwayElement:
		return soap_out_PointerTons1__PathwayElement(soap, tag, id, (ns1__PathwayElement *const*)ptr, "ns1:PathwayElement");
	case SOAP_TYPE_PointerToPointerTons1__LinkDBRelation:
		return soap_out_PointerToPointerTons1__LinkDBRelation(soap, tag, id, (ns1__LinkDBRelation **const*)ptr, "ns1:LinkDBRelation");
	case SOAP_TYPE_PointerTons1__LinkDBRelation:
		return soap_out_PointerTons1__LinkDBRelation(soap, tag, id, (ns1__LinkDBRelation *const*)ptr, "ns1:LinkDBRelation");
	case SOAP_TYPE_PointerToPointerTons1__Definition:
		return soap_out_PointerToPointerTons1__Definition(soap, tag, id, (ns1__Definition **const*)ptr, "ns1:Definition");
	case SOAP_TYPE_PointerTons1__Definition:
		return soap_out_PointerTons1__Definition(soap, tag, id, (ns1__Definition *const*)ptr, "ns1:Definition");
	case SOAP_TYPE_PointerToPointerTons1__MotifResult:
		return soap_out_PointerToPointerTons1__MotifResult(soap, tag, id, (ns1__MotifResult **const*)ptr, "ns1:MotifResult");
	case SOAP_TYPE_PointerTons1__MotifResult:
		return soap_out_PointerTons1__MotifResult(soap, tag, id, (ns1__MotifResult *const*)ptr, "ns1:MotifResult");
	case SOAP_TYPE_PointerToPointerTons1__SSDBRelation:
		return soap_out_PointerToPointerTons1__SSDBRelation(soap, tag, id, (ns1__SSDBRelation **const*)ptr, "ns1:SSDBRelation");
	case SOAP_TYPE_PointerTons1__SSDBRelation:
		return soap_out_PointerTons1__SSDBRelation(soap, tag, id, (ns1__SSDBRelation *const*)ptr, "ns1:SSDBRelation");
	case SOAP_TYPE_PointerToPointerTostd__string:
		return soap_out_PointerToPointerTostd__string(soap, tag, id, (std::string **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToArrayOfSubtype:
		return soap_out_PointerToArrayOfSubtype(soap, tag, id, (ArrayOfSubtype *const*)ptr, "ns1:Subtype");
	case SOAP_TYPE_PointerToArrayOfint:
		return soap_out_PointerToArrayOfint(soap, tag, id, (ArrayOfint *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToArrayOfstring:
		return soap_out_PointerToArrayOfstring(soap, tag, id, (ArrayOfstring *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ArrayOfSubtype:
		((ArrayOfSubtype *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Subtype:
		((ns1__Subtype *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfPathwayElementRelation:
		((ArrayOfPathwayElementRelation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PathwayElementRelation:
		((ns1__PathwayElementRelation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfPathwayElement:
		((ArrayOfPathwayElement *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PathwayElement:
		((ns1__PathwayElement *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfLinkDBRelation:
		((ArrayOfLinkDBRelation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LinkDBRelation:
		((ns1__LinkDBRelation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfDefinition:
		((ArrayOfDefinition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Definition:
		((ns1__Definition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfMotifResult:
		((ArrayOfMotifResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MotifResult:
		((ns1__MotifResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfSSDBRelation:
		((ArrayOfSSDBRelation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SSDBRelation:
		((ns1__SSDBRelation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfstring:
		((ArrayOfstring *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfint:
		((ArrayOfint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__SOAP_ENC__arrayType:
		soap_serialize__SOAP_ENC__arrayType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkos:
		soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREkos(soap, (const struct ns1__get_USCOREpathways_USCOREby_USCOREkos *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse:
		soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(soap, (const struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathway:
		soap_serialize_ns1__get_USCOREkos_USCOREby_USCOREpathway(soap, (const struct ns1__get_USCOREkos_USCOREby_USCOREpathway *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse:
		soap_serialize_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(soap, (const struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcf:
		soap_serialize_ns1__convert_USCOREmol_USCOREto_USCOREkcf(soap, (const struct ns1__convert_USCOREmol_USCOREto_USCOREkcf *)ptr);
		break;
	case SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse:
		soap_serialize_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(soap, (const struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzyme:
		soap_serialize_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(soap, (const struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse:
		soap_serialize_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(soap, (const struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme:
		soap_serialize_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(soap, (const struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse:
		soap_serialize_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(soap, (const struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreaction:
		soap_serialize_ns1__get_USCOREglycans_USCOREby_USCOREreaction(soap, (const struct ns1__get_USCOREglycans_USCOREby_USCOREreaction *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse:
		soap_serialize_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(soap, (const struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreaction:
		soap_serialize_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(soap, (const struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse:
		soap_serialize_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(soap, (const struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathway:
		soap_serialize_ns1__get_USCOREglycans_USCOREby_USCOREpathway(soap, (const struct ns1__get_USCOREglycans_USCOREby_USCOREpathway *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse:
		soap_serialize_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(soap, (const struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathway:
		soap_serialize_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(soap, (const struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse:
		soap_serialize_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(soap, (const struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycans:
		soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREglycans(soap, (const struct ns1__get_USCOREpathways_USCOREby_USCOREglycans *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse:
		soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(soap, (const struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompounds:
		soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(soap, (const struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse:
		soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(soap, (const struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompound:
		soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(soap, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse:
		soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(soap, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycan:
		soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(soap, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse:
		soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(soap, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompound:
		soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREcompound(soap, (const struct ns1__get_USCOREreactions_USCOREby_USCOREcompound *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse:
		soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(soap, (const struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycan:
		soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREglycan(soap, (const struct ns1__get_USCOREreactions_USCOREby_USCOREglycan *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse:
		soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(soap, (const struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism:
		soap_serialize_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(soap, (const struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse:
		soap_serialize_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(soap, (const struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganism:
		soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREorganism(soap, (const struct ns1__get_USCOREgenes_USCOREby_USCOREorganism *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse:
		soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(soap, (const struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzyme:
		soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(soap, (const struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse:
		soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(soap, (const struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreaction:
		soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(soap, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse:
		soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(soap, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgene:
		soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREgene(soap, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREgene *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse:
		soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(soap, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzyme:
		soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(soap, (const struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse:
		soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(soap, (const struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCORElinked_USCOREpathways:
		soap_serialize_ns1__get_USCORElinked_USCOREpathways(soap, (const struct ns1__get_USCORElinked_USCOREpathways *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCORElinked_USCOREpathwaysResponse:
		soap_serialize_ns1__get_USCORElinked_USCOREpathwaysResponse(soap, (const struct ns1__get_USCORElinked_USCOREpathwaysResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactions:
		soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREreactions(soap, (const struct ns1__get_USCOREpathways_USCOREby_USCOREreactions *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse:
		soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(soap, (const struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymes:
		soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(soap, (const struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse:
		soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(soap, (const struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenes:
		soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREgenes(soap, (const struct ns1__get_USCOREpathways_USCOREby_USCOREgenes *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse:
		soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(soap, (const struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathway:
		soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREpathway(soap, (const struct ns1__get_USCOREreactions_USCOREby_USCOREpathway *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse:
		soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(soap, (const struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathway:
		soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(soap, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse:
		soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(soap, (const struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathway:
		soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREpathway(soap, (const struct ns1__get_USCOREgenes_USCOREby_USCOREpathway *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse:
		soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(soap, (const struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects:
		soap_serialize_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(soap, (const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse:
		soap_serialize_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, (const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects:
		soap_serialize_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(soap, (const struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse:
		soap_serialize_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, (const struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjects:
		soap_serialize_ns1__color_USCOREpathway_USCOREby_USCOREobjects(soap, (const struct ns1__color_USCOREpathway_USCOREby_USCOREobjects *)ptr);
		break;
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse:
		soap_serialize_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, (const struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjects:
		soap_serialize_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(soap, (const struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects *)ptr);
		break;
	case SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse:
		soap_serialize_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, (const struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements:
		soap_serialize_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(soap, (const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse:
		soap_serialize_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(soap, (const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelements:
		soap_serialize_ns1__color_USCOREpathway_USCOREby_USCOREelements(soap, (const struct ns1__color_USCOREpathway_USCOREby_USCOREelements *)ptr);
		break;
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse:
		soap_serialize_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(soap, (const struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway:
		soap_serialize_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(soap, (const struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse:
		soap_serialize_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(soap, (const struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathway:
		soap_serialize_ns1__get_USCOREelements_USCOREby_USCOREpathway(soap, (const struct ns1__get_USCOREelements_USCOREby_USCOREpathway *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse:
		soap_serialize_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(soap, (const struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene:
		soap_serialize_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(soap, (const struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse:
		soap_serialize_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, (const struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene:
		soap_serialize_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(soap, (const struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse:
		soap_serialize_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, (const struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass:
		soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(soap, (const struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse:
		soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(soap, (const struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko:
		soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREko(soap, (const struct ns1__get_USCOREgenes_USCOREby_USCOREko *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse:
		soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(soap, (const struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass:
		soap_serialize_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(soap, (const struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse:
		soap_serialize_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(soap, (const struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgene:
		soap_serialize_ns1__get_USCOREko_USCOREby_USCOREgene(soap, (const struct ns1__get_USCOREko_USCOREby_USCOREgene *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgeneResponse:
		soap_serialize_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(soap, (const struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifs:
		soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(soap, (const struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse:
		soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(soap, (const struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgene:
		soap_serialize_ns1__get_USCOREmotifs_USCOREby_USCOREgene(soap, (const struct ns1__get_USCOREmotifs_USCOREby_USCOREgene *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse:
		soap_serialize_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(soap, (const struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgene:
		soap_serialize_ns1__get_USCOREparalogs_USCOREby_USCOREgene(soap, (const struct ns1__get_USCOREparalogs_USCOREby_USCOREgene *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse:
		soap_serialize_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(soap, (const struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene:
		soap_serialize_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, (const struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse:
		soap_serialize_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, (const struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene:
		soap_serialize_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, (const struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse:
		soap_serialize_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, (const struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene:
		soap_serialize_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, (const struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse:
		soap_serialize_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, (const struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentry:
		soap_serialize_ns1__get_USCORElinkdb_USCOREby_USCOREentry(soap, (const struct ns1__get_USCORElinkdb_USCOREby_USCOREentry *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse:
		soap_serialize_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(soap, (const struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__bconv:
		soap_serialize_ns1__bconv(soap, (const struct ns1__bconv *)ptr);
		break;
	case SOAP_TYPE_ns1__bconvResponse:
		soap_serialize_ns1__bconvResponse(soap, (const struct ns1__bconvResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__btit:
		soap_serialize_ns1__btit(soap, (const struct ns1__btit *)ptr);
		break;
	case SOAP_TYPE_ns1__btitResponse:
		soap_serialize_ns1__btitResponse(soap, (const struct ns1__btitResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__bfind:
		soap_serialize_ns1__bfind(soap, (const struct ns1__bfind *)ptr);
		break;
	case SOAP_TYPE_ns1__bfindResponse:
		soap_serialize_ns1__bfindResponse(soap, (const struct ns1__bfindResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__bget:
		soap_serialize_ns1__bget(soap, (const struct ns1__bget *)ptr);
		break;
	case SOAP_TYPE_ns1__bgetResponse:
		soap_serialize_ns1__bgetResponse(soap, (const struct ns1__bgetResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__binfo:
		soap_serialize_ns1__binfo(soap, (const struct ns1__binfo *)ptr);
		break;
	case SOAP_TYPE_ns1__binfoResponse:
		soap_serialize_ns1__binfoResponse(soap, (const struct ns1__binfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__list_USCOREko_USCOREclasses:
		soap_serialize_ns1__list_USCOREko_USCOREclasses(soap, (const struct ns1__list_USCOREko_USCOREclasses *)ptr);
		break;
	case SOAP_TYPE_ns1__list_USCOREko_USCOREclassesResponse:
		soap_serialize_ns1__list_USCOREko_USCOREclassesResponse(soap, (const struct ns1__list_USCOREko_USCOREclassesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__list_USCOREpathways:
		soap_serialize_ns1__list_USCOREpathways(soap, (const struct ns1__list_USCOREpathways *)ptr);
		break;
	case SOAP_TYPE_ns1__list_USCOREpathwaysResponse:
		soap_serialize_ns1__list_USCOREpathwaysResponse(soap, (const struct ns1__list_USCOREpathwaysResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__list_USCOREorganisms:
		soap_serialize_ns1__list_USCOREorganisms(soap, (const struct ns1__list_USCOREorganisms *)ptr);
		break;
	case SOAP_TYPE_ns1__list_USCOREorganismsResponse:
		soap_serialize_ns1__list_USCOREorganismsResponse(soap, (const struct ns1__list_USCOREorganismsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__list_USCOREdatabases:
		soap_serialize_ns1__list_USCOREdatabases(soap, (const struct ns1__list_USCOREdatabases *)ptr);
		break;
	case SOAP_TYPE_ns1__list_USCOREdatabasesResponse:
		soap_serialize_ns1__list_USCOREdatabasesResponse(soap, (const struct ns1__list_USCOREdatabasesResponse *)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfPathwayElementRelation:
		soap_serialize_PointerToArrayOfPathwayElementRelation(soap, (ArrayOfPathwayElementRelation *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfPathwayElement:
		soap_serialize_PointerToArrayOfPathwayElement(soap, (ArrayOfPathwayElement *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfMotifResult:
		soap_serialize_PointerToArrayOfMotifResult(soap, (ArrayOfMotifResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfSSDBRelation:
		soap_serialize_PointerToArrayOfSSDBRelation(soap, (ArrayOfSSDBRelation *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfLinkDBRelation:
		soap_serialize_PointerToArrayOfLinkDBRelation(soap, (ArrayOfLinkDBRelation *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfDefinition:
		soap_serialize_PointerToArrayOfDefinition(soap, (ArrayOfDefinition *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Subtype:
		soap_serialize_PointerToPointerTons1__Subtype(soap, (ns1__Subtype **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Subtype:
		soap_serialize_PointerTons1__Subtype(soap, (ns1__Subtype *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__PathwayElementRelation:
		soap_serialize_PointerToPointerTons1__PathwayElementRelation(soap, (ns1__PathwayElementRelation **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PathwayElementRelation:
		soap_serialize_PointerTons1__PathwayElementRelation(soap, (ns1__PathwayElementRelation *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__PathwayElement:
		soap_serialize_PointerToPointerTons1__PathwayElement(soap, (ns1__PathwayElement **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PathwayElement:
		soap_serialize_PointerTons1__PathwayElement(soap, (ns1__PathwayElement *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__LinkDBRelation:
		soap_serialize_PointerToPointerTons1__LinkDBRelation(soap, (ns1__LinkDBRelation **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LinkDBRelation:
		soap_serialize_PointerTons1__LinkDBRelation(soap, (ns1__LinkDBRelation *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Definition:
		soap_serialize_PointerToPointerTons1__Definition(soap, (ns1__Definition **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Definition:
		soap_serialize_PointerTons1__Definition(soap, (ns1__Definition *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__MotifResult:
		soap_serialize_PointerToPointerTons1__MotifResult(soap, (ns1__MotifResult **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MotifResult:
		soap_serialize_PointerTons1__MotifResult(soap, (ns1__MotifResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__SSDBRelation:
		soap_serialize_PointerToPointerTons1__SSDBRelation(soap, (ns1__SSDBRelation **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SSDBRelation:
		soap_serialize_PointerTons1__SSDBRelation(soap, (ns1__SSDBRelation *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTostd__string:
		soap_serialize_PointerToPointerTostd__string(soap, (std::string **const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfSubtype:
		soap_serialize_PointerToArrayOfSubtype(soap, (ArrayOfSubtype *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfint:
		soap_serialize_PointerToArrayOfint(soap, (ArrayOfint *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfstring:
		soap_serialize_PointerToArrayOfstring(soap, (ArrayOfstring *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SSDBRelation:
		return (void*)soap_instantiate_ns1__SSDBRelation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MotifResult:
		return (void*)soap_instantiate_ns1__MotifResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Definition:
		return (void*)soap_instantiate_ns1__Definition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LinkDBRelation:
		return (void*)soap_instantiate_ns1__LinkDBRelation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PathwayElement:
		return (void*)soap_instantiate_ns1__PathwayElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PathwayElementRelation:
		return (void*)soap_instantiate_ns1__PathwayElementRelation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Subtype:
		return (void*)soap_instantiate_ns1__Subtype(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfint:
		return (void*)soap_instantiate_ArrayOfint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfstring:
		return (void*)soap_instantiate_ArrayOfstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfSSDBRelation:
		return (void*)soap_instantiate_ArrayOfSSDBRelation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfMotifResult:
		return (void*)soap_instantiate_ArrayOfMotifResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfDefinition:
		return (void*)soap_instantiate_ArrayOfDefinition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfLinkDBRelation:
		return (void*)soap_instantiate_ArrayOfLinkDBRelation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfPathwayElement:
		return (void*)soap_instantiate_ArrayOfPathwayElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfPathwayElementRelation:
		return (void*)soap_instantiate_ArrayOfPathwayElementRelation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfSubtype:
		return (void*)soap_instantiate_ArrayOfSubtype(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__list_USCOREdatabasesResponse:
		return (void*)soap_instantiate_ns1__list_USCOREdatabasesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__list_USCOREdatabases:
		return (void*)soap_instantiate_ns1__list_USCOREdatabases(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__list_USCOREorganismsResponse:
		return (void*)soap_instantiate_ns1__list_USCOREorganismsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__list_USCOREorganisms:
		return (void*)soap_instantiate_ns1__list_USCOREorganisms(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__list_USCOREpathwaysResponse:
		return (void*)soap_instantiate_ns1__list_USCOREpathwaysResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__list_USCOREpathways:
		return (void*)soap_instantiate_ns1__list_USCOREpathways(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__list_USCOREko_USCOREclassesResponse:
		return (void*)soap_instantiate_ns1__list_USCOREko_USCOREclassesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__list_USCOREko_USCOREclasses:
		return (void*)soap_instantiate_ns1__list_USCOREko_USCOREclasses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__binfoResponse:
		return (void*)soap_instantiate_ns1__binfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__binfo:
		return (void*)soap_instantiate_ns1__binfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__bgetResponse:
		return (void*)soap_instantiate_ns1__bgetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__bget:
		return (void*)soap_instantiate_ns1__bget(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__bfindResponse:
		return (void*)soap_instantiate_ns1__bfindResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__bfind:
		return (void*)soap_instantiate_ns1__bfind(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__btitResponse:
		return (void*)soap_instantiate_ns1__btitResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__btit:
		return (void*)soap_instantiate_ns1__btit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__bconvResponse:
		return (void*)soap_instantiate_ns1__bconvResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__bconv:
		return (void*)soap_instantiate_ns1__bconv(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse:
		return (void*)soap_instantiate_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentry:
		return (void*)soap_instantiate_ns1__get_USCORElinkdb_USCOREby_USCOREentry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse:
		return (void*)soap_instantiate_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene:
		return (void*)soap_instantiate_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse:
		return (void*)soap_instantiate_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene:
		return (void*)soap_instantiate_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse:
		return (void*)soap_instantiate_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene:
		return (void*)soap_instantiate_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse:
		return (void*)soap_instantiate_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgene:
		return (void*)soap_instantiate_ns1__get_USCOREparalogs_USCOREby_USCOREgene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse:
		return (void*)soap_instantiate_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgene:
		return (void*)soap_instantiate_ns1__get_USCOREmotifs_USCOREby_USCOREgene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse:
		return (void*)soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifs:
		return (void*)soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgeneResponse:
		return (void*)soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgene:
		return (void*)soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREgene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse:
		return (void*)soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass:
		return (void*)soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse:
		return (void*)soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko:
		return (void*)soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREko(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse:
		return (void*)soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass:
		return (void*)soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse:
		return (void*)soap_instantiate_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene:
		return (void*)soap_instantiate_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse:
		return (void*)soap_instantiate_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene:
		return (void*)soap_instantiate_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse:
		return (void*)soap_instantiate_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathway:
		return (void*)soap_instantiate_ns1__get_USCOREelements_USCOREby_USCOREpathway(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse:
		return (void*)soap_instantiate_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway:
		return (void*)soap_instantiate_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse:
		return (void*)soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelements:
		return (void*)soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREelements(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse:
		return (void*)soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements:
		return (void*)soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse:
		return (void*)soap_instantiate_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjects:
		return (void*)soap_instantiate_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse:
		return (void*)soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjects:
		return (void*)soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREobjects(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse:
		return (void*)soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects:
		return (void*)soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse:
		return (void*)soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects:
		return (void*)soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse:
		return (void*)soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathway:
		return (void*)soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREpathway(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse:
		return (void*)soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathway:
		return (void*)soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse:
		return (void*)soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathway:
		return (void*)soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREpathway(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse:
		return (void*)soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenes:
		return (void*)soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREgenes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse:
		return (void*)soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymes:
		return (void*)soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse:
		return (void*)soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactions:
		return (void*)soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREreactions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCORElinked_USCOREpathwaysResponse:
		return (void*)soap_instantiate_ns1__get_USCORElinked_USCOREpathwaysResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCORElinked_USCOREpathways:
		return (void*)soap_instantiate_ns1__get_USCORElinked_USCOREpathways(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse:
		return (void*)soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzyme:
		return (void*)soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse:
		return (void*)soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgene:
		return (void*)soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREgene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse:
		return (void*)soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreaction:
		return (void*)soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse:
		return (void*)soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzyme:
		return (void*)soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse:
		return (void*)soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganism:
		return (void*)soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREorganism(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse:
		return (void*)soap_instantiate_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism:
		return (void*)soap_instantiate_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse:
		return (void*)soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycan:
		return (void*)soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREglycan(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse:
		return (void*)soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompound:
		return (void*)soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREcompound(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse:
		return (void*)soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycan:
		return (void*)soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse:
		return (void*)soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompound:
		return (void*)soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse:
		return (void*)soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompounds:
		return (void*)soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse:
		return (void*)soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycans:
		return (void*)soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREglycans(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse:
		return (void*)soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathway:
		return (void*)soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse:
		return (void*)soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathway:
		return (void*)soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREpathway(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse:
		return (void*)soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreaction:
		return (void*)soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse:
		return (void*)soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreaction:
		return (void*)soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREreaction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse:
		return (void*)soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme:
		return (void*)soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse:
		return (void*)soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzyme:
		return (void*)soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse:
		return (void*)soap_instantiate_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcf:
		return (void*)soap_instantiate_ns1__convert_USCOREmol_USCOREto_USCOREkcf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse:
		return (void*)soap_instantiate_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathway:
		return (void*)soap_instantiate_ns1__get_USCOREkos_USCOREby_USCOREpathway(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse:
		return (void*)soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkos:
		return (void*)soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREkos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__SOAP_ENC__arrayType:
		return (void*)soap_instantiate__SOAP_ENC__arrayType(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SSDBRelation:
		if (p->size < 0)
			delete (ns1__SSDBRelation*)p->ptr;
		else
			delete[] (ns1__SSDBRelation*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MotifResult:
		if (p->size < 0)
			delete (ns1__MotifResult*)p->ptr;
		else
			delete[] (ns1__MotifResult*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Definition:
		if (p->size < 0)
			delete (ns1__Definition*)p->ptr;
		else
			delete[] (ns1__Definition*)p->ptr;
		break;
	case SOAP_TYPE_ns1__LinkDBRelation:
		if (p->size < 0)
			delete (ns1__LinkDBRelation*)p->ptr;
		else
			delete[] (ns1__LinkDBRelation*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PathwayElement:
		if (p->size < 0)
			delete (ns1__PathwayElement*)p->ptr;
		else
			delete[] (ns1__PathwayElement*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PathwayElementRelation:
		if (p->size < 0)
			delete (ns1__PathwayElementRelation*)p->ptr;
		else
			delete[] (ns1__PathwayElementRelation*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Subtype:
		if (p->size < 0)
			delete (ns1__Subtype*)p->ptr;
		else
			delete[] (ns1__Subtype*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfint:
		if (p->size < 0)
			delete (ArrayOfint*)p->ptr;
		else
			delete[] (ArrayOfint*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfstring:
		if (p->size < 0)
			delete (ArrayOfstring*)p->ptr;
		else
			delete[] (ArrayOfstring*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfSSDBRelation:
		if (p->size < 0)
			delete (ArrayOfSSDBRelation*)p->ptr;
		else
			delete[] (ArrayOfSSDBRelation*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfMotifResult:
		if (p->size < 0)
			delete (ArrayOfMotifResult*)p->ptr;
		else
			delete[] (ArrayOfMotifResult*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfDefinition:
		if (p->size < 0)
			delete (ArrayOfDefinition*)p->ptr;
		else
			delete[] (ArrayOfDefinition*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfLinkDBRelation:
		if (p->size < 0)
			delete (ArrayOfLinkDBRelation*)p->ptr;
		else
			delete[] (ArrayOfLinkDBRelation*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfPathwayElement:
		if (p->size < 0)
			delete (ArrayOfPathwayElement*)p->ptr;
		else
			delete[] (ArrayOfPathwayElement*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfPathwayElementRelation:
		if (p->size < 0)
			delete (ArrayOfPathwayElementRelation*)p->ptr;
		else
			delete[] (ArrayOfPathwayElementRelation*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfSubtype:
		if (p->size < 0)
			delete (ArrayOfSubtype*)p->ptr;
		else
			delete[] (ArrayOfSubtype*)p->ptr;
		break;
	case SOAP_TYPE_ns1__list_USCOREdatabasesResponse:
		if (p->size < 0)
			delete (struct ns1__list_USCOREdatabasesResponse*)p->ptr;
		else
			delete[] (struct ns1__list_USCOREdatabasesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__list_USCOREdatabases:
		if (p->size < 0)
			delete (struct ns1__list_USCOREdatabases*)p->ptr;
		else
			delete[] (struct ns1__list_USCOREdatabases*)p->ptr;
		break;
	case SOAP_TYPE_ns1__list_USCOREorganismsResponse:
		if (p->size < 0)
			delete (struct ns1__list_USCOREorganismsResponse*)p->ptr;
		else
			delete[] (struct ns1__list_USCOREorganismsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__list_USCOREorganisms:
		if (p->size < 0)
			delete (struct ns1__list_USCOREorganisms*)p->ptr;
		else
			delete[] (struct ns1__list_USCOREorganisms*)p->ptr;
		break;
	case SOAP_TYPE_ns1__list_USCOREpathwaysResponse:
		if (p->size < 0)
			delete (struct ns1__list_USCOREpathwaysResponse*)p->ptr;
		else
			delete[] (struct ns1__list_USCOREpathwaysResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__list_USCOREpathways:
		if (p->size < 0)
			delete (struct ns1__list_USCOREpathways*)p->ptr;
		else
			delete[] (struct ns1__list_USCOREpathways*)p->ptr;
		break;
	case SOAP_TYPE_ns1__list_USCOREko_USCOREclassesResponse:
		if (p->size < 0)
			delete (struct ns1__list_USCOREko_USCOREclassesResponse*)p->ptr;
		else
			delete[] (struct ns1__list_USCOREko_USCOREclassesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__list_USCOREko_USCOREclasses:
		if (p->size < 0)
			delete (struct ns1__list_USCOREko_USCOREclasses*)p->ptr;
		else
			delete[] (struct ns1__list_USCOREko_USCOREclasses*)p->ptr;
		break;
	case SOAP_TYPE_ns1__binfoResponse:
		if (p->size < 0)
			delete (struct ns1__binfoResponse*)p->ptr;
		else
			delete[] (struct ns1__binfoResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__binfo:
		if (p->size < 0)
			delete (struct ns1__binfo*)p->ptr;
		else
			delete[] (struct ns1__binfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__bgetResponse:
		if (p->size < 0)
			delete (struct ns1__bgetResponse*)p->ptr;
		else
			delete[] (struct ns1__bgetResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__bget:
		if (p->size < 0)
			delete (struct ns1__bget*)p->ptr;
		else
			delete[] (struct ns1__bget*)p->ptr;
		break;
	case SOAP_TYPE_ns1__bfindResponse:
		if (p->size < 0)
			delete (struct ns1__bfindResponse*)p->ptr;
		else
			delete[] (struct ns1__bfindResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__bfind:
		if (p->size < 0)
			delete (struct ns1__bfind*)p->ptr;
		else
			delete[] (struct ns1__bfind*)p->ptr;
		break;
	case SOAP_TYPE_ns1__btitResponse:
		if (p->size < 0)
			delete (struct ns1__btitResponse*)p->ptr;
		else
			delete[] (struct ns1__btitResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__btit:
		if (p->size < 0)
			delete (struct ns1__btit*)p->ptr;
		else
			delete[] (struct ns1__btit*)p->ptr;
		break;
	case SOAP_TYPE_ns1__bconvResponse:
		if (p->size < 0)
			delete (struct ns1__bconvResponse*)p->ptr;
		else
			delete[] (struct ns1__bconvResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__bconv:
		if (p->size < 0)
			delete (struct ns1__bconv*)p->ptr;
		else
			delete[] (struct ns1__bconv*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentry:
		if (p->size < 0)
			delete (struct ns1__get_USCORElinkdb_USCOREby_USCOREentry*)p->ptr;
		else
			delete[] (struct ns1__get_USCORElinkdb_USCOREby_USCOREentry*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene:
		if (p->size < 0)
			delete (struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene:
		if (p->size < 0)
			delete (struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene:
		if (p->size < 0)
			delete (struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgene:
		if (p->size < 0)
			delete (struct ns1__get_USCOREparalogs_USCOREby_USCOREgene*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREparalogs_USCOREby_USCOREgene*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgene:
		if (p->size < 0)
			delete (struct ns1__get_USCOREmotifs_USCOREby_USCOREgene*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREmotifs_USCOREby_USCOREgene*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifs:
		if (p->size < 0)
			delete (struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgeneResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgene:
		if (p->size < 0)
			delete (struct ns1__get_USCOREko_USCOREby_USCOREgene*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREko_USCOREby_USCOREgene*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass:
		if (p->size < 0)
			delete (struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko:
		if (p->size < 0)
			delete (struct ns1__get_USCOREgenes_USCOREby_USCOREko*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREgenes_USCOREby_USCOREko*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass:
		if (p->size < 0)
			delete (struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene:
		if (p->size < 0)
			delete (struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene:
		if (p->size < 0)
			delete (struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathway:
		if (p->size < 0)
			delete (struct ns1__get_USCOREelements_USCOREby_USCOREpathway*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREelements_USCOREby_USCOREpathway*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway:
		if (p->size < 0)
			delete (struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway*)p->ptr;
		break;
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse:
		if (p->size < 0)
			delete (struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse*)p->ptr;
		else
			delete[] (struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelements:
		if (p->size < 0)
			delete (struct ns1__color_USCOREpathway_USCOREby_USCOREelements*)p->ptr;
		else
			delete[] (struct ns1__color_USCOREpathway_USCOREby_USCOREelements*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements:
		if (p->size < 0)
			delete (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements*)p->ptr;
		break;
	case SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse:
		if (p->size < 0)
			delete (struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse*)p->ptr;
		else
			delete[] (struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjects:
		if (p->size < 0)
			delete (struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects*)p->ptr;
		else
			delete[] (struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects*)p->ptr;
		break;
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse:
		if (p->size < 0)
			delete (struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse*)p->ptr;
		else
			delete[] (struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjects:
		if (p->size < 0)
			delete (struct ns1__color_USCOREpathway_USCOREby_USCOREobjects*)p->ptr;
		else
			delete[] (struct ns1__color_USCOREpathway_USCOREby_USCOREobjects*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects:
		if (p->size < 0)
			delete (struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects:
		if (p->size < 0)
			delete (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathway:
		if (p->size < 0)
			delete (struct ns1__get_USCOREgenes_USCOREby_USCOREpathway*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREgenes_USCOREby_USCOREpathway*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathway:
		if (p->size < 0)
			delete (struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathway:
		if (p->size < 0)
			delete (struct ns1__get_USCOREreactions_USCOREby_USCOREpathway*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREreactions_USCOREby_USCOREpathway*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenes:
		if (p->size < 0)
			delete (struct ns1__get_USCOREpathways_USCOREby_USCOREgenes*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREpathways_USCOREby_USCOREgenes*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymes:
		if (p->size < 0)
			delete (struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactions:
		if (p->size < 0)
			delete (struct ns1__get_USCOREpathways_USCOREby_USCOREreactions*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREpathways_USCOREby_USCOREreactions*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCORElinked_USCOREpathwaysResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCORElinked_USCOREpathwaysResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCORElinked_USCOREpathwaysResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCORElinked_USCOREpathways:
		if (p->size < 0)
			delete (struct ns1__get_USCORElinked_USCOREpathways*)p->ptr;
		else
			delete[] (struct ns1__get_USCORElinked_USCOREpathways*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzyme:
		if (p->size < 0)
			delete (struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgene:
		if (p->size < 0)
			delete (struct ns1__get_USCOREenzymes_USCOREby_USCOREgene*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREenzymes_USCOREby_USCOREgene*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreaction:
		if (p->size < 0)
			delete (struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzyme:
		if (p->size < 0)
			delete (struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganism:
		if (p->size < 0)
			delete (struct ns1__get_USCOREgenes_USCOREby_USCOREorganism*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREgenes_USCOREby_USCOREorganism*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism:
		if (p->size < 0)
			delete (struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycan:
		if (p->size < 0)
			delete (struct ns1__get_USCOREreactions_USCOREby_USCOREglycan*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREreactions_USCOREby_USCOREglycan*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompound:
		if (p->size < 0)
			delete (struct ns1__get_USCOREreactions_USCOREby_USCOREcompound*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREreactions_USCOREby_USCOREcompound*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycan:
		if (p->size < 0)
			delete (struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompound:
		if (p->size < 0)
			delete (struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompounds:
		if (p->size < 0)
			delete (struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycans:
		if (p->size < 0)
			delete (struct ns1__get_USCOREpathways_USCOREby_USCOREglycans*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREpathways_USCOREby_USCOREglycans*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathway:
		if (p->size < 0)
			delete (struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathway:
		if (p->size < 0)
			delete (struct ns1__get_USCOREglycans_USCOREby_USCOREpathway*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREglycans_USCOREby_USCOREpathway*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreaction:
		if (p->size < 0)
			delete (struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreaction:
		if (p->size < 0)
			delete (struct ns1__get_USCOREglycans_USCOREby_USCOREreaction*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREglycans_USCOREby_USCOREreaction*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme:
		if (p->size < 0)
			delete (struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzyme:
		if (p->size < 0)
			delete (struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme*)p->ptr;
		break;
	case SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse:
		if (p->size < 0)
			delete (struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse*)p->ptr;
		else
			delete[] (struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcf:
		if (p->size < 0)
			delete (struct ns1__convert_USCOREmol_USCOREto_USCOREkcf*)p->ptr;
		else
			delete[] (struct ns1__convert_USCOREmol_USCOREto_USCOREkcf*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathway:
		if (p->size < 0)
			delete (struct ns1__get_USCOREkos_USCOREby_USCOREpathway*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREkos_USCOREby_USCOREpathway*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse:
		if (p->size < 0)
			delete (struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkos:
		if (p->size < 0)
			delete (struct ns1__get_USCOREpathways_USCOREby_USCOREkos*)p->ptr;
		else
			delete[] (struct ns1__get_USCOREpathways_USCOREby_USCOREkos*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE__SOAP_ENC__arrayType:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	}
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{	switch (tt)
	{
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	return soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	const char *s = soap_code_str(soap_codes_bool, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
	soap_send(soap, soap_bool2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void ArrayOfSubtype::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfSubtype))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__Subtype(soap, this->__ptr + i);
		}
}

void ArrayOfSubtype::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOfSubtype::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfSubtype);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfSubtype::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfSubtype(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfSubtype(struct soap *soap, const char *tag, int id, const ArrayOfSubtype *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:Subtype", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfSubtype);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__Subtype(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfSubtype::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfSubtype(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfSubtype * SOAP_FMAC4 soap_get_ArrayOfSubtype(struct soap *soap, ArrayOfSubtype *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfSubtype(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfSubtype::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfSubtype(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfSubtype * SOAP_FMAC4 soap_in_ArrayOfSubtype(struct soap *soap, const char *tag, ArrayOfSubtype *a, const char *type)
{	int i, j;
	ns1__Subtype **p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfSubtype *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfSubtype, sizeof(ArrayOfSubtype), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__Subtype **)soap_malloc(soap, sizeof(ns1__Subtype *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__Subtype(soap, NULL, a->__ptr + i, "ns1:Subtype"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__Subtype **)soap_push_block(soap, sizeof(ns1__Subtype *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__Subtype(soap, NULL, p, "ns1:Subtype"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__Subtype **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfSubtype *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOfSubtype, 0, sizeof(ArrayOfSubtype), 0, soap_copy_ArrayOfSubtype);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfSubtype * SOAP_FMAC6 soap_new_ArrayOfSubtype(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfSubtype(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfSubtype(struct soap *soap, ArrayOfSubtype *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfSubtype * SOAP_FMAC4 soap_instantiate_ArrayOfSubtype(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfSubtype(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfSubtype, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfSubtype;
		if (size)
			*size = sizeof(ArrayOfSubtype);
		((ArrayOfSubtype*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfSubtype[n];
		if (size)
			*size = n * sizeof(ArrayOfSubtype);
		for (int i = 0; i < n; i++)
			((ArrayOfSubtype*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfSubtype*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfSubtype(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfSubtype %p -> %p\n", q, p));
	*(ArrayOfSubtype*)p = *(ArrayOfSubtype*)q;
}

void ns1__Subtype::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__Subtype*)this)->relation, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__Subtype*)this)->relation);
	soap_embedded(soap, &((ns1__Subtype*)this)->element_USCOREid, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__Subtype*)this)->type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__Subtype*)this)->type);
	/* transient soap skipped */
}

void ns1__Subtype::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__Subtype*)this)->relation);
	soap_default_int(soap, &((ns1__Subtype*)this)->element_USCOREid);
	soap_default_std__string(soap, &((ns1__Subtype*)this)->type);
	/* transient soap skipped */
}

int ns1__Subtype::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Subtype);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Subtype::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Subtype(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Subtype(struct soap *soap, const char *tag, int id, const ns1__Subtype *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Subtype), type);
	soap_out_std__string(soap, "relation", -1, &(((ns1__Subtype*)a)->relation), "");
	soap_out_int(soap, "element_id", -1, &(((ns1__Subtype*)a)->element_USCOREid), "");
	soap_out_std__string(soap, "type", -1, &(((ns1__Subtype*)a)->type), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Subtype::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Subtype(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Subtype * SOAP_FMAC4 soap_get_ns1__Subtype(struct soap *soap, ns1__Subtype *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Subtype(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Subtype::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Subtype(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Subtype * SOAP_FMAC4 soap_in_ns1__Subtype(struct soap *soap, const char *tag, ns1__Subtype *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns1__Subtype *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Subtype, sizeof(ns1__Subtype), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Subtype)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Subtype *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_relation1 = 1, soap_flag_element_USCOREid1 = 1, soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_relation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "relation", &(((ns1__Subtype*)a)->relation), "xsd:string"))
				{	soap_flag_relation1--;
					continue;
				}
			if (soap_flag_element_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "element_id", &(((ns1__Subtype*)a)->element_USCOREid), "xsd:int"))
				{	soap_flag_element_USCOREid1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(((ns1__Subtype*)a)->type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_relation1 > 0 || soap_flag_element_USCOREid1 > 0 || soap_flag_type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Subtype *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__Subtype, 0, sizeof(ns1__Subtype), 0, soap_copy_ns1__Subtype);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Subtype * SOAP_FMAC6 soap_new_ns1__Subtype(struct soap *soap, int n)
{	return soap_instantiate_ns1__Subtype(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Subtype(struct soap *soap, ns1__Subtype *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__Subtype * SOAP_FMAC4 soap_instantiate_ns1__Subtype(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Subtype(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Subtype, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Subtype;
		if (size)
			*size = sizeof(ns1__Subtype);
		((ns1__Subtype*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Subtype[n];
		if (size)
			*size = n * sizeof(ns1__Subtype);
		for (int i = 0; i < n; i++)
			((ns1__Subtype*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Subtype*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Subtype(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Subtype %p -> %p\n", q, p));
	*(ns1__Subtype*)p = *(ns1__Subtype*)q;
}

void ArrayOfPathwayElementRelation::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfPathwayElementRelation))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__PathwayElementRelation(soap, this->__ptr + i);
		}
}

void ArrayOfPathwayElementRelation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOfPathwayElementRelation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfPathwayElementRelation);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfPathwayElementRelation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfPathwayElementRelation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfPathwayElementRelation(struct soap *soap, const char *tag, int id, const ArrayOfPathwayElementRelation *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:PathwayElementRelation", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfPathwayElementRelation);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__PathwayElementRelation(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfPathwayElementRelation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfPathwayElementRelation(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfPathwayElementRelation * SOAP_FMAC4 soap_get_ArrayOfPathwayElementRelation(struct soap *soap, ArrayOfPathwayElementRelation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfPathwayElementRelation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfPathwayElementRelation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfPathwayElementRelation(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfPathwayElementRelation * SOAP_FMAC4 soap_in_ArrayOfPathwayElementRelation(struct soap *soap, const char *tag, ArrayOfPathwayElementRelation *a, const char *type)
{	int i, j;
	ns1__PathwayElementRelation **p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfPathwayElementRelation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfPathwayElementRelation, sizeof(ArrayOfPathwayElementRelation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__PathwayElementRelation **)soap_malloc(soap, sizeof(ns1__PathwayElementRelation *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__PathwayElementRelation(soap, NULL, a->__ptr + i, "ns1:PathwayElementRelation"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__PathwayElementRelation **)soap_push_block(soap, sizeof(ns1__PathwayElementRelation *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__PathwayElementRelation(soap, NULL, p, "ns1:PathwayElementRelation"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__PathwayElementRelation **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfPathwayElementRelation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOfPathwayElementRelation, 0, sizeof(ArrayOfPathwayElementRelation), 0, soap_copy_ArrayOfPathwayElementRelation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfPathwayElementRelation * SOAP_FMAC6 soap_new_ArrayOfPathwayElementRelation(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfPathwayElementRelation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfPathwayElementRelation(struct soap *soap, ArrayOfPathwayElementRelation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfPathwayElementRelation * SOAP_FMAC4 soap_instantiate_ArrayOfPathwayElementRelation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfPathwayElementRelation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfPathwayElementRelation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfPathwayElementRelation;
		if (size)
			*size = sizeof(ArrayOfPathwayElementRelation);
		((ArrayOfPathwayElementRelation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfPathwayElementRelation[n];
		if (size)
			*size = n * sizeof(ArrayOfPathwayElementRelation);
		for (int i = 0; i < n; i++)
			((ArrayOfPathwayElementRelation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfPathwayElementRelation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfPathwayElementRelation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfPathwayElementRelation %p -> %p\n", q, p));
	*(ArrayOfPathwayElementRelation*)p = *(ArrayOfPathwayElementRelation*)q;
}

void ns1__PathwayElementRelation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__PathwayElementRelation*)this)->element_USCOREid1, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__PathwayElementRelation*)this)->element_USCOREid2, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__PathwayElementRelation*)this)->type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__PathwayElementRelation*)this)->type);
	soap_embedded(soap, &((ns1__PathwayElementRelation*)this)->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__PathwayElementRelation*)this)->name);
	soap_serialize_PointerToArrayOfSubtype(soap, &((ns1__PathwayElementRelation*)this)->subtypes);
	/* transient soap skipped */
}

void ns1__PathwayElementRelation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((ns1__PathwayElementRelation*)this)->element_USCOREid1);
	soap_default_int(soap, &((ns1__PathwayElementRelation*)this)->element_USCOREid2);
	soap_default_std__string(soap, &((ns1__PathwayElementRelation*)this)->type);
	soap_default_std__string(soap, &((ns1__PathwayElementRelation*)this)->name);
	((ns1__PathwayElementRelation*)this)->subtypes = NULL;
	/* transient soap skipped */
}

int ns1__PathwayElementRelation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PathwayElementRelation);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__PathwayElementRelation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PathwayElementRelation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PathwayElementRelation(struct soap *soap, const char *tag, int id, const ns1__PathwayElementRelation *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PathwayElementRelation), type);
	soap_out_int(soap, "element_id1", -1, &(((ns1__PathwayElementRelation*)a)->element_USCOREid1), "");
	soap_out_int(soap, "element_id2", -1, &(((ns1__PathwayElementRelation*)a)->element_USCOREid2), "");
	soap_out_std__string(soap, "type", -1, &(((ns1__PathwayElementRelation*)a)->type), "");
	soap_out_std__string(soap, "name", -1, &(((ns1__PathwayElementRelation*)a)->name), "");
	soap_out_PointerToArrayOfSubtype(soap, "subtypes", -1, &(((ns1__PathwayElementRelation*)a)->subtypes), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__PathwayElementRelation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PathwayElementRelation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PathwayElementRelation * SOAP_FMAC4 soap_get_ns1__PathwayElementRelation(struct soap *soap, ns1__PathwayElementRelation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PathwayElementRelation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__PathwayElementRelation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PathwayElementRelation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PathwayElementRelation * SOAP_FMAC4 soap_in_ns1__PathwayElementRelation(struct soap *soap, const char *tag, ns1__PathwayElementRelation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns1__PathwayElementRelation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PathwayElementRelation, sizeof(ns1__PathwayElementRelation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PathwayElementRelation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PathwayElementRelation *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_element_USCOREid11 = 1, soap_flag_element_USCOREid21 = 1, soap_flag_type1 = 1, soap_flag_name1 = 1, soap_flag_subtypes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_element_USCOREid11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "element_id1", &(((ns1__PathwayElementRelation*)a)->element_USCOREid1), "xsd:int"))
				{	soap_flag_element_USCOREid11--;
					continue;
				}
			if (soap_flag_element_USCOREid21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "element_id2", &(((ns1__PathwayElementRelation*)a)->element_USCOREid2), "xsd:int"))
				{	soap_flag_element_USCOREid21--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(((ns1__PathwayElementRelation*)a)->type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(((ns1__PathwayElementRelation*)a)->name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_subtypes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfSubtype(soap, "subtypes", &(((ns1__PathwayElementRelation*)a)->subtypes), "ns1:Subtype"))
				{	soap_flag_subtypes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_element_USCOREid11 > 0 || soap_flag_element_USCOREid21 > 0 || soap_flag_type1 > 0 || soap_flag_name1 > 0 || soap_flag_subtypes1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PathwayElementRelation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__PathwayElementRelation, 0, sizeof(ns1__PathwayElementRelation), 0, soap_copy_ns1__PathwayElementRelation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__PathwayElementRelation * SOAP_FMAC6 soap_new_ns1__PathwayElementRelation(struct soap *soap, int n)
{	return soap_instantiate_ns1__PathwayElementRelation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__PathwayElementRelation(struct soap *soap, ns1__PathwayElementRelation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__PathwayElementRelation * SOAP_FMAC4 soap_instantiate_ns1__PathwayElementRelation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PathwayElementRelation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PathwayElementRelation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__PathwayElementRelation;
		if (size)
			*size = sizeof(ns1__PathwayElementRelation);
		((ns1__PathwayElementRelation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__PathwayElementRelation[n];
		if (size)
			*size = n * sizeof(ns1__PathwayElementRelation);
		for (int i = 0; i < n; i++)
			((ns1__PathwayElementRelation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PathwayElementRelation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PathwayElementRelation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PathwayElementRelation %p -> %p\n", q, p));
	*(ns1__PathwayElementRelation*)p = *(ns1__PathwayElementRelation*)q;
}

void ArrayOfPathwayElement::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfPathwayElement))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__PathwayElement(soap, this->__ptr + i);
		}
}

void ArrayOfPathwayElement::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOfPathwayElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfPathwayElement);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfPathwayElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfPathwayElement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfPathwayElement(struct soap *soap, const char *tag, int id, const ArrayOfPathwayElement *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:PathwayElement", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfPathwayElement);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__PathwayElement(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfPathwayElement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfPathwayElement(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfPathwayElement * SOAP_FMAC4 soap_get_ArrayOfPathwayElement(struct soap *soap, ArrayOfPathwayElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfPathwayElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfPathwayElement::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfPathwayElement(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfPathwayElement * SOAP_FMAC4 soap_in_ArrayOfPathwayElement(struct soap *soap, const char *tag, ArrayOfPathwayElement *a, const char *type)
{	int i, j;
	ns1__PathwayElement **p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfPathwayElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfPathwayElement, sizeof(ArrayOfPathwayElement), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__PathwayElement **)soap_malloc(soap, sizeof(ns1__PathwayElement *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__PathwayElement(soap, NULL, a->__ptr + i, "ns1:PathwayElement"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__PathwayElement **)soap_push_block(soap, sizeof(ns1__PathwayElement *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__PathwayElement(soap, NULL, p, "ns1:PathwayElement"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__PathwayElement **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfPathwayElement *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOfPathwayElement, 0, sizeof(ArrayOfPathwayElement), 0, soap_copy_ArrayOfPathwayElement);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfPathwayElement * SOAP_FMAC6 soap_new_ArrayOfPathwayElement(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfPathwayElement(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfPathwayElement(struct soap *soap, ArrayOfPathwayElement *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfPathwayElement * SOAP_FMAC4 soap_instantiate_ArrayOfPathwayElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfPathwayElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfPathwayElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfPathwayElement;
		if (size)
			*size = sizeof(ArrayOfPathwayElement);
		((ArrayOfPathwayElement*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfPathwayElement[n];
		if (size)
			*size = n * sizeof(ArrayOfPathwayElement);
		for (int i = 0; i < n; i++)
			((ArrayOfPathwayElement*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfPathwayElement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfPathwayElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfPathwayElement %p -> %p\n", q, p));
	*(ArrayOfPathwayElement*)p = *(ArrayOfPathwayElement*)q;
}

void ns1__PathwayElement::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__PathwayElement*)this)->element_USCOREid, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__PathwayElement*)this)->type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__PathwayElement*)this)->type);
	soap_serialize_PointerToArrayOfstring(soap, &((ns1__PathwayElement*)this)->names);
	soap_serialize_PointerToArrayOfint(soap, &((ns1__PathwayElement*)this)->components);
	/* transient soap skipped */
}

void ns1__PathwayElement::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((ns1__PathwayElement*)this)->element_USCOREid);
	soap_default_std__string(soap, &((ns1__PathwayElement*)this)->type);
	((ns1__PathwayElement*)this)->names = NULL;
	((ns1__PathwayElement*)this)->components = NULL;
	/* transient soap skipped */
}

int ns1__PathwayElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PathwayElement);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__PathwayElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PathwayElement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PathwayElement(struct soap *soap, const char *tag, int id, const ns1__PathwayElement *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PathwayElement), type);
	soap_out_int(soap, "element_id", -1, &(((ns1__PathwayElement*)a)->element_USCOREid), "");
	soap_out_std__string(soap, "type", -1, &(((ns1__PathwayElement*)a)->type), "");
	soap_out_PointerToArrayOfstring(soap, "names", -1, &(((ns1__PathwayElement*)a)->names), "");
	soap_out_PointerToArrayOfint(soap, "components", -1, &(((ns1__PathwayElement*)a)->components), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__PathwayElement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PathwayElement(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PathwayElement * SOAP_FMAC4 soap_get_ns1__PathwayElement(struct soap *soap, ns1__PathwayElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PathwayElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__PathwayElement::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PathwayElement(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PathwayElement * SOAP_FMAC4 soap_in_ns1__PathwayElement(struct soap *soap, const char *tag, ns1__PathwayElement *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns1__PathwayElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PathwayElement, sizeof(ns1__PathwayElement), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PathwayElement)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PathwayElement *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_element_USCOREid1 = 1, soap_flag_type1 = 1, soap_flag_names1 = 1, soap_flag_components1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_element_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "element_id", &(((ns1__PathwayElement*)a)->element_USCOREid), "xsd:int"))
				{	soap_flag_element_USCOREid1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(((ns1__PathwayElement*)a)->type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_names1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "names", &(((ns1__PathwayElement*)a)->names), "xsd:string"))
				{	soap_flag_names1--;
					continue;
				}
			if (soap_flag_components1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfint(soap, "components", &(((ns1__PathwayElement*)a)->components), "xsd:int"))
				{	soap_flag_components1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_element_USCOREid1 > 0 || soap_flag_type1 > 0 || soap_flag_names1 > 0 || soap_flag_components1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PathwayElement *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__PathwayElement, 0, sizeof(ns1__PathwayElement), 0, soap_copy_ns1__PathwayElement);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__PathwayElement * SOAP_FMAC6 soap_new_ns1__PathwayElement(struct soap *soap, int n)
{	return soap_instantiate_ns1__PathwayElement(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__PathwayElement(struct soap *soap, ns1__PathwayElement *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__PathwayElement * SOAP_FMAC4 soap_instantiate_ns1__PathwayElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PathwayElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PathwayElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__PathwayElement;
		if (size)
			*size = sizeof(ns1__PathwayElement);
		((ns1__PathwayElement*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__PathwayElement[n];
		if (size)
			*size = n * sizeof(ns1__PathwayElement);
		for (int i = 0; i < n; i++)
			((ns1__PathwayElement*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PathwayElement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PathwayElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PathwayElement %p -> %p\n", q, p));
	*(ns1__PathwayElement*)p = *(ns1__PathwayElement*)q;
}

void ArrayOfLinkDBRelation::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfLinkDBRelation))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__LinkDBRelation(soap, this->__ptr + i);
		}
}

void ArrayOfLinkDBRelation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOfLinkDBRelation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfLinkDBRelation);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfLinkDBRelation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfLinkDBRelation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfLinkDBRelation(struct soap *soap, const char *tag, int id, const ArrayOfLinkDBRelation *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:LinkDBRelation", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfLinkDBRelation);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__LinkDBRelation(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfLinkDBRelation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfLinkDBRelation(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfLinkDBRelation * SOAP_FMAC4 soap_get_ArrayOfLinkDBRelation(struct soap *soap, ArrayOfLinkDBRelation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfLinkDBRelation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfLinkDBRelation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfLinkDBRelation(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfLinkDBRelation * SOAP_FMAC4 soap_in_ArrayOfLinkDBRelation(struct soap *soap, const char *tag, ArrayOfLinkDBRelation *a, const char *type)
{	int i, j;
	ns1__LinkDBRelation **p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfLinkDBRelation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfLinkDBRelation, sizeof(ArrayOfLinkDBRelation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__LinkDBRelation **)soap_malloc(soap, sizeof(ns1__LinkDBRelation *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__LinkDBRelation(soap, NULL, a->__ptr + i, "ns1:LinkDBRelation"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__LinkDBRelation **)soap_push_block(soap, sizeof(ns1__LinkDBRelation *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__LinkDBRelation(soap, NULL, p, "ns1:LinkDBRelation"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__LinkDBRelation **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfLinkDBRelation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOfLinkDBRelation, 0, sizeof(ArrayOfLinkDBRelation), 0, soap_copy_ArrayOfLinkDBRelation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfLinkDBRelation * SOAP_FMAC6 soap_new_ArrayOfLinkDBRelation(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfLinkDBRelation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfLinkDBRelation(struct soap *soap, ArrayOfLinkDBRelation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfLinkDBRelation * SOAP_FMAC4 soap_instantiate_ArrayOfLinkDBRelation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfLinkDBRelation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfLinkDBRelation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfLinkDBRelation;
		if (size)
			*size = sizeof(ArrayOfLinkDBRelation);
		((ArrayOfLinkDBRelation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfLinkDBRelation[n];
		if (size)
			*size = n * sizeof(ArrayOfLinkDBRelation);
		for (int i = 0; i < n; i++)
			((ArrayOfLinkDBRelation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfLinkDBRelation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfLinkDBRelation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfLinkDBRelation %p -> %p\n", q, p));
	*(ArrayOfLinkDBRelation*)p = *(ArrayOfLinkDBRelation*)q;
}

void ns1__LinkDBRelation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__LinkDBRelation*)this)->entry_USCOREid1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__LinkDBRelation*)this)->entry_USCOREid1);
	soap_embedded(soap, &((ns1__LinkDBRelation*)this)->entry_USCOREid2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__LinkDBRelation*)this)->entry_USCOREid2);
	soap_embedded(soap, &((ns1__LinkDBRelation*)this)->type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__LinkDBRelation*)this)->type);
	soap_embedded(soap, &((ns1__LinkDBRelation*)this)->path, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__LinkDBRelation*)this)->path);
	/* transient soap skipped */
}

void ns1__LinkDBRelation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__LinkDBRelation*)this)->entry_USCOREid1);
	soap_default_std__string(soap, &((ns1__LinkDBRelation*)this)->entry_USCOREid2);
	soap_default_std__string(soap, &((ns1__LinkDBRelation*)this)->type);
	soap_default_std__string(soap, &((ns1__LinkDBRelation*)this)->path);
	/* transient soap skipped */
}

int ns1__LinkDBRelation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__LinkDBRelation);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__LinkDBRelation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LinkDBRelation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LinkDBRelation(struct soap *soap, const char *tag, int id, const ns1__LinkDBRelation *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LinkDBRelation), type);
	soap_out_std__string(soap, "entry_id1", -1, &(((ns1__LinkDBRelation*)a)->entry_USCOREid1), "");
	soap_out_std__string(soap, "entry_id2", -1, &(((ns1__LinkDBRelation*)a)->entry_USCOREid2), "");
	soap_out_std__string(soap, "type", -1, &(((ns1__LinkDBRelation*)a)->type), "");
	soap_out_std__string(soap, "path", -1, &(((ns1__LinkDBRelation*)a)->path), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__LinkDBRelation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LinkDBRelation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LinkDBRelation * SOAP_FMAC4 soap_get_ns1__LinkDBRelation(struct soap *soap, ns1__LinkDBRelation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LinkDBRelation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__LinkDBRelation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LinkDBRelation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LinkDBRelation * SOAP_FMAC4 soap_in_ns1__LinkDBRelation(struct soap *soap, const char *tag, ns1__LinkDBRelation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns1__LinkDBRelation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LinkDBRelation, sizeof(ns1__LinkDBRelation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__LinkDBRelation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__LinkDBRelation *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_entry_USCOREid11 = 1, soap_flag_entry_USCOREid21 = 1, soap_flag_type1 = 1, soap_flag_path1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entry_USCOREid11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "entry_id1", &(((ns1__LinkDBRelation*)a)->entry_USCOREid1), "xsd:string"))
				{	soap_flag_entry_USCOREid11--;
					continue;
				}
			if (soap_flag_entry_USCOREid21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "entry_id2", &(((ns1__LinkDBRelation*)a)->entry_USCOREid2), "xsd:string"))
				{	soap_flag_entry_USCOREid21--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(((ns1__LinkDBRelation*)a)->type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_path1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "path", &(((ns1__LinkDBRelation*)a)->path), "xsd:string"))
				{	soap_flag_path1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entry_USCOREid11 > 0 || soap_flag_entry_USCOREid21 > 0 || soap_flag_type1 > 0 || soap_flag_path1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__LinkDBRelation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__LinkDBRelation, 0, sizeof(ns1__LinkDBRelation), 0, soap_copy_ns1__LinkDBRelation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__LinkDBRelation * SOAP_FMAC6 soap_new_ns1__LinkDBRelation(struct soap *soap, int n)
{	return soap_instantiate_ns1__LinkDBRelation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__LinkDBRelation(struct soap *soap, ns1__LinkDBRelation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__LinkDBRelation * SOAP_FMAC4 soap_instantiate_ns1__LinkDBRelation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LinkDBRelation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__LinkDBRelation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__LinkDBRelation;
		if (size)
			*size = sizeof(ns1__LinkDBRelation);
		((ns1__LinkDBRelation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__LinkDBRelation[n];
		if (size)
			*size = n * sizeof(ns1__LinkDBRelation);
		for (int i = 0; i < n; i++)
			((ns1__LinkDBRelation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__LinkDBRelation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__LinkDBRelation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__LinkDBRelation %p -> %p\n", q, p));
	*(ns1__LinkDBRelation*)p = *(ns1__LinkDBRelation*)q;
}

void ArrayOfDefinition::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfDefinition))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__Definition(soap, this->__ptr + i);
		}
}

void ArrayOfDefinition::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOfDefinition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfDefinition);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfDefinition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfDefinition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfDefinition(struct soap *soap, const char *tag, int id, const ArrayOfDefinition *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:Definition", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfDefinition);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__Definition(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfDefinition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfDefinition(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfDefinition * SOAP_FMAC4 soap_get_ArrayOfDefinition(struct soap *soap, ArrayOfDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfDefinition(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfDefinition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfDefinition(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfDefinition * SOAP_FMAC4 soap_in_ArrayOfDefinition(struct soap *soap, const char *tag, ArrayOfDefinition *a, const char *type)
{	int i, j;
	ns1__Definition **p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfDefinition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfDefinition, sizeof(ArrayOfDefinition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__Definition **)soap_malloc(soap, sizeof(ns1__Definition *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__Definition(soap, NULL, a->__ptr + i, "ns1:Definition"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__Definition **)soap_push_block(soap, sizeof(ns1__Definition *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__Definition(soap, NULL, p, "ns1:Definition"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__Definition **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfDefinition *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOfDefinition, 0, sizeof(ArrayOfDefinition), 0, soap_copy_ArrayOfDefinition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfDefinition * SOAP_FMAC6 soap_new_ArrayOfDefinition(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfDefinition(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfDefinition(struct soap *soap, ArrayOfDefinition *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfDefinition * SOAP_FMAC4 soap_instantiate_ArrayOfDefinition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfDefinition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfDefinition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfDefinition;
		if (size)
			*size = sizeof(ArrayOfDefinition);
		((ArrayOfDefinition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfDefinition[n];
		if (size)
			*size = n * sizeof(ArrayOfDefinition);
		for (int i = 0; i < n; i++)
			((ArrayOfDefinition*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfDefinition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfDefinition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfDefinition %p -> %p\n", q, p));
	*(ArrayOfDefinition*)p = *(ArrayOfDefinition*)q;
}

void ns1__Definition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__Definition*)this)->entry_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__Definition*)this)->entry_USCOREid);
	soap_embedded(soap, &((ns1__Definition*)this)->definition, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__Definition*)this)->definition);
	/* transient soap skipped */
}

void ns1__Definition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__Definition*)this)->entry_USCOREid);
	soap_default_std__string(soap, &((ns1__Definition*)this)->definition);
	/* transient soap skipped */
}

int ns1__Definition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Definition);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Definition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Definition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Definition(struct soap *soap, const char *tag, int id, const ns1__Definition *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Definition), type);
	soap_out_std__string(soap, "entry_id", -1, &(((ns1__Definition*)a)->entry_USCOREid), "");
	soap_out_std__string(soap, "definition", -1, &(((ns1__Definition*)a)->definition), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__Definition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Definition(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Definition * SOAP_FMAC4 soap_get_ns1__Definition(struct soap *soap, ns1__Definition *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Definition(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__Definition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Definition(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Definition * SOAP_FMAC4 soap_in_ns1__Definition(struct soap *soap, const char *tag, ns1__Definition *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns1__Definition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Definition, sizeof(ns1__Definition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Definition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Definition *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_entry_USCOREid1 = 1, soap_flag_definition1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entry_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "entry_id", &(((ns1__Definition*)a)->entry_USCOREid), "xsd:string"))
				{	soap_flag_entry_USCOREid1--;
					continue;
				}
			if (soap_flag_definition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "definition", &(((ns1__Definition*)a)->definition), "xsd:string"))
				{	soap_flag_definition1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entry_USCOREid1 > 0 || soap_flag_definition1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Definition *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__Definition, 0, sizeof(ns1__Definition), 0, soap_copy_ns1__Definition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Definition * SOAP_FMAC6 soap_new_ns1__Definition(struct soap *soap, int n)
{	return soap_instantiate_ns1__Definition(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Definition(struct soap *soap, ns1__Definition *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__Definition * SOAP_FMAC4 soap_instantiate_ns1__Definition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Definition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Definition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Definition;
		if (size)
			*size = sizeof(ns1__Definition);
		((ns1__Definition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Definition[n];
		if (size)
			*size = n * sizeof(ns1__Definition);
		for (int i = 0; i < n; i++)
			((ns1__Definition*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Definition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Definition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Definition %p -> %p\n", q, p));
	*(ns1__Definition*)p = *(ns1__Definition*)q;
}

void ArrayOfMotifResult::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfMotifResult))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__MotifResult(soap, this->__ptr + i);
		}
}

void ArrayOfMotifResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOfMotifResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfMotifResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfMotifResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfMotifResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfMotifResult(struct soap *soap, const char *tag, int id, const ArrayOfMotifResult *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:MotifResult", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfMotifResult);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__MotifResult(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfMotifResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfMotifResult(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfMotifResult * SOAP_FMAC4 soap_get_ArrayOfMotifResult(struct soap *soap, ArrayOfMotifResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfMotifResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfMotifResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfMotifResult(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfMotifResult * SOAP_FMAC4 soap_in_ArrayOfMotifResult(struct soap *soap, const char *tag, ArrayOfMotifResult *a, const char *type)
{	int i, j;
	ns1__MotifResult **p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfMotifResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfMotifResult, sizeof(ArrayOfMotifResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__MotifResult **)soap_malloc(soap, sizeof(ns1__MotifResult *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__MotifResult(soap, NULL, a->__ptr + i, "ns1:MotifResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__MotifResult **)soap_push_block(soap, sizeof(ns1__MotifResult *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__MotifResult(soap, NULL, p, "ns1:MotifResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__MotifResult **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfMotifResult *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOfMotifResult, 0, sizeof(ArrayOfMotifResult), 0, soap_copy_ArrayOfMotifResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfMotifResult * SOAP_FMAC6 soap_new_ArrayOfMotifResult(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfMotifResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfMotifResult(struct soap *soap, ArrayOfMotifResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfMotifResult * SOAP_FMAC4 soap_instantiate_ArrayOfMotifResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfMotifResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfMotifResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfMotifResult;
		if (size)
			*size = sizeof(ArrayOfMotifResult);
		((ArrayOfMotifResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfMotifResult[n];
		if (size)
			*size = n * sizeof(ArrayOfMotifResult);
		for (int i = 0; i < n; i++)
			((ArrayOfMotifResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfMotifResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfMotifResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfMotifResult %p -> %p\n", q, p));
	*(ArrayOfMotifResult*)p = *(ArrayOfMotifResult*)q;
}

void ns1__MotifResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__MotifResult*)this)->motif_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__MotifResult*)this)->motif_USCOREid);
	soap_embedded(soap, &((ns1__MotifResult*)this)->definition, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__MotifResult*)this)->definition);
	soap_embedded(soap, &((ns1__MotifResult*)this)->genes_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__MotifResult*)this)->genes_USCOREid);
	soap_embedded(soap, &((ns1__MotifResult*)this)->start_USCOREposition, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__MotifResult*)this)->end_USCOREposition, SOAP_TYPE_int);
	/* transient soap skipped */
}

void ns1__MotifResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__MotifResult*)this)->motif_USCOREid);
	soap_default_std__string(soap, &((ns1__MotifResult*)this)->definition);
	soap_default_std__string(soap, &((ns1__MotifResult*)this)->genes_USCOREid);
	soap_default_int(soap, &((ns1__MotifResult*)this)->start_USCOREposition);
	soap_default_int(soap, &((ns1__MotifResult*)this)->end_USCOREposition);
	soap_default_float(soap, &((ns1__MotifResult*)this)->score);
	soap_default_double(soap, &((ns1__MotifResult*)this)->evalue);
	/* transient soap skipped */
}

int ns1__MotifResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MotifResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MotifResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MotifResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MotifResult(struct soap *soap, const char *tag, int id, const ns1__MotifResult *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MotifResult), type);
	soap_out_std__string(soap, "motif_id", -1, &(((ns1__MotifResult*)a)->motif_USCOREid), "");
	soap_out_std__string(soap, "definition", -1, &(((ns1__MotifResult*)a)->definition), "");
	soap_out_std__string(soap, "genes_id", -1, &(((ns1__MotifResult*)a)->genes_USCOREid), "");
	soap_out_int(soap, "start_position", -1, &(((ns1__MotifResult*)a)->start_USCOREposition), "");
	soap_out_int(soap, "end_position", -1, &(((ns1__MotifResult*)a)->end_USCOREposition), "");
	soap_out_float(soap, "score", -1, &(((ns1__MotifResult*)a)->score), "");
	soap_out_double(soap, "evalue", -1, &(((ns1__MotifResult*)a)->evalue), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MotifResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MotifResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MotifResult * SOAP_FMAC4 soap_get_ns1__MotifResult(struct soap *soap, ns1__MotifResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MotifResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MotifResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MotifResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MotifResult * SOAP_FMAC4 soap_in_ns1__MotifResult(struct soap *soap, const char *tag, ns1__MotifResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns1__MotifResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MotifResult, sizeof(ns1__MotifResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MotifResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MotifResult *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_motif_USCOREid1 = 1, soap_flag_definition1 = 1, soap_flag_genes_USCOREid1 = 1, soap_flag_start_USCOREposition1 = 1, soap_flag_end_USCOREposition1 = 1, soap_flag_score1 = 1, soap_flag_evalue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_motif_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "motif_id", &(((ns1__MotifResult*)a)->motif_USCOREid), "xsd:string"))
				{	soap_flag_motif_USCOREid1--;
					continue;
				}
			if (soap_flag_definition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "definition", &(((ns1__MotifResult*)a)->definition), "xsd:string"))
				{	soap_flag_definition1--;
					continue;
				}
			if (soap_flag_genes_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genes_id", &(((ns1__MotifResult*)a)->genes_USCOREid), "xsd:string"))
				{	soap_flag_genes_USCOREid1--;
					continue;
				}
			if (soap_flag_start_USCOREposition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start_position", &(((ns1__MotifResult*)a)->start_USCOREposition), "xsd:int"))
				{	soap_flag_start_USCOREposition1--;
					continue;
				}
			if (soap_flag_end_USCOREposition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "end_position", &(((ns1__MotifResult*)a)->end_USCOREposition), "xsd:int"))
				{	soap_flag_end_USCOREposition1--;
					continue;
				}
			if (soap_flag_score1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "score", &(((ns1__MotifResult*)a)->score), "xsd:float"))
				{	soap_flag_score1--;
					continue;
				}
			if (soap_flag_evalue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "evalue", &(((ns1__MotifResult*)a)->evalue), "xsd:double"))
				{	soap_flag_evalue1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_motif_USCOREid1 > 0 || soap_flag_definition1 > 0 || soap_flag_genes_USCOREid1 > 0 || soap_flag_start_USCOREposition1 > 0 || soap_flag_end_USCOREposition1 > 0 || soap_flag_score1 > 0 || soap_flag_evalue1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MotifResult *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__MotifResult, 0, sizeof(ns1__MotifResult), 0, soap_copy_ns1__MotifResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MotifResult * SOAP_FMAC6 soap_new_ns1__MotifResult(struct soap *soap, int n)
{	return soap_instantiate_ns1__MotifResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MotifResult(struct soap *soap, ns1__MotifResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MotifResult * SOAP_FMAC4 soap_instantiate_ns1__MotifResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MotifResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MotifResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MotifResult;
		if (size)
			*size = sizeof(ns1__MotifResult);
		((ns1__MotifResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MotifResult[n];
		if (size)
			*size = n * sizeof(ns1__MotifResult);
		for (int i = 0; i < n; i++)
			((ns1__MotifResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MotifResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MotifResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MotifResult %p -> %p\n", q, p));
	*(ns1__MotifResult*)p = *(ns1__MotifResult*)q;
}

void ArrayOfSSDBRelation::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfSSDBRelation))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__SSDBRelation(soap, this->__ptr + i);
		}
}

void ArrayOfSSDBRelation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOfSSDBRelation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfSSDBRelation);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfSSDBRelation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfSSDBRelation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfSSDBRelation(struct soap *soap, const char *tag, int id, const ArrayOfSSDBRelation *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:SSDBRelation", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfSSDBRelation);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__SSDBRelation(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfSSDBRelation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfSSDBRelation(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfSSDBRelation * SOAP_FMAC4 soap_get_ArrayOfSSDBRelation(struct soap *soap, ArrayOfSSDBRelation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfSSDBRelation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfSSDBRelation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfSSDBRelation(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfSSDBRelation * SOAP_FMAC4 soap_in_ArrayOfSSDBRelation(struct soap *soap, const char *tag, ArrayOfSSDBRelation *a, const char *type)
{	int i, j;
	ns1__SSDBRelation **p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfSSDBRelation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfSSDBRelation, sizeof(ArrayOfSSDBRelation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__SSDBRelation **)soap_malloc(soap, sizeof(ns1__SSDBRelation *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__SSDBRelation(soap, NULL, a->__ptr + i, "ns1:SSDBRelation"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__SSDBRelation **)soap_push_block(soap, sizeof(ns1__SSDBRelation *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__SSDBRelation(soap, NULL, p, "ns1:SSDBRelation"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__SSDBRelation **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfSSDBRelation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOfSSDBRelation, 0, sizeof(ArrayOfSSDBRelation), 0, soap_copy_ArrayOfSSDBRelation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfSSDBRelation * SOAP_FMAC6 soap_new_ArrayOfSSDBRelation(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfSSDBRelation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfSSDBRelation(struct soap *soap, ArrayOfSSDBRelation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfSSDBRelation * SOAP_FMAC4 soap_instantiate_ArrayOfSSDBRelation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfSSDBRelation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfSSDBRelation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfSSDBRelation;
		if (size)
			*size = sizeof(ArrayOfSSDBRelation);
		((ArrayOfSSDBRelation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfSSDBRelation[n];
		if (size)
			*size = n * sizeof(ArrayOfSSDBRelation);
		for (int i = 0; i < n; i++)
			((ArrayOfSSDBRelation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfSSDBRelation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfSSDBRelation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfSSDBRelation %p -> %p\n", q, p));
	*(ArrayOfSSDBRelation*)p = *(ArrayOfSSDBRelation*)q;
}

void ns1__SSDBRelation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__SSDBRelation*)this)->genes_USCOREid1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__SSDBRelation*)this)->genes_USCOREid1);
	soap_embedded(soap, &((ns1__SSDBRelation*)this)->genes_USCOREid2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__SSDBRelation*)this)->genes_USCOREid2);
	soap_embedded(soap, &((ns1__SSDBRelation*)this)->sw_USCOREscore, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__SSDBRelation*)this)->overlap, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__SSDBRelation*)this)->start_USCOREposition1, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__SSDBRelation*)this)->end_USCOREposition1, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__SSDBRelation*)this)->start_USCOREposition2, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__SSDBRelation*)this)->end_USCOREposition2, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__SSDBRelation*)this)->definition1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__SSDBRelation*)this)->definition1);
	soap_embedded(soap, &((ns1__SSDBRelation*)this)->definition2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__SSDBRelation*)this)->definition2);
	soap_embedded(soap, &((ns1__SSDBRelation*)this)->length1, SOAP_TYPE_int);
	soap_embedded(soap, &((ns1__SSDBRelation*)this)->length2, SOAP_TYPE_int);
	/* transient soap skipped */
}

void ns1__SSDBRelation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__SSDBRelation*)this)->genes_USCOREid1);
	soap_default_std__string(soap, &((ns1__SSDBRelation*)this)->genes_USCOREid2);
	soap_default_int(soap, &((ns1__SSDBRelation*)this)->sw_USCOREscore);
	soap_default_float(soap, &((ns1__SSDBRelation*)this)->bit_USCOREscore);
	soap_default_float(soap, &((ns1__SSDBRelation*)this)->identity);
	soap_default_int(soap, &((ns1__SSDBRelation*)this)->overlap);
	soap_default_int(soap, &((ns1__SSDBRelation*)this)->start_USCOREposition1);
	soap_default_int(soap, &((ns1__SSDBRelation*)this)->end_USCOREposition1);
	soap_default_int(soap, &((ns1__SSDBRelation*)this)->start_USCOREposition2);
	soap_default_int(soap, &((ns1__SSDBRelation*)this)->end_USCOREposition2);
	soap_default_bool(soap, &((ns1__SSDBRelation*)this)->best_USCOREflag_USCORE1to2);
	soap_default_bool(soap, &((ns1__SSDBRelation*)this)->best_USCOREflag_USCORE2to1);
	soap_default_std__string(soap, &((ns1__SSDBRelation*)this)->definition1);
	soap_default_std__string(soap, &((ns1__SSDBRelation*)this)->definition2);
	soap_default_int(soap, &((ns1__SSDBRelation*)this)->length1);
	soap_default_int(soap, &((ns1__SSDBRelation*)this)->length2);
	/* transient soap skipped */
}

int ns1__SSDBRelation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SSDBRelation);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SSDBRelation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SSDBRelation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SSDBRelation(struct soap *soap, const char *tag, int id, const ns1__SSDBRelation *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SSDBRelation), type);
	soap_out_std__string(soap, "genes_id1", -1, &(((ns1__SSDBRelation*)a)->genes_USCOREid1), "");
	soap_out_std__string(soap, "genes_id2", -1, &(((ns1__SSDBRelation*)a)->genes_USCOREid2), "");
	soap_out_int(soap, "sw_score", -1, &(((ns1__SSDBRelation*)a)->sw_USCOREscore), "");
	soap_out_float(soap, "bit_score", -1, &(((ns1__SSDBRelation*)a)->bit_USCOREscore), "");
	soap_out_float(soap, "identity", -1, &(((ns1__SSDBRelation*)a)->identity), "");
	soap_out_int(soap, "overlap", -1, &(((ns1__SSDBRelation*)a)->overlap), "");
	soap_out_int(soap, "start_position1", -1, &(((ns1__SSDBRelation*)a)->start_USCOREposition1), "");
	soap_out_int(soap, "end_position1", -1, &(((ns1__SSDBRelation*)a)->end_USCOREposition1), "");
	soap_out_int(soap, "start_position2", -1, &(((ns1__SSDBRelation*)a)->start_USCOREposition2), "");
	soap_out_int(soap, "end_position2", -1, &(((ns1__SSDBRelation*)a)->end_USCOREposition2), "");
	soap_out_bool(soap, "best_flag_1to2", -1, &(((ns1__SSDBRelation*)a)->best_USCOREflag_USCORE1to2), "");
	soap_out_bool(soap, "best_flag_2to1", -1, &(((ns1__SSDBRelation*)a)->best_USCOREflag_USCORE2to1), "");
	soap_out_std__string(soap, "definition1", -1, &(((ns1__SSDBRelation*)a)->definition1), "");
	soap_out_std__string(soap, "definition2", -1, &(((ns1__SSDBRelation*)a)->definition2), "");
	soap_out_int(soap, "length1", -1, &(((ns1__SSDBRelation*)a)->length1), "");
	soap_out_int(soap, "length2", -1, &(((ns1__SSDBRelation*)a)->length2), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SSDBRelation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SSDBRelation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SSDBRelation * SOAP_FMAC4 soap_get_ns1__SSDBRelation(struct soap *soap, ns1__SSDBRelation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SSDBRelation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SSDBRelation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SSDBRelation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SSDBRelation * SOAP_FMAC4 soap_in_ns1__SSDBRelation(struct soap *soap, const char *tag, ns1__SSDBRelation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns1__SSDBRelation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SSDBRelation, sizeof(ns1__SSDBRelation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SSDBRelation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SSDBRelation *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_genes_USCOREid11 = 1, soap_flag_genes_USCOREid21 = 1, soap_flag_sw_USCOREscore1 = 1, soap_flag_bit_USCOREscore1 = 1, soap_flag_identity1 = 1, soap_flag_overlap1 = 1, soap_flag_start_USCOREposition11 = 1, soap_flag_end_USCOREposition11 = 1, soap_flag_start_USCOREposition21 = 1, soap_flag_end_USCOREposition21 = 1, soap_flag_best_USCOREflag_USCORE1to21 = 1, soap_flag_best_USCOREflag_USCORE2to11 = 1, soap_flag_definition11 = 1, soap_flag_definition21 = 1, soap_flag_length11 = 1, soap_flag_length21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genes_USCOREid11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genes_id1", &(((ns1__SSDBRelation*)a)->genes_USCOREid1), "xsd:string"))
				{	soap_flag_genes_USCOREid11--;
					continue;
				}
			if (soap_flag_genes_USCOREid21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genes_id2", &(((ns1__SSDBRelation*)a)->genes_USCOREid2), "xsd:string"))
				{	soap_flag_genes_USCOREid21--;
					continue;
				}
			if (soap_flag_sw_USCOREscore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sw_score", &(((ns1__SSDBRelation*)a)->sw_USCOREscore), "xsd:int"))
				{	soap_flag_sw_USCOREscore1--;
					continue;
				}
			if (soap_flag_bit_USCOREscore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "bit_score", &(((ns1__SSDBRelation*)a)->bit_USCOREscore), "xsd:float"))
				{	soap_flag_bit_USCOREscore1--;
					continue;
				}
			if (soap_flag_identity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "identity", &(((ns1__SSDBRelation*)a)->identity), "xsd:float"))
				{	soap_flag_identity1--;
					continue;
				}
			if (soap_flag_overlap1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "overlap", &(((ns1__SSDBRelation*)a)->overlap), "xsd:int"))
				{	soap_flag_overlap1--;
					continue;
				}
			if (soap_flag_start_USCOREposition11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start_position1", &(((ns1__SSDBRelation*)a)->start_USCOREposition1), "xsd:int"))
				{	soap_flag_start_USCOREposition11--;
					continue;
				}
			if (soap_flag_end_USCOREposition11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "end_position1", &(((ns1__SSDBRelation*)a)->end_USCOREposition1), "xsd:int"))
				{	soap_flag_end_USCOREposition11--;
					continue;
				}
			if (soap_flag_start_USCOREposition21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start_position2", &(((ns1__SSDBRelation*)a)->start_USCOREposition2), "xsd:int"))
				{	soap_flag_start_USCOREposition21--;
					continue;
				}
			if (soap_flag_end_USCOREposition21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "end_position2", &(((ns1__SSDBRelation*)a)->end_USCOREposition2), "xsd:int"))
				{	soap_flag_end_USCOREposition21--;
					continue;
				}
			if (soap_flag_best_USCOREflag_USCORE1to21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "best_flag_1to2", &(((ns1__SSDBRelation*)a)->best_USCOREflag_USCORE1to2), "xsd:boolean"))
				{	soap_flag_best_USCOREflag_USCORE1to21--;
					continue;
				}
			if (soap_flag_best_USCOREflag_USCORE2to11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "best_flag_2to1", &(((ns1__SSDBRelation*)a)->best_USCOREflag_USCORE2to1), "xsd:boolean"))
				{	soap_flag_best_USCOREflag_USCORE2to11--;
					continue;
				}
			if (soap_flag_definition11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "definition1", &(((ns1__SSDBRelation*)a)->definition1), "xsd:string"))
				{	soap_flag_definition11--;
					continue;
				}
			if (soap_flag_definition21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "definition2", &(((ns1__SSDBRelation*)a)->definition2), "xsd:string"))
				{	soap_flag_definition21--;
					continue;
				}
			if (soap_flag_length11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "length1", &(((ns1__SSDBRelation*)a)->length1), "xsd:int"))
				{	soap_flag_length11--;
					continue;
				}
			if (soap_flag_length21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "length2", &(((ns1__SSDBRelation*)a)->length2), "xsd:int"))
				{	soap_flag_length21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genes_USCOREid11 > 0 || soap_flag_genes_USCOREid21 > 0 || soap_flag_sw_USCOREscore1 > 0 || soap_flag_bit_USCOREscore1 > 0 || soap_flag_identity1 > 0 || soap_flag_overlap1 > 0 || soap_flag_start_USCOREposition11 > 0 || soap_flag_end_USCOREposition11 > 0 || soap_flag_start_USCOREposition21 > 0 || soap_flag_end_USCOREposition21 > 0 || soap_flag_best_USCOREflag_USCORE1to21 > 0 || soap_flag_best_USCOREflag_USCORE2to11 > 0 || soap_flag_definition11 > 0 || soap_flag_definition21 > 0 || soap_flag_length11 > 0 || soap_flag_length21 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SSDBRelation *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__SSDBRelation, 0, sizeof(ns1__SSDBRelation), 0, soap_copy_ns1__SSDBRelation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SSDBRelation * SOAP_FMAC6 soap_new_ns1__SSDBRelation(struct soap *soap, int n)
{	return soap_instantiate_ns1__SSDBRelation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SSDBRelation(struct soap *soap, ns1__SSDBRelation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SSDBRelation * SOAP_FMAC4 soap_instantiate_ns1__SSDBRelation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SSDBRelation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SSDBRelation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SSDBRelation;
		if (size)
			*size = sizeof(ns1__SSDBRelation);
		((ns1__SSDBRelation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SSDBRelation[n];
		if (size)
			*size = n * sizeof(ns1__SSDBRelation);
		for (int i = 0; i < n; i++)
			((ns1__SSDBRelation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SSDBRelation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SSDBRelation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SSDBRelation %p -> %p\n", q, p));
	*(ns1__SSDBRelation*)p = *(ns1__SSDBRelation*)q;
}

void ArrayOfstring::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfstring))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTostd__string(soap, this->__ptr + i);
		}
}

void ArrayOfstring::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOfstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfstring);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfstring(struct soap *soap, const char *tag, int id, const ArrayOfstring *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfstring);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTostd__string(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfstring(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfstring * SOAP_FMAC4 soap_get_ArrayOfstring(struct soap *soap, ArrayOfstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfstring::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfstring(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfstring * SOAP_FMAC4 soap_in_ArrayOfstring(struct soap *soap, const char *tag, ArrayOfstring *a, const char *type)
{	int i, j;
	std::string **p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfstring, sizeof(ArrayOfstring), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (std::string **)soap_malloc(soap, sizeof(std::string *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTostd__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (std::string **)soap_push_block(soap, sizeof(std::string *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTostd__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (std::string **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfstring *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOfstring, 0, sizeof(ArrayOfstring), 0, soap_copy_ArrayOfstring);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfstring * SOAP_FMAC6 soap_new_ArrayOfstring(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfstring(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfstring(struct soap *soap, ArrayOfstring *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfstring * SOAP_FMAC4 soap_instantiate_ArrayOfstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfstring;
		if (size)
			*size = sizeof(ArrayOfstring);
		((ArrayOfstring*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfstring[n];
		if (size)
			*size = n * sizeof(ArrayOfstring);
		for (int i = 0; i < n; i++)
			((ArrayOfstring*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfstring %p -> %p\n", q, p));
	*(ArrayOfstring*)p = *(ArrayOfstring*)q;
}

void ArrayOfint::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfint))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_int);
		}
}

void ArrayOfint::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOfint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfint);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfint(struct soap *soap, const char *tag, int id, const ArrayOfint *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:int", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfint);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_int(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfint(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfint * SOAP_FMAC4 soap_get_ArrayOfint(struct soap *soap, ArrayOfint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfint(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfint * SOAP_FMAC4 soap_in_ArrayOfint(struct soap *soap, const char *tag, ArrayOfint *a, const char *type)
{	int i, j;
	int *p;
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfint, sizeof(ArrayOfint), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (int *)soap_malloc(soap, sizeof(int) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_int(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_int(soap, NULL, a->__ptr + i, "xsd:int"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (int *)soap_push_block(soap, sizeof(int));
				if (!p)
					return NULL;
				soap_default_int(soap, p);
				if (!soap_in_int(soap, NULL, p, "xsd:int"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (int *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfint *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOfint, 0, sizeof(ArrayOfint), 0, soap_copy_ArrayOfint);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfint * SOAP_FMAC6 soap_new_ArrayOfint(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfint(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfint(struct soap *soap, ArrayOfint *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfint * SOAP_FMAC4 soap_instantiate_ArrayOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfint;
		if (size)
			*size = sizeof(ArrayOfint);
		((ArrayOfint*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfint[n];
		if (size)
			*size = n * sizeof(ArrayOfint);
		for (int i = 0; i < n; i++)
			((ArrayOfint*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfint*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfint %p -> %p\n", q, p));
	*(ArrayOfint*)p = *(ArrayOfint*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__SOAP_ENC__arrayType(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__SOAP_ENC__arrayType(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__SOAP_ENC__arrayType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__SOAP_ENC__arrayType);
	if (soap_out__SOAP_ENC__arrayType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out__SOAP_ENC__arrayType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE__SOAP_ENC__arrayType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get__SOAP_ENC__arrayType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in__SOAP_ENC__arrayType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in__SOAP_ENC__arrayType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE__SOAP_ENC__arrayType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE__SOAP_ENC__arrayType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE__SOAP_ENC__arrayType, 0, sizeof(std::string), 0, soap_copy__SOAP_ENC__arrayType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new__SOAP_ENC__arrayType(struct soap *soap, int n)
{	return soap_instantiate__SOAP_ENC__arrayType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__SOAP_ENC__arrayType(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate__SOAP_ENC__arrayType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__SOAP_ENC__arrayType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__SOAP_ENC__arrayType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__SOAP_ENC__arrayType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREkos(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREkos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->ko_USCOREid_USCORElist);
	soap_embedded(soap, &a->org, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->org);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREpathways_USCOREby_USCOREkos(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREkos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ko_USCOREid_USCORElist = NULL;
	soap_default_std__string(soap, &a->org);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREpathways_USCOREby_USCOREkos(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREkos *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkos);
	if (soap_out_ns1__get_USCOREpathways_USCOREby_USCOREkos(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREpathways_USCOREby_USCOREkos(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREpathways_USCOREby_USCOREkos *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkos), type);
	soap_out_PointerToArrayOfstring(soap, "ko_id_list", -1, &a->ko_USCOREid_USCORElist, "");
	soap_out_std__string(soap, "org", -1, &a->org, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREkos * SOAP_FMAC4 soap_get_ns1__get_USCOREpathways_USCOREby_USCOREkos(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREkos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREpathways_USCOREby_USCOREkos(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREkos * SOAP_FMAC4 soap_in_ns1__get_USCOREpathways_USCOREby_USCOREkos(struct soap *soap, const char *tag, struct ns1__get_USCOREpathways_USCOREby_USCOREkos *a, const char *type)
{
	short soap_flag_ko_USCOREid_USCORElist = 1, soap_flag_org = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREkos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkos, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREkos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREpathways_USCOREby_USCOREkos(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ko_USCOREid_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "ko_id_list", &a->ko_USCOREid_USCORElist, "xsd:string"))
				{	soap_flag_ko_USCOREid_USCORElist--;
					continue;
				}
			if (soap_flag_org && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "org", &a->org, "xsd:string"))
				{	soap_flag_org--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_org > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREkos *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkos, 0, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREkos), 0, soap_copy_ns1__get_USCOREpathways_USCOREby_USCOREkos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREpathways_USCOREby_USCOREkos * SOAP_FMAC6 soap_new_ns1__get_USCOREpathways_USCOREby_USCOREkos(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREkos(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREpathways_USCOREby_USCOREkos(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREkos *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREkos * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREkos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREkos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREkos;
		if (size)
			*size = sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREkos);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREkos[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREkos);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREpathways_USCOREby_USCOREkos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREpathways_USCOREby_USCOREkos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREpathways_USCOREby_USCOREkos %p -> %p\n", q, p));
	*(struct ns1__get_USCOREpathways_USCOREby_USCOREkos*)p = *(struct ns1__get_USCOREpathways_USCOREby_USCOREkos*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse);
	if (soap_out_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse, 0, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREpathways_USCOREby_USCOREkosResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse*)p = *(struct ns1__get_USCOREpathways_USCOREby_USCOREkosResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREkos_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREkos_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->pathway_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREkos_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREkos_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREkos_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREkos_USCOREby_USCOREpathway *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathway);
	if (soap_out_ns1__get_USCOREkos_USCOREby_USCOREpathway(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREkos_USCOREby_USCOREpathway(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREkos_USCOREby_USCOREpathway *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathway), type);
	soap_out_std__string(soap, "pathway_id", -1, &a->pathway_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREkos_USCOREby_USCOREpathway * SOAP_FMAC4 soap_get_ns1__get_USCOREkos_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREkos_USCOREby_USCOREpathway *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREkos_USCOREby_USCOREpathway(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREkos_USCOREby_USCOREpathway * SOAP_FMAC4 soap_in_ns1__get_USCOREkos_USCOREby_USCOREpathway(struct soap *soap, const char *tag, struct ns1__get_USCOREkos_USCOREby_USCOREpathway *a, const char *type)
{
	short soap_flag_pathway_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREkos_USCOREby_USCOREpathway *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathway, sizeof(struct ns1__get_USCOREkos_USCOREby_USCOREpathway), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREkos_USCOREby_USCOREpathway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathway_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pathway_id", &a->pathway_USCOREid, "xsd:string"))
				{	soap_flag_pathway_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathway_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREkos_USCOREby_USCOREpathway *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathway, 0, sizeof(struct ns1__get_USCOREkos_USCOREby_USCOREpathway), 0, soap_copy_ns1__get_USCOREkos_USCOREby_USCOREpathway);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREkos_USCOREby_USCOREpathway * SOAP_FMAC6 soap_new_ns1__get_USCOREkos_USCOREby_USCOREpathway(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREkos_USCOREby_USCOREpathway(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREkos_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREkos_USCOREby_USCOREpathway *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREkos_USCOREby_USCOREpathway * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREkos_USCOREby_USCOREpathway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREkos_USCOREby_USCOREpathway(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathway, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREkos_USCOREby_USCOREpathway;
		if (size)
			*size = sizeof(struct ns1__get_USCOREkos_USCOREby_USCOREpathway);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREkos_USCOREby_USCOREpathway[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREkos_USCOREby_USCOREpathway);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREkos_USCOREby_USCOREpathway*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREkos_USCOREby_USCOREpathway(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREkos_USCOREby_USCOREpathway %p -> %p\n", q, p));
	*(struct ns1__get_USCOREkos_USCOREby_USCOREpathway*)p = *(struct ns1__get_USCOREkos_USCOREby_USCOREpathway*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse);
	if (soap_out_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse, sizeof(struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse, 0, sizeof(struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse*)p = *(struct ns1__get_USCOREkos_USCOREby_USCOREpathwayResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__convert_USCOREmol_USCOREto_USCOREkcf(struct soap *soap, const struct ns1__convert_USCOREmol_USCOREto_USCOREkcf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->mol_USCOREtext, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->mol_USCOREtext);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__convert_USCOREmol_USCOREto_USCOREkcf(struct soap *soap, struct ns1__convert_USCOREmol_USCOREto_USCOREkcf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->mol_USCOREtext);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__convert_USCOREmol_USCOREto_USCOREkcf(struct soap *soap, const struct ns1__convert_USCOREmol_USCOREto_USCOREkcf *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcf);
	if (soap_out_ns1__convert_USCOREmol_USCOREto_USCOREkcf(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__convert_USCOREmol_USCOREto_USCOREkcf(struct soap *soap, const char *tag, int id, const struct ns1__convert_USCOREmol_USCOREto_USCOREkcf *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcf), type);
	soap_out_std__string(soap, "mol_text", -1, &a->mol_USCOREtext, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__convert_USCOREmol_USCOREto_USCOREkcf * SOAP_FMAC4 soap_get_ns1__convert_USCOREmol_USCOREto_USCOREkcf(struct soap *soap, struct ns1__convert_USCOREmol_USCOREto_USCOREkcf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__convert_USCOREmol_USCOREto_USCOREkcf(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__convert_USCOREmol_USCOREto_USCOREkcf * SOAP_FMAC4 soap_in_ns1__convert_USCOREmol_USCOREto_USCOREkcf(struct soap *soap, const char *tag, struct ns1__convert_USCOREmol_USCOREto_USCOREkcf *a, const char *type)
{
	short soap_flag_mol_USCOREtext = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__convert_USCOREmol_USCOREto_USCOREkcf *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcf, sizeof(struct ns1__convert_USCOREmol_USCOREto_USCOREkcf), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__convert_USCOREmol_USCOREto_USCOREkcf(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mol_USCOREtext && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mol_text", &a->mol_USCOREtext, "xsd:string"))
				{	soap_flag_mol_USCOREtext--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mol_USCOREtext > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__convert_USCOREmol_USCOREto_USCOREkcf *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcf, 0, sizeof(struct ns1__convert_USCOREmol_USCOREto_USCOREkcf), 0, soap_copy_ns1__convert_USCOREmol_USCOREto_USCOREkcf);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__convert_USCOREmol_USCOREto_USCOREkcf * SOAP_FMAC6 soap_new_ns1__convert_USCOREmol_USCOREto_USCOREkcf(struct soap *soap, int n)
{	return soap_instantiate_ns1__convert_USCOREmol_USCOREto_USCOREkcf(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__convert_USCOREmol_USCOREto_USCOREkcf(struct soap *soap, struct ns1__convert_USCOREmol_USCOREto_USCOREkcf *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__convert_USCOREmol_USCOREto_USCOREkcf * SOAP_FMAC4 soap_instantiate_ns1__convert_USCOREmol_USCOREto_USCOREkcf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__convert_USCOREmol_USCOREto_USCOREkcf(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcf, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__convert_USCOREmol_USCOREto_USCOREkcf;
		if (size)
			*size = sizeof(struct ns1__convert_USCOREmol_USCOREto_USCOREkcf);
	}
	else
	{	cp->ptr = (void*)new struct ns1__convert_USCOREmol_USCOREto_USCOREkcf[n];
		if (size)
			*size = n * sizeof(struct ns1__convert_USCOREmol_USCOREto_USCOREkcf);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__convert_USCOREmol_USCOREto_USCOREkcf*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__convert_USCOREmol_USCOREto_USCOREkcf(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__convert_USCOREmol_USCOREto_USCOREkcf %p -> %p\n", q, p));
	*(struct ns1__convert_USCOREmol_USCOREto_USCOREkcf*)p = *(struct ns1__convert_USCOREmol_USCOREto_USCOREkcf*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(struct soap *soap, const struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(struct soap *soap, struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(struct soap *soap, const struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse);
	if (soap_out_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(struct soap *soap, const char *tag, int id, const struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse), type);
	soap_element_result(soap, "return");
	soap_out_std__string(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse * SOAP_FMAC4 soap_get_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(struct soap *soap, struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse * SOAP_FMAC4 soap_in_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(struct soap *soap, const char *tag, struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse, sizeof(struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse, 0, sizeof(struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse), 0, soap_copy_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse * SOAP_FMAC6 soap_new_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(struct soap *soap, struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse * SOAP_FMAC4 soap_instantiate_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse;
		if (size)
			*size = sizeof(struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse %p -> %p\n", q, p));
	*(struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse*)p = *(struct ns1__convert_USCOREmol_USCOREto_USCOREkcfResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(struct soap *soap, const struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->enzyme_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->enzyme_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->enzyme_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(struct soap *soap, const struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzyme);
	if (soap_out_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzyme), type);
	soap_out_std__string(soap, "enzyme_id", -1, &a->enzyme_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme * SOAP_FMAC4 soap_get_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme * SOAP_FMAC4 soap_in_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(struct soap *soap, const char *tag, struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme *a, const char *type)
{
	short soap_flag_enzyme_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzyme, sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enzyme_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "enzyme_id", &a->enzyme_USCOREid, "xsd:string"))
				{	soap_flag_enzyme_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enzyme_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzyme, 0, sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme), 0, soap_copy_ns1__get_USCOREglycans_USCOREby_USCOREenzyme);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme * SOAP_FMAC6 soap_new_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzyme, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme;
		if (size)
			*size = sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREglycans_USCOREby_USCOREenzyme(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme %p -> %p\n", q, p));
	*(struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme*)p = *(struct ns1__get_USCOREglycans_USCOREby_USCOREenzyme*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(struct soap *soap, const struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(struct soap *soap, const struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse);
	if (soap_out_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse, sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse, 0, sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse*)p = *(struct ns1__get_USCOREglycans_USCOREby_USCOREenzymeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(struct soap *soap, const struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->enzyme_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->enzyme_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->enzyme_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(struct soap *soap, const struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme);
	if (soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme), type);
	soap_out_std__string(soap, "enzyme_id", -1, &a->enzyme_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme * SOAP_FMAC4 soap_get_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme * SOAP_FMAC4 soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(struct soap *soap, const char *tag, struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme *a, const char *type)
{
	short soap_flag_enzyme_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme, sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enzyme_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "enzyme_id", &a->enzyme_USCOREid, "xsd:string"))
				{	soap_flag_enzyme_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enzyme_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme, 0, sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme), 0, soap_copy_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme * SOAP_FMAC6 soap_new_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme;
		if (size)
			*size = sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREcompounds_USCOREby_USCOREenzyme(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme %p -> %p\n", q, p));
	*(struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme*)p = *(struct ns1__get_USCOREcompounds_USCOREby_USCOREenzyme*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(struct soap *soap, const struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(struct soap *soap, const struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse);
	if (soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse, sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse, 0, sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse*)p = *(struct ns1__get_USCOREcompounds_USCOREby_USCOREenzymeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREglycans_USCOREby_USCOREreaction(struct soap *soap, const struct ns1__get_USCOREglycans_USCOREby_USCOREreaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->reaction_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->reaction_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREglycans_USCOREby_USCOREreaction(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREreaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->reaction_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREglycans_USCOREby_USCOREreaction(struct soap *soap, const struct ns1__get_USCOREglycans_USCOREby_USCOREreaction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreaction);
	if (soap_out_ns1__get_USCOREglycans_USCOREby_USCOREreaction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREglycans_USCOREby_USCOREreaction(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREglycans_USCOREby_USCOREreaction *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreaction), type);
	soap_out_std__string(soap, "reaction_id", -1, &a->reaction_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREreaction * SOAP_FMAC4 soap_get_ns1__get_USCOREglycans_USCOREby_USCOREreaction(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREreaction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREglycans_USCOREby_USCOREreaction(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREreaction * SOAP_FMAC4 soap_in_ns1__get_USCOREglycans_USCOREby_USCOREreaction(struct soap *soap, const char *tag, struct ns1__get_USCOREglycans_USCOREby_USCOREreaction *a, const char *type)
{
	short soap_flag_reaction_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREglycans_USCOREby_USCOREreaction *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreaction, sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREreaction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREglycans_USCOREby_USCOREreaction(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reaction_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "reaction_id", &a->reaction_USCOREid, "xsd:string"))
				{	soap_flag_reaction_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reaction_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREglycans_USCOREby_USCOREreaction *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreaction, 0, sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREreaction), 0, soap_copy_ns1__get_USCOREglycans_USCOREby_USCOREreaction);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREglycans_USCOREby_USCOREreaction * SOAP_FMAC6 soap_new_ns1__get_USCOREglycans_USCOREby_USCOREreaction(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREreaction(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREglycans_USCOREby_USCOREreaction(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREreaction *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREreaction * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREreaction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREreaction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreaction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREglycans_USCOREby_USCOREreaction;
		if (size)
			*size = sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREreaction);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREglycans_USCOREby_USCOREreaction[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREreaction);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREglycans_USCOREby_USCOREreaction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREglycans_USCOREby_USCOREreaction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREglycans_USCOREby_USCOREreaction %p -> %p\n", q, p));
	*(struct ns1__get_USCOREglycans_USCOREby_USCOREreaction*)p = *(struct ns1__get_USCOREglycans_USCOREby_USCOREreaction*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(struct soap *soap, const struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(struct soap *soap, const struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse);
	if (soap_out_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse, sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse, 0, sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse*)p = *(struct ns1__get_USCOREglycans_USCOREby_USCOREreactionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(struct soap *soap, const struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->reaction_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->reaction_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->reaction_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(struct soap *soap, const struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreaction);
	if (soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreaction), type);
	soap_out_std__string(soap, "reaction_id", -1, &a->reaction_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction * SOAP_FMAC4 soap_get_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction * SOAP_FMAC4 soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(struct soap *soap, const char *tag, struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction *a, const char *type)
{
	short soap_flag_reaction_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreaction, sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reaction_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "reaction_id", &a->reaction_USCOREid, "xsd:string"))
				{	soap_flag_reaction_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reaction_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreaction, 0, sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction), 0, soap_copy_ns1__get_USCOREcompounds_USCOREby_USCOREreaction);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction * SOAP_FMAC6 soap_new_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreaction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction;
		if (size)
			*size = sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREcompounds_USCOREby_USCOREreaction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction %p -> %p\n", q, p));
	*(struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction*)p = *(struct ns1__get_USCOREcompounds_USCOREby_USCOREreaction*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(struct soap *soap, const struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(struct soap *soap, const struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse);
	if (soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse, sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse, 0, sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse*)p = *(struct ns1__get_USCOREcompounds_USCOREby_USCOREreactionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREglycans_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREglycans_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->pathway_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREglycans_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREglycans_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREglycans_USCOREby_USCOREpathway *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathway);
	if (soap_out_ns1__get_USCOREglycans_USCOREby_USCOREpathway(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREglycans_USCOREby_USCOREpathway(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREglycans_USCOREby_USCOREpathway *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathway), type);
	soap_out_std__string(soap, "pathway_id", -1, &a->pathway_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREpathway * SOAP_FMAC4 soap_get_ns1__get_USCOREglycans_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREpathway *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREglycans_USCOREby_USCOREpathway(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREpathway * SOAP_FMAC4 soap_in_ns1__get_USCOREglycans_USCOREby_USCOREpathway(struct soap *soap, const char *tag, struct ns1__get_USCOREglycans_USCOREby_USCOREpathway *a, const char *type)
{
	short soap_flag_pathway_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREglycans_USCOREby_USCOREpathway *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathway, sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREpathway), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREglycans_USCOREby_USCOREpathway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathway_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pathway_id", &a->pathway_USCOREid, "xsd:string"))
				{	soap_flag_pathway_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathway_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREglycans_USCOREby_USCOREpathway *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathway, 0, sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREpathway), 0, soap_copy_ns1__get_USCOREglycans_USCOREby_USCOREpathway);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREglycans_USCOREby_USCOREpathway * SOAP_FMAC6 soap_new_ns1__get_USCOREglycans_USCOREby_USCOREpathway(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREpathway(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREglycans_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREpathway *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREpathway * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREpathway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREpathway(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathway, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREglycans_USCOREby_USCOREpathway;
		if (size)
			*size = sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREpathway);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREglycans_USCOREby_USCOREpathway[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREpathway);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREglycans_USCOREby_USCOREpathway*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREglycans_USCOREby_USCOREpathway(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREglycans_USCOREby_USCOREpathway %p -> %p\n", q, p));
	*(struct ns1__get_USCOREglycans_USCOREby_USCOREpathway*)p = *(struct ns1__get_USCOREglycans_USCOREby_USCOREpathway*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse);
	if (soap_out_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse, sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse, 0, sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse*)p = *(struct ns1__get_USCOREglycans_USCOREby_USCOREpathwayResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->pathway_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathway);
	if (soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathway), type);
	soap_out_std__string(soap, "pathway_id", -1, &a->pathway_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway * SOAP_FMAC4 soap_get_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway * SOAP_FMAC4 soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(struct soap *soap, const char *tag, struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway *a, const char *type)
{
	short soap_flag_pathway_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathway, sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathway_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pathway_id", &a->pathway_USCOREid, "xsd:string"))
				{	soap_flag_pathway_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathway_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathway, 0, sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway), 0, soap_copy_ns1__get_USCOREcompounds_USCOREby_USCOREpathway);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway * SOAP_FMAC6 soap_new_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathway, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway;
		if (size)
			*size = sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREcompounds_USCOREby_USCOREpathway(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway %p -> %p\n", q, p));
	*(struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway*)p = *(struct ns1__get_USCOREcompounds_USCOREby_USCOREpathway*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse);
	if (soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse, sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse, 0, sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse*)p = *(struct ns1__get_USCOREcompounds_USCOREby_USCOREpathwayResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREglycans(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREglycans *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->glycan_USCOREid_USCORElist);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREpathways_USCOREby_USCOREglycans(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREglycans *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->glycan_USCOREid_USCORElist = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREpathways_USCOREby_USCOREglycans(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREglycans *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycans);
	if (soap_out_ns1__get_USCOREpathways_USCOREby_USCOREglycans(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREpathways_USCOREby_USCOREglycans(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREpathways_USCOREby_USCOREglycans *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycans), type);
	soap_out_PointerToArrayOfstring(soap, "glycan_id_list", -1, &a->glycan_USCOREid_USCORElist, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREglycans * SOAP_FMAC4 soap_get_ns1__get_USCOREpathways_USCOREby_USCOREglycans(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREglycans *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREpathways_USCOREby_USCOREglycans(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREglycans * SOAP_FMAC4 soap_in_ns1__get_USCOREpathways_USCOREby_USCOREglycans(struct soap *soap, const char *tag, struct ns1__get_USCOREpathways_USCOREby_USCOREglycans *a, const char *type)
{
	short soap_flag_glycan_USCOREid_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREglycans *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycans, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREglycans), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREpathways_USCOREby_USCOREglycans(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_glycan_USCOREid_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "glycan_id_list", &a->glycan_USCOREid_USCORElist, "xsd:string"))
				{	soap_flag_glycan_USCOREid_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREglycans *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycans, 0, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREglycans), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREpathways_USCOREby_USCOREglycans * SOAP_FMAC6 soap_new_ns1__get_USCOREpathways_USCOREby_USCOREglycans(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREglycans(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREpathways_USCOREby_USCOREglycans(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREglycans *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREglycans * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREglycans(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREglycans(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycans, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREglycans;
		if (size)
			*size = sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREglycans);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREglycans[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREglycans);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREpathways_USCOREby_USCOREglycans*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREpathways_USCOREby_USCOREglycans(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREpathways_USCOREby_USCOREglycans %p -> %p\n", q, p));
	*(struct ns1__get_USCOREpathways_USCOREby_USCOREglycans*)p = *(struct ns1__get_USCOREpathways_USCOREby_USCOREglycans*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse);
	if (soap_out_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse, 0, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse*)p = *(struct ns1__get_USCOREpathways_USCOREby_USCOREglycansResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->compound_USCOREid_USCORElist);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->compound_USCOREid_USCORElist = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompounds);
	if (soap_out_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompounds), type);
	soap_out_PointerToArrayOfstring(soap, "compound_id_list", -1, &a->compound_USCOREid_USCORElist, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds * SOAP_FMAC4 soap_get_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds * SOAP_FMAC4 soap_in_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(struct soap *soap, const char *tag, struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds *a, const char *type)
{
	short soap_flag_compound_USCOREid_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompounds, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_compound_USCOREid_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "compound_id_list", &a->compound_USCOREid_USCORElist, "xsd:string"))
				{	soap_flag_compound_USCOREid_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompounds, 0, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds * SOAP_FMAC6 soap_new_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompounds, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds;
		if (size)
			*size = sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREpathways_USCOREby_USCOREcompounds(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds %p -> %p\n", q, p));
	*(struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds*)p = *(struct ns1__get_USCOREpathways_USCOREby_USCOREcompounds*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse);
	if (soap_out_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse, 0, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse*)p = *(struct ns1__get_USCOREpathways_USCOREby_USCOREcompoundsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->compound_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->compound_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->compound_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompound);
	if (soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompound), type);
	soap_out_std__string(soap, "compound_id", -1, &a->compound_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound * SOAP_FMAC4 soap_get_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound * SOAP_FMAC4 soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(struct soap *soap, const char *tag, struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound *a, const char *type)
{
	short soap_flag_compound_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompound, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_compound_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "compound_id", &a->compound_USCOREid, "xsd:string"))
				{	soap_flag_compound_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_compound_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompound, 0, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound), 0, soap_copy_ns1__get_USCOREenzymes_USCOREby_USCOREcompound);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound * SOAP_FMAC6 soap_new_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompound, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound;
		if (size)
			*size = sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREenzymes_USCOREby_USCOREcompound(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound %p -> %p\n", q, p));
	*(struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound*)p = *(struct ns1__get_USCOREenzymes_USCOREby_USCOREcompound*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse);
	if (soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse, 0, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse*)p = *(struct ns1__get_USCOREenzymes_USCOREby_USCOREcompoundResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->glycan_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->glycan_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->glycan_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycan);
	if (soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycan), type);
	soap_out_std__string(soap, "glycan_id", -1, &a->glycan_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan * SOAP_FMAC4 soap_get_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan * SOAP_FMAC4 soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(struct soap *soap, const char *tag, struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan *a, const char *type)
{
	short soap_flag_glycan_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycan, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_glycan_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "glycan_id", &a->glycan_USCOREid, "xsd:string"))
				{	soap_flag_glycan_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_glycan_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycan, 0, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan), 0, soap_copy_ns1__get_USCOREenzymes_USCOREby_USCOREglycan);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan * SOAP_FMAC6 soap_new_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycan, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan;
		if (size)
			*size = sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREenzymes_USCOREby_USCOREglycan(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan %p -> %p\n", q, p));
	*(struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan*)p = *(struct ns1__get_USCOREenzymes_USCOREby_USCOREglycan*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse);
	if (soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse, 0, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse*)p = *(struct ns1__get_USCOREenzymes_USCOREby_USCOREglycanResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREcompound(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREcompound *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->compound_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->compound_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREreactions_USCOREby_USCOREcompound(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREcompound *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->compound_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREreactions_USCOREby_USCOREcompound(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREcompound *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompound);
	if (soap_out_ns1__get_USCOREreactions_USCOREby_USCOREcompound(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREreactions_USCOREby_USCOREcompound(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREreactions_USCOREby_USCOREcompound *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompound), type);
	soap_out_std__string(soap, "compound_id", -1, &a->compound_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREcompound * SOAP_FMAC4 soap_get_ns1__get_USCOREreactions_USCOREby_USCOREcompound(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREcompound *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREreactions_USCOREby_USCOREcompound(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREcompound * SOAP_FMAC4 soap_in_ns1__get_USCOREreactions_USCOREby_USCOREcompound(struct soap *soap, const char *tag, struct ns1__get_USCOREreactions_USCOREby_USCOREcompound *a, const char *type)
{
	short soap_flag_compound_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREcompound *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompound, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREcompound), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREreactions_USCOREby_USCOREcompound(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_compound_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "compound_id", &a->compound_USCOREid, "xsd:string"))
				{	soap_flag_compound_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_compound_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREcompound *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompound, 0, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREcompound), 0, soap_copy_ns1__get_USCOREreactions_USCOREby_USCOREcompound);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREreactions_USCOREby_USCOREcompound * SOAP_FMAC6 soap_new_ns1__get_USCOREreactions_USCOREby_USCOREcompound(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREcompound(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREreactions_USCOREby_USCOREcompound(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREcompound *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREcompound * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREcompound(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREcompound(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompound, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREcompound;
		if (size)
			*size = sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREcompound);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREcompound[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREcompound);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREreactions_USCOREby_USCOREcompound*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREreactions_USCOREby_USCOREcompound(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREreactions_USCOREby_USCOREcompound %p -> %p\n", q, p));
	*(struct ns1__get_USCOREreactions_USCOREby_USCOREcompound*)p = *(struct ns1__get_USCOREreactions_USCOREby_USCOREcompound*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse);
	if (soap_out_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse, 0, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse*)p = *(struct ns1__get_USCOREreactions_USCOREby_USCOREcompoundResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREglycan(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREglycan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->glycan_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->glycan_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREreactions_USCOREby_USCOREglycan(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREglycan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->glycan_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREreactions_USCOREby_USCOREglycan(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREglycan *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycan);
	if (soap_out_ns1__get_USCOREreactions_USCOREby_USCOREglycan(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREreactions_USCOREby_USCOREglycan(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREreactions_USCOREby_USCOREglycan *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycan), type);
	soap_out_std__string(soap, "glycan_id", -1, &a->glycan_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREglycan * SOAP_FMAC4 soap_get_ns1__get_USCOREreactions_USCOREby_USCOREglycan(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREglycan *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREreactions_USCOREby_USCOREglycan(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREglycan * SOAP_FMAC4 soap_in_ns1__get_USCOREreactions_USCOREby_USCOREglycan(struct soap *soap, const char *tag, struct ns1__get_USCOREreactions_USCOREby_USCOREglycan *a, const char *type)
{
	short soap_flag_glycan_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREglycan *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycan, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREglycan), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREreactions_USCOREby_USCOREglycan(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_glycan_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "glycan_id", &a->glycan_USCOREid, "xsd:string"))
				{	soap_flag_glycan_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_glycan_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREglycan *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycan, 0, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREglycan), 0, soap_copy_ns1__get_USCOREreactions_USCOREby_USCOREglycan);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREreactions_USCOREby_USCOREglycan * SOAP_FMAC6 soap_new_ns1__get_USCOREreactions_USCOREby_USCOREglycan(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREglycan(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREreactions_USCOREby_USCOREglycan(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREglycan *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREglycan * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREglycan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREglycan(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycan, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREglycan;
		if (size)
			*size = sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREglycan);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREglycan[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREglycan);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREreactions_USCOREby_USCOREglycan*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREreactions_USCOREby_USCOREglycan(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREreactions_USCOREby_USCOREglycan %p -> %p\n", q, p));
	*(struct ns1__get_USCOREreactions_USCOREby_USCOREglycan*)p = *(struct ns1__get_USCOREreactions_USCOREby_USCOREglycan*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse);
	if (soap_out_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse, 0, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse*)p = *(struct ns1__get_USCOREreactions_USCOREby_USCOREglycanResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, const struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->abbr, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->abbr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->abbr);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, const struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism);
	if (soap_out_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism), type);
	soap_out_std__string(soap, "abbr", -1, &a->abbr, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism * SOAP_FMAC4 soap_get_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism * SOAP_FMAC4 soap_in_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, const char *tag, struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism *a, const char *type)
{
	short soap_flag_abbr = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism, sizeof(struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_abbr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "abbr", &a->abbr, "xsd:string"))
				{	soap_flag_abbr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_abbr > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism, 0, sizeof(struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism), 0, soap_copy_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism * SOAP_FMAC6 soap_new_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism;
		if (size)
			*size = sizeof(struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism %p -> %p\n", q, p));
	*(struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism*)p = *(struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganism*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, const struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->return_, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, const struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse);
	if (soap_out_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse), type);
	soap_element_result(soap, "return");
	soap_out_int(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse, sizeof(struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "return", &a->return_, "xsd:int"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse, 0, sizeof(struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse*)p = *(struct ns1__get_USCOREnumber_USCOREof_USCOREgenes_USCOREby_USCOREorganismResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREorganism *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->org, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->org);
	soap_embedded(soap, &a->start, SOAP_TYPE_int);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREorganism *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->org);
	soap_default_int(soap, &a->start);
	soap_default_int(soap, &a->max_USCOREresults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREorganism *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganism);
	if (soap_out_ns1__get_USCOREgenes_USCOREby_USCOREorganism(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREgenes_USCOREby_USCOREorganism *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganism), type);
	soap_out_std__string(soap, "org", -1, &a->org, "");
	soap_out_int(soap, "start", -1, &a->start, "");
	soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREorganism * SOAP_FMAC4 soap_get_ns1__get_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREorganism *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREgenes_USCOREby_USCOREorganism(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREorganism * SOAP_FMAC4 soap_in_ns1__get_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, const char *tag, struct ns1__get_USCOREgenes_USCOREby_USCOREorganism *a, const char *type)
{
	short soap_flag_org = 1, soap_flag_start = 1, soap_flag_max_USCOREresults = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREorganism *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganism, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREorganism), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREgenes_USCOREby_USCOREorganism(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_org && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "org", &a->org, "xsd:string"))
				{	soap_flag_org--;
					continue;
				}
			if (soap_flag_start && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start", &a->start, "xsd:int"))
				{	soap_flag_start--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_org > 0 || soap_flag_start > 0 || soap_flag_max_USCOREresults > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREorganism *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganism, 0, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREorganism), 0, soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREorganism);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREgenes_USCOREby_USCOREorganism * SOAP_FMAC6 soap_new_ns1__get_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREorganism(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREorganism *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREorganism * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREorganism(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganism, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREorganism;
		if (size)
			*size = sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREorganism);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREorganism[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREorganism);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREgenes_USCOREby_USCOREorganism*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREorganism(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREgenes_USCOREby_USCOREorganism %p -> %p\n", q, p));
	*(struct ns1__get_USCOREgenes_USCOREby_USCOREorganism*)p = *(struct ns1__get_USCOREgenes_USCOREby_USCOREorganism*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse);
	if (soap_out_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse, 0, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse*)p = *(struct ns1__get_USCOREgenes_USCOREby_USCOREorganismResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->enzyme_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->enzyme_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->enzyme_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzyme);
	if (soap_out_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzyme), type);
	soap_out_std__string(soap, "enzyme_id", -1, &a->enzyme_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme * SOAP_FMAC4 soap_get_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme * SOAP_FMAC4 soap_in_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(struct soap *soap, const char *tag, struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme *a, const char *type)
{
	short soap_flag_enzyme_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzyme, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enzyme_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "enzyme_id", &a->enzyme_USCOREid, "xsd:string"))
				{	soap_flag_enzyme_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enzyme_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzyme, 0, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme), 0, soap_copy_ns1__get_USCOREreactions_USCOREby_USCOREenzyme);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme * SOAP_FMAC6 soap_new_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzyme, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme;
		if (size)
			*size = sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREreactions_USCOREby_USCOREenzyme(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme %p -> %p\n", q, p));
	*(struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme*)p = *(struct ns1__get_USCOREreactions_USCOREby_USCOREenzyme*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse);
	if (soap_out_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse, 0, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse*)p = *(struct ns1__get_USCOREreactions_USCOREby_USCOREenzymeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->reaction_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->reaction_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->reaction_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreaction);
	if (soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreaction), type);
	soap_out_std__string(soap, "reaction_id", -1, &a->reaction_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction * SOAP_FMAC4 soap_get_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction * SOAP_FMAC4 soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(struct soap *soap, const char *tag, struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction *a, const char *type)
{
	short soap_flag_reaction_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreaction, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reaction_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "reaction_id", &a->reaction_USCOREid, "xsd:string"))
				{	soap_flag_reaction_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reaction_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreaction, 0, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction), 0, soap_copy_ns1__get_USCOREenzymes_USCOREby_USCOREreaction);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction * SOAP_FMAC6 soap_new_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreaction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction;
		if (size)
			*size = sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREenzymes_USCOREby_USCOREreaction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction %p -> %p\n", q, p));
	*(struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction*)p = *(struct ns1__get_USCOREenzymes_USCOREby_USCOREreaction*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse);
	if (soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse, 0, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse*)p = *(struct ns1__get_USCOREenzymes_USCOREby_USCOREreactionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->genes_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->genes_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->genes_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREenzymes_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREgene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgene);
	if (soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREgene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREgene(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREenzymes_USCOREby_USCOREgene *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgene), type);
	soap_out_std__string(soap, "genes_id", -1, &a->genes_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREgene * SOAP_FMAC4 soap_get_ns1__get_USCOREenzymes_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREgene *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREgene(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREgene * SOAP_FMAC4 soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREgene(struct soap *soap, const char *tag, struct ns1__get_USCOREenzymes_USCOREby_USCOREgene *a, const char *type)
{
	short soap_flag_genes_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREgene *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgene, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREgene), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREgene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genes_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genes_id", &a->genes_USCOREid, "xsd:string"))
				{	soap_flag_genes_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genes_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREgene *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgene, 0, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREgene), 0, soap_copy_ns1__get_USCOREenzymes_USCOREby_USCOREgene);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREenzymes_USCOREby_USCOREgene * SOAP_FMAC6 soap_new_ns1__get_USCOREenzymes_USCOREby_USCOREgene(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREgene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREenzymes_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREgene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREgene * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREgene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREgene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREgene;
		if (size)
			*size = sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREgene);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREgene[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREgene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREenzymes_USCOREby_USCOREgene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREenzymes_USCOREby_USCOREgene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREenzymes_USCOREby_USCOREgene %p -> %p\n", q, p));
	*(struct ns1__get_USCOREenzymes_USCOREby_USCOREgene*)p = *(struct ns1__get_USCOREenzymes_USCOREby_USCOREgene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse);
	if (soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse, 0, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse*)p = *(struct ns1__get_USCOREenzymes_USCOREby_USCOREgeneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->enzyme_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->enzyme_USCOREid);
	soap_embedded(soap, &a->org, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->org);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->enzyme_USCOREid);
	soap_default_std__string(soap, &a->org);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzyme);
	if (soap_out_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzyme), type);
	soap_out_std__string(soap, "enzyme_id", -1, &a->enzyme_USCOREid, "");
	soap_out_std__string(soap, "org", -1, &a->org, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme * SOAP_FMAC4 soap_get_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme * SOAP_FMAC4 soap_in_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(struct soap *soap, const char *tag, struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme *a, const char *type)
{
	short soap_flag_enzyme_USCOREid = 1, soap_flag_org = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzyme, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enzyme_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "enzyme_id", &a->enzyme_USCOREid, "xsd:string"))
				{	soap_flag_enzyme_USCOREid--;
					continue;
				}
			if (soap_flag_org && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "org", &a->org, "xsd:string"))
				{	soap_flag_org--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enzyme_USCOREid > 0 || soap_flag_org > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzyme, 0, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme), 0, soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREenzyme);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme * SOAP_FMAC6 soap_new_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzyme, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme;
		if (size)
			*size = sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREenzyme(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme %p -> %p\n", q, p));
	*(struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme*)p = *(struct ns1__get_USCOREgenes_USCOREby_USCOREenzyme*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse);
	if (soap_out_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse, 0, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse*)p = *(struct ns1__get_USCOREgenes_USCOREby_USCOREenzymeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCORElinked_USCOREpathways(struct soap *soap, const struct ns1__get_USCORElinked_USCOREpathways *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->pathway_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCORElinked_USCOREpathways(struct soap *soap, struct ns1__get_USCORElinked_USCOREpathways *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCORElinked_USCOREpathways(struct soap *soap, const struct ns1__get_USCORElinked_USCOREpathways *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCORElinked_USCOREpathways);
	if (soap_out_ns1__get_USCORElinked_USCOREpathways(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCORElinked_USCOREpathways(struct soap *soap, const char *tag, int id, const struct ns1__get_USCORElinked_USCOREpathways *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCORElinked_USCOREpathways), type);
	soap_out_std__string(soap, "pathway_id", -1, &a->pathway_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCORElinked_USCOREpathways * SOAP_FMAC4 soap_get_ns1__get_USCORElinked_USCOREpathways(struct soap *soap, struct ns1__get_USCORElinked_USCOREpathways *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCORElinked_USCOREpathways(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCORElinked_USCOREpathways * SOAP_FMAC4 soap_in_ns1__get_USCORElinked_USCOREpathways(struct soap *soap, const char *tag, struct ns1__get_USCORElinked_USCOREpathways *a, const char *type)
{
	short soap_flag_pathway_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCORElinked_USCOREpathways *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCORElinked_USCOREpathways, sizeof(struct ns1__get_USCORElinked_USCOREpathways), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCORElinked_USCOREpathways(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathway_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pathway_id", &a->pathway_USCOREid, "xsd:string"))
				{	soap_flag_pathway_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathway_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORElinked_USCOREpathways *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCORElinked_USCOREpathways, 0, sizeof(struct ns1__get_USCORElinked_USCOREpathways), 0, soap_copy_ns1__get_USCORElinked_USCOREpathways);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCORElinked_USCOREpathways * SOAP_FMAC6 soap_new_ns1__get_USCORElinked_USCOREpathways(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCORElinked_USCOREpathways(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCORElinked_USCOREpathways(struct soap *soap, struct ns1__get_USCORElinked_USCOREpathways *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCORElinked_USCOREpathways * SOAP_FMAC4 soap_instantiate_ns1__get_USCORElinked_USCOREpathways(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCORElinked_USCOREpathways(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCORElinked_USCOREpathways, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCORElinked_USCOREpathways;
		if (size)
			*size = sizeof(struct ns1__get_USCORElinked_USCOREpathways);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCORElinked_USCOREpathways[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCORElinked_USCOREpathways);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCORElinked_USCOREpathways*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCORElinked_USCOREpathways(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCORElinked_USCOREpathways %p -> %p\n", q, p));
	*(struct ns1__get_USCORElinked_USCOREpathways*)p = *(struct ns1__get_USCORElinked_USCOREpathways*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCORElinked_USCOREpathwaysResponse(struct soap *soap, const struct ns1__get_USCORElinked_USCOREpathwaysResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCORElinked_USCOREpathwaysResponse(struct soap *soap, struct ns1__get_USCORElinked_USCOREpathwaysResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCORElinked_USCOREpathwaysResponse(struct soap *soap, const struct ns1__get_USCORElinked_USCOREpathwaysResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCORElinked_USCOREpathwaysResponse);
	if (soap_out_ns1__get_USCORElinked_USCOREpathwaysResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCORElinked_USCOREpathwaysResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCORElinked_USCOREpathwaysResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCORElinked_USCOREpathwaysResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCORElinked_USCOREpathwaysResponse * SOAP_FMAC4 soap_get_ns1__get_USCORElinked_USCOREpathwaysResponse(struct soap *soap, struct ns1__get_USCORElinked_USCOREpathwaysResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCORElinked_USCOREpathwaysResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCORElinked_USCOREpathwaysResponse * SOAP_FMAC4 soap_in_ns1__get_USCORElinked_USCOREpathwaysResponse(struct soap *soap, const char *tag, struct ns1__get_USCORElinked_USCOREpathwaysResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCORElinked_USCOREpathwaysResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCORElinked_USCOREpathwaysResponse, sizeof(struct ns1__get_USCORElinked_USCOREpathwaysResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCORElinked_USCOREpathwaysResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORElinked_USCOREpathwaysResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCORElinked_USCOREpathwaysResponse, 0, sizeof(struct ns1__get_USCORElinked_USCOREpathwaysResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCORElinked_USCOREpathwaysResponse * SOAP_FMAC6 soap_new_ns1__get_USCORElinked_USCOREpathwaysResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCORElinked_USCOREpathwaysResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCORElinked_USCOREpathwaysResponse(struct soap *soap, struct ns1__get_USCORElinked_USCOREpathwaysResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCORElinked_USCOREpathwaysResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCORElinked_USCOREpathwaysResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCORElinked_USCOREpathwaysResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCORElinked_USCOREpathwaysResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCORElinked_USCOREpathwaysResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCORElinked_USCOREpathwaysResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCORElinked_USCOREpathwaysResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCORElinked_USCOREpathwaysResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCORElinked_USCOREpathwaysResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCORElinked_USCOREpathwaysResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCORElinked_USCOREpathwaysResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCORElinked_USCOREpathwaysResponse*)p = *(struct ns1__get_USCORElinked_USCOREpathwaysResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREreactions(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREreactions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->reaction_USCOREid_USCORElist);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREpathways_USCOREby_USCOREreactions(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREreactions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->reaction_USCOREid_USCORElist = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREpathways_USCOREby_USCOREreactions(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREreactions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactions);
	if (soap_out_ns1__get_USCOREpathways_USCOREby_USCOREreactions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREpathways_USCOREby_USCOREreactions(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREpathways_USCOREby_USCOREreactions *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactions), type);
	soap_out_PointerToArrayOfstring(soap, "reaction_id_list", -1, &a->reaction_USCOREid_USCORElist, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREreactions * SOAP_FMAC4 soap_get_ns1__get_USCOREpathways_USCOREby_USCOREreactions(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREreactions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREpathways_USCOREby_USCOREreactions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREreactions * SOAP_FMAC4 soap_in_ns1__get_USCOREpathways_USCOREby_USCOREreactions(struct soap *soap, const char *tag, struct ns1__get_USCOREpathways_USCOREby_USCOREreactions *a, const char *type)
{
	short soap_flag_reaction_USCOREid_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREreactions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactions, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREreactions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREpathways_USCOREby_USCOREreactions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reaction_USCOREid_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "reaction_id_list", &a->reaction_USCOREid_USCORElist, "xsd:string"))
				{	soap_flag_reaction_USCOREid_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREreactions *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactions, 0, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREreactions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREpathways_USCOREby_USCOREreactions * SOAP_FMAC6 soap_new_ns1__get_USCOREpathways_USCOREby_USCOREreactions(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREreactions(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREpathways_USCOREby_USCOREreactions(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREreactions *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREreactions * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREreactions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREreactions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREreactions;
		if (size)
			*size = sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREreactions);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREreactions[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREreactions);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREpathways_USCOREby_USCOREreactions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREpathways_USCOREby_USCOREreactions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREpathways_USCOREby_USCOREreactions %p -> %p\n", q, p));
	*(struct ns1__get_USCOREpathways_USCOREby_USCOREreactions*)p = *(struct ns1__get_USCOREpathways_USCOREby_USCOREreactions*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse);
	if (soap_out_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse, 0, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse*)p = *(struct ns1__get_USCOREpathways_USCOREby_USCOREreactionsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->enzyme_USCOREid_USCORElist);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->enzyme_USCOREid_USCORElist = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymes);
	if (soap_out_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymes), type);
	soap_out_PointerToArrayOfstring(soap, "enzyme_id_list", -1, &a->enzyme_USCOREid_USCORElist, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes * SOAP_FMAC4 soap_get_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes * SOAP_FMAC4 soap_in_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(struct soap *soap, const char *tag, struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes *a, const char *type)
{
	short soap_flag_enzyme_USCOREid_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymes, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enzyme_USCOREid_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "enzyme_id_list", &a->enzyme_USCOREid_USCORElist, "xsd:string"))
				{	soap_flag_enzyme_USCOREid_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymes, 0, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes * SOAP_FMAC6 soap_new_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes;
		if (size)
			*size = sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREpathways_USCOREby_USCOREenzymes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes %p -> %p\n", q, p));
	*(struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes*)p = *(struct ns1__get_USCOREpathways_USCOREby_USCOREenzymes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse);
	if (soap_out_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse, 0, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse*)p = *(struct ns1__get_USCOREpathways_USCOREby_USCOREenzymesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREgenes(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREgenes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->genes_USCOREid_USCORElist);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREpathways_USCOREby_USCOREgenes(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREgenes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->genes_USCOREid_USCORElist = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREpathways_USCOREby_USCOREgenes(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREgenes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenes);
	if (soap_out_ns1__get_USCOREpathways_USCOREby_USCOREgenes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREpathways_USCOREby_USCOREgenes(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREpathways_USCOREby_USCOREgenes *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenes), type);
	soap_out_PointerToArrayOfstring(soap, "genes_id_list", -1, &a->genes_USCOREid_USCORElist, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREgenes * SOAP_FMAC4 soap_get_ns1__get_USCOREpathways_USCOREby_USCOREgenes(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREgenes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREpathways_USCOREby_USCOREgenes(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREgenes * SOAP_FMAC4 soap_in_ns1__get_USCOREpathways_USCOREby_USCOREgenes(struct soap *soap, const char *tag, struct ns1__get_USCOREpathways_USCOREby_USCOREgenes *a, const char *type)
{
	short soap_flag_genes_USCOREid_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREgenes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenes, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREgenes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREpathways_USCOREby_USCOREgenes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genes_USCOREid_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "genes_id_list", &a->genes_USCOREid_USCORElist, "xsd:string"))
				{	soap_flag_genes_USCOREid_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREgenes *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenes, 0, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREgenes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREpathways_USCOREby_USCOREgenes * SOAP_FMAC6 soap_new_ns1__get_USCOREpathways_USCOREby_USCOREgenes(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREgenes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREpathways_USCOREby_USCOREgenes(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREgenes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREgenes * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREgenes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREgenes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREgenes;
		if (size)
			*size = sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREgenes);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREgenes[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREgenes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREpathways_USCOREby_USCOREgenes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREpathways_USCOREby_USCOREgenes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREpathways_USCOREby_USCOREgenes %p -> %p\n", q, p));
	*(struct ns1__get_USCOREpathways_USCOREby_USCOREgenes*)p = *(struct ns1__get_USCOREpathways_USCOREby_USCOREgenes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(struct soap *soap, const struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse);
	if (soap_out_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse, 0, sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(struct soap *soap, struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse*)p = *(struct ns1__get_USCOREpathways_USCOREby_USCOREgenesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->pathway_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREreactions_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREreactions_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREpathway *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathway);
	if (soap_out_ns1__get_USCOREreactions_USCOREby_USCOREpathway(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREreactions_USCOREby_USCOREpathway(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREreactions_USCOREby_USCOREpathway *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathway), type);
	soap_out_std__string(soap, "pathway_id", -1, &a->pathway_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREpathway * SOAP_FMAC4 soap_get_ns1__get_USCOREreactions_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREpathway *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREreactions_USCOREby_USCOREpathway(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREpathway * SOAP_FMAC4 soap_in_ns1__get_USCOREreactions_USCOREby_USCOREpathway(struct soap *soap, const char *tag, struct ns1__get_USCOREreactions_USCOREby_USCOREpathway *a, const char *type)
{
	short soap_flag_pathway_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREpathway *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathway, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREpathway), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREreactions_USCOREby_USCOREpathway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathway_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pathway_id", &a->pathway_USCOREid, "xsd:string"))
				{	soap_flag_pathway_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathway_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREpathway *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathway, 0, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREpathway), 0, soap_copy_ns1__get_USCOREreactions_USCOREby_USCOREpathway);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREreactions_USCOREby_USCOREpathway * SOAP_FMAC6 soap_new_ns1__get_USCOREreactions_USCOREby_USCOREpathway(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREpathway(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREreactions_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREpathway *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREpathway * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREpathway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREpathway(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathway, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREpathway;
		if (size)
			*size = sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREpathway);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREpathway[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREpathway);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREreactions_USCOREby_USCOREpathway*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREreactions_USCOREby_USCOREpathway(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREreactions_USCOREby_USCOREpathway %p -> %p\n", q, p));
	*(struct ns1__get_USCOREreactions_USCOREby_USCOREpathway*)p = *(struct ns1__get_USCOREreactions_USCOREby_USCOREpathway*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse);
	if (soap_out_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse, 0, sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse*)p = *(struct ns1__get_USCOREreactions_USCOREby_USCOREpathwayResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->pathway_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathway);
	if (soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathway), type);
	soap_out_std__string(soap, "pathway_id", -1, &a->pathway_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway * SOAP_FMAC4 soap_get_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway * SOAP_FMAC4 soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(struct soap *soap, const char *tag, struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway *a, const char *type)
{
	short soap_flag_pathway_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathway, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathway_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pathway_id", &a->pathway_USCOREid, "xsd:string"))
				{	soap_flag_pathway_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathway_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathway, 0, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway), 0, soap_copy_ns1__get_USCOREenzymes_USCOREby_USCOREpathway);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway * SOAP_FMAC6 soap_new_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathway, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway;
		if (size)
			*size = sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREenzymes_USCOREby_USCOREpathway(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway %p -> %p\n", q, p));
	*(struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway*)p = *(struct ns1__get_USCOREenzymes_USCOREby_USCOREpathway*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse);
	if (soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse, 0, sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse*)p = *(struct ns1__get_USCOREenzymes_USCOREby_USCOREpathwayResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->pathway_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREgenes_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREgenes_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREpathway *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathway);
	if (soap_out_ns1__get_USCOREgenes_USCOREby_USCOREpathway(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREgenes_USCOREby_USCOREpathway(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREgenes_USCOREby_USCOREpathway *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathway), type);
	soap_out_std__string(soap, "pathway_id", -1, &a->pathway_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREpathway * SOAP_FMAC4 soap_get_ns1__get_USCOREgenes_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREpathway *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREgenes_USCOREby_USCOREpathway(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREpathway * SOAP_FMAC4 soap_in_ns1__get_USCOREgenes_USCOREby_USCOREpathway(struct soap *soap, const char *tag, struct ns1__get_USCOREgenes_USCOREby_USCOREpathway *a, const char *type)
{
	short soap_flag_pathway_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREpathway *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathway, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREpathway), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREgenes_USCOREby_USCOREpathway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathway_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pathway_id", &a->pathway_USCOREid, "xsd:string"))
				{	soap_flag_pathway_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathway_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREpathway *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathway, 0, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREpathway), 0, soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREpathway);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREgenes_USCOREby_USCOREpathway * SOAP_FMAC6 soap_new_ns1__get_USCOREgenes_USCOREby_USCOREpathway(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREpathway(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREgenes_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREpathway *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREpathway * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREpathway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREpathway(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathway, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREpathway;
		if (size)
			*size = sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREpathway);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREpathway[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREpathway);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREgenes_USCOREby_USCOREpathway*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREpathway(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREgenes_USCOREby_USCOREpathway %p -> %p\n", q, p));
	*(struct ns1__get_USCOREgenes_USCOREby_USCOREpathway*)p = *(struct ns1__get_USCOREgenes_USCOREby_USCOREpathway*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse);
	if (soap_out_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse, 0, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse*)p = *(struct ns1__get_USCOREgenes_USCOREby_USCOREpathwayResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->pathway_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->pathway_USCOREid);
	soap_serialize_PointerToArrayOfstring(soap, &a->object_USCOREid_USCORElist);
	soap_serialize_PointerToArrayOfstring(soap, &a->fg_USCOREcolor_USCORElist);
	soap_serialize_PointerToArrayOfstring(soap, &a->bg_USCOREcolor_USCORElist);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->pathway_USCOREid);
	a->object_USCOREid_USCORElist = NULL;
	a->fg_USCOREcolor_USCORElist = NULL;
	a->bg_USCOREcolor_USCORElist = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects);
	if (soap_out_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects), type);
	soap_out_std__string(soap, "pathway_id", -1, &a->pathway_USCOREid, "");
	soap_out_PointerToArrayOfstring(soap, "object_id_list", -1, &a->object_USCOREid_USCORElist, "");
	soap_out_PointerToArrayOfstring(soap, "fg_color_list", -1, &a->fg_USCOREcolor_USCORElist, "");
	soap_out_PointerToArrayOfstring(soap, "bg_color_list", -1, &a->bg_USCOREcolor_USCORElist, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC4 soap_get_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC4 soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const char *tag, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects *a, const char *type)
{
	short soap_flag_pathway_USCOREid = 1, soap_flag_object_USCOREid_USCORElist = 1, soap_flag_fg_USCOREcolor_USCORElist = 1, soap_flag_bg_USCOREcolor_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects, sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathway_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pathway_id", &a->pathway_USCOREid, "xsd:string"))
				{	soap_flag_pathway_USCOREid--;
					continue;
				}
			if (soap_flag_object_USCOREid_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "object_id_list", &a->object_USCOREid_USCORElist, "xsd:string"))
				{	soap_flag_object_USCOREid_USCORElist--;
					continue;
				}
			if (soap_flag_fg_USCOREcolor_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "fg_color_list", &a->fg_USCOREcolor_USCORElist, "xsd:string"))
				{	soap_flag_fg_USCOREcolor_USCORElist--;
					continue;
				}
			if (soap_flag_bg_USCOREcolor_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "bg_color_list", &a->bg_USCOREcolor_USCORElist, "xsd:string"))
				{	soap_flag_bg_USCOREcolor_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathway_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects, 0, sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects), 0, soap_copy_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC6 soap_new_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects;
		if (size)
			*size = sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects %p -> %p\n", q, p));
	*(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects*)p = *(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjects*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse);
	if (soap_out_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse), type);
	soap_element_result(soap, "return");
	soap_out_std__string(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse, sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse, 0, sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse), 0, soap_copy_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse*)p = *(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREobjectsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->pathway_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->pathway_USCOREid);
	soap_serialize_PointerToArrayOfstring(soap, &a->object_USCOREid_USCORElist);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->pathway_USCOREid);
	a->object_USCOREid_USCORElist = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects);
	if (soap_out_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects), type);
	soap_out_std__string(soap, "pathway_id", -1, &a->pathway_USCOREid, "");
	soap_out_PointerToArrayOfstring(soap, "object_id_list", -1, &a->object_USCOREid_USCORElist, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC4 soap_get_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC4 soap_in_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const char *tag, struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects *a, const char *type)
{
	short soap_flag_pathway_USCOREid = 1, soap_flag_object_USCOREid_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects, sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathway_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pathway_id", &a->pathway_USCOREid, "xsd:string"))
				{	soap_flag_pathway_USCOREid--;
					continue;
				}
			if (soap_flag_object_USCOREid_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "object_id_list", &a->object_USCOREid_USCORElist, "xsd:string"))
				{	soap_flag_object_USCOREid_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathway_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects, 0, sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects), 0, soap_copy_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC6 soap_new_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects;
		if (size)
			*size = sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects %p -> %p\n", q, p));
	*(struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects*)p = *(struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjects*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse);
	if (soap_out_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse), type);
	soap_element_result(soap, "return");
	soap_out_std__string(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse, sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse, 0, sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse), 0, soap_copy_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse*)p = *(struct ns1__get_USCOREhtml_USCOREof_USCOREmarked_USCOREpathway_USCOREby_USCOREobjectsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__color_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const struct ns1__color_USCOREpathway_USCOREby_USCOREobjects *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->pathway_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->pathway_USCOREid);
	soap_serialize_PointerToArrayOfstring(soap, &a->object_USCOREid_USCORElist);
	soap_serialize_PointerToArrayOfstring(soap, &a->fg_USCOREcolor_USCORElist);
	soap_serialize_PointerToArrayOfstring(soap, &a->bg_USCOREcolor_USCORElist);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__color_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, struct ns1__color_USCOREpathway_USCOREby_USCOREobjects *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->pathway_USCOREid);
	a->object_USCOREid_USCORElist = NULL;
	a->fg_USCOREcolor_USCORElist = NULL;
	a->bg_USCOREcolor_USCORElist = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__color_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const struct ns1__color_USCOREpathway_USCOREby_USCOREobjects *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjects);
	if (soap_out_ns1__color_USCOREpathway_USCOREby_USCOREobjects(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__color_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const char *tag, int id, const struct ns1__color_USCOREpathway_USCOREby_USCOREobjects *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjects), type);
	soap_out_std__string(soap, "pathway_id", -1, &a->pathway_USCOREid, "");
	soap_out_PointerToArrayOfstring(soap, "object_id_list", -1, &a->object_USCOREid_USCORElist, "");
	soap_out_PointerToArrayOfstring(soap, "fg_color_list", -1, &a->fg_USCOREcolor_USCORElist, "");
	soap_out_PointerToArrayOfstring(soap, "bg_color_list", -1, &a->bg_USCOREcolor_USCORElist, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__color_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC4 soap_get_ns1__color_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, struct ns1__color_USCOREpathway_USCOREby_USCOREobjects *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__color_USCOREpathway_USCOREby_USCOREobjects(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__color_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC4 soap_in_ns1__color_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const char *tag, struct ns1__color_USCOREpathway_USCOREby_USCOREobjects *a, const char *type)
{
	short soap_flag_pathway_USCOREid = 1, soap_flag_object_USCOREid_USCORElist = 1, soap_flag_fg_USCOREcolor_USCORElist = 1, soap_flag_bg_USCOREcolor_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__color_USCOREpathway_USCOREby_USCOREobjects *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjects, sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREobjects), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__color_USCOREpathway_USCOREby_USCOREobjects(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathway_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pathway_id", &a->pathway_USCOREid, "xsd:string"))
				{	soap_flag_pathway_USCOREid--;
					continue;
				}
			if (soap_flag_object_USCOREid_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "object_id_list", &a->object_USCOREid_USCORElist, "xsd:string"))
				{	soap_flag_object_USCOREid_USCORElist--;
					continue;
				}
			if (soap_flag_fg_USCOREcolor_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "fg_color_list", &a->fg_USCOREcolor_USCORElist, "xsd:string"))
				{	soap_flag_fg_USCOREcolor_USCORElist--;
					continue;
				}
			if (soap_flag_bg_USCOREcolor_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "bg_color_list", &a->bg_USCOREcolor_USCORElist, "xsd:string"))
				{	soap_flag_bg_USCOREcolor_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathway_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__color_USCOREpathway_USCOREby_USCOREobjects *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjects, 0, sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREobjects), 0, soap_copy_ns1__color_USCOREpathway_USCOREby_USCOREobjects);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__color_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC6 soap_new_ns1__color_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, int n)
{	return soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREobjects(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__color_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, struct ns1__color_USCOREpathway_USCOREby_USCOREobjects *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__color_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC4 soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREobjects(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjects, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__color_USCOREpathway_USCOREby_USCOREobjects;
		if (size)
			*size = sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREobjects);
	}
	else
	{	cp->ptr = (void*)new struct ns1__color_USCOREpathway_USCOREby_USCOREobjects[n];
		if (size)
			*size = n * sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREobjects);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__color_USCOREpathway_USCOREby_USCOREobjects*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__color_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__color_USCOREpathway_USCOREby_USCOREobjects %p -> %p\n", q, p));
	*(struct ns1__color_USCOREpathway_USCOREby_USCOREobjects*)p = *(struct ns1__color_USCOREpathway_USCOREby_USCOREobjects*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse);
	if (soap_out_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const char *tag, int id, const struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse), type);
	soap_element_result(soap, "return");
	soap_out_std__string(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC4 soap_get_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC4 soap_in_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const char *tag, struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse, sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse, 0, sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse), 0, soap_copy_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC6 soap_new_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC4 soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse;
		if (size)
			*size = sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse %p -> %p\n", q, p));
	*(struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse*)p = *(struct ns1__color_USCOREpathway_USCOREby_USCOREobjectsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->pathway_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->pathway_USCOREid);
	soap_serialize_PointerToArrayOfstring(soap, &a->object_USCOREid_USCORElist);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->pathway_USCOREid);
	a->object_USCOREid_USCORElist = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjects);
	if (soap_out_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const char *tag, int id, const struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjects), type);
	soap_out_std__string(soap, "pathway_id", -1, &a->pathway_USCOREid, "");
	soap_out_PointerToArrayOfstring(soap, "object_id_list", -1, &a->object_USCOREid_USCORElist, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC4 soap_get_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC4 soap_in_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, const char *tag, struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects *a, const char *type)
{
	short soap_flag_pathway_USCOREid = 1, soap_flag_object_USCOREid_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjects, sizeof(struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathway_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pathway_id", &a->pathway_USCOREid, "xsd:string"))
				{	soap_flag_pathway_USCOREid--;
					continue;
				}
			if (soap_flag_object_USCOREid_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "object_id_list", &a->object_USCOREid_USCORElist, "xsd:string"))
				{	soap_flag_object_USCOREid_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathway_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjects, 0, sizeof(struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects), 0, soap_copy_ns1__mark_USCOREpathway_USCOREby_USCOREobjects);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC6 soap_new_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, int n)
{	return soap_instantiate_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects * SOAP_FMAC4 soap_instantiate_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjects, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects;
		if (size)
			*size = sizeof(struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects);
	}
	else
	{	cp->ptr = (void*)new struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects[n];
		if (size)
			*size = n * sizeof(struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__mark_USCOREpathway_USCOREby_USCOREobjects(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects %p -> %p\n", q, p));
	*(struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects*)p = *(struct ns1__mark_USCOREpathway_USCOREby_USCOREobjects*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse);
	if (soap_out_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const char *tag, int id, const struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse), type);
	soap_element_result(soap, "return");
	soap_out_std__string(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC4 soap_get_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC4 soap_in_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, const char *tag, struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse, sizeof(struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse, 0, sizeof(struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse), 0, soap_copy_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC6 soap_new_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse * SOAP_FMAC4 soap_instantiate_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse;
		if (size)
			*size = sizeof(struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse %p -> %p\n", q, p));
	*(struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse*)p = *(struct ns1__mark_USCOREpathway_USCOREby_USCOREobjectsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->pathway_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->pathway_USCOREid);
	soap_serialize_PointerToArrayOfint(soap, &a->element_USCORElist);
	soap_serialize_PointerToArrayOfstring(soap, &a->fg_USCOREcolor_USCORElist);
	soap_serialize_PointerToArrayOfstring(soap, &a->bg_USCOREcolor_USCORElist);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->pathway_USCOREid);
	a->element_USCORElist = NULL;
	a->fg_USCOREcolor_USCORElist = NULL;
	a->bg_USCOREcolor_USCORElist = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements);
	if (soap_out_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements), type);
	soap_out_std__string(soap, "pathway_id", -1, &a->pathway_USCOREid, "");
	soap_out_PointerToArrayOfint(soap, "element_list", -1, &a->element_USCORElist, "");
	soap_out_PointerToArrayOfstring(soap, "fg_color_list", -1, &a->fg_USCOREcolor_USCORElist, "");
	soap_out_PointerToArrayOfstring(soap, "bg_color_list", -1, &a->bg_USCOREcolor_USCORElist, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements * SOAP_FMAC4 soap_get_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements * SOAP_FMAC4 soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, const char *tag, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements *a, const char *type)
{
	short soap_flag_pathway_USCOREid = 1, soap_flag_element_USCORElist = 1, soap_flag_fg_USCOREcolor_USCORElist = 1, soap_flag_bg_USCOREcolor_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements, sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathway_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pathway_id", &a->pathway_USCOREid, "xsd:string"))
				{	soap_flag_pathway_USCOREid--;
					continue;
				}
			if (soap_flag_element_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfint(soap, "element_list", &a->element_USCORElist, "xsd:int"))
				{	soap_flag_element_USCORElist--;
					continue;
				}
			if (soap_flag_fg_USCOREcolor_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "fg_color_list", &a->fg_USCOREcolor_USCORElist, "xsd:string"))
				{	soap_flag_fg_USCOREcolor_USCORElist--;
					continue;
				}
			if (soap_flag_bg_USCOREcolor_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "bg_color_list", &a->bg_USCOREcolor_USCORElist, "xsd:string"))
				{	soap_flag_bg_USCOREcolor_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathway_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements, 0, sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements), 0, soap_copy_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements * SOAP_FMAC6 soap_new_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements;
		if (size)
			*size = sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements %p -> %p\n", q, p));
	*(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements*)p = *(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelements*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse);
	if (soap_out_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse), type);
	soap_element_result(soap, "return");
	soap_out_std__string(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse, sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse, 0, sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse), 0, soap_copy_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse*)p = *(struct ns1__get_USCOREhtml_USCOREof_USCOREcolored_USCOREpathway_USCOREby_USCOREelementsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__color_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, const struct ns1__color_USCOREpathway_USCOREby_USCOREelements *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->pathway_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->pathway_USCOREid);
	soap_serialize_PointerToArrayOfint(soap, &a->element_USCORElist);
	soap_serialize_PointerToArrayOfstring(soap, &a->fg_USCOREcolor_USCORElist);
	soap_serialize_PointerToArrayOfstring(soap, &a->bg_USCOREcolor_USCORElist);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__color_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, struct ns1__color_USCOREpathway_USCOREby_USCOREelements *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->pathway_USCOREid);
	a->element_USCORElist = NULL;
	a->fg_USCOREcolor_USCORElist = NULL;
	a->bg_USCOREcolor_USCORElist = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__color_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, const struct ns1__color_USCOREpathway_USCOREby_USCOREelements *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelements);
	if (soap_out_ns1__color_USCOREpathway_USCOREby_USCOREelements(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__color_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, const char *tag, int id, const struct ns1__color_USCOREpathway_USCOREby_USCOREelements *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelements), type);
	soap_out_std__string(soap, "pathway_id", -1, &a->pathway_USCOREid, "");
	soap_out_PointerToArrayOfint(soap, "element_list", -1, &a->element_USCORElist, "");
	soap_out_PointerToArrayOfstring(soap, "fg_color_list", -1, &a->fg_USCOREcolor_USCORElist, "");
	soap_out_PointerToArrayOfstring(soap, "bg_color_list", -1, &a->bg_USCOREcolor_USCORElist, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__color_USCOREpathway_USCOREby_USCOREelements * SOAP_FMAC4 soap_get_ns1__color_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, struct ns1__color_USCOREpathway_USCOREby_USCOREelements *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__color_USCOREpathway_USCOREby_USCOREelements(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__color_USCOREpathway_USCOREby_USCOREelements * SOAP_FMAC4 soap_in_ns1__color_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, const char *tag, struct ns1__color_USCOREpathway_USCOREby_USCOREelements *a, const char *type)
{
	short soap_flag_pathway_USCOREid = 1, soap_flag_element_USCORElist = 1, soap_flag_fg_USCOREcolor_USCORElist = 1, soap_flag_bg_USCOREcolor_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__color_USCOREpathway_USCOREby_USCOREelements *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelements, sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREelements), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__color_USCOREpathway_USCOREby_USCOREelements(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathway_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pathway_id", &a->pathway_USCOREid, "xsd:string"))
				{	soap_flag_pathway_USCOREid--;
					continue;
				}
			if (soap_flag_element_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfint(soap, "element_list", &a->element_USCORElist, "xsd:int"))
				{	soap_flag_element_USCORElist--;
					continue;
				}
			if (soap_flag_fg_USCOREcolor_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "fg_color_list", &a->fg_USCOREcolor_USCORElist, "xsd:string"))
				{	soap_flag_fg_USCOREcolor_USCORElist--;
					continue;
				}
			if (soap_flag_bg_USCOREcolor_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "bg_color_list", &a->bg_USCOREcolor_USCORElist, "xsd:string"))
				{	soap_flag_bg_USCOREcolor_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathway_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__color_USCOREpathway_USCOREby_USCOREelements *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelements, 0, sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREelements), 0, soap_copy_ns1__color_USCOREpathway_USCOREby_USCOREelements);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__color_USCOREpathway_USCOREby_USCOREelements * SOAP_FMAC6 soap_new_ns1__color_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, int n)
{	return soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREelements(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__color_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, struct ns1__color_USCOREpathway_USCOREby_USCOREelements *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__color_USCOREpathway_USCOREby_USCOREelements * SOAP_FMAC4 soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREelements(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelements, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__color_USCOREpathway_USCOREby_USCOREelements;
		if (size)
			*size = sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREelements);
	}
	else
	{	cp->ptr = (void*)new struct ns1__color_USCOREpathway_USCOREby_USCOREelements[n];
		if (size)
			*size = n * sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREelements);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__color_USCOREpathway_USCOREby_USCOREelements*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__color_USCOREpathway_USCOREby_USCOREelements(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__color_USCOREpathway_USCOREby_USCOREelements %p -> %p\n", q, p));
	*(struct ns1__color_USCOREpathway_USCOREby_USCOREelements*)p = *(struct ns1__color_USCOREpathway_USCOREby_USCOREelements*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, const struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, const struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse);
	if (soap_out_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, const char *tag, int id, const struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse), type);
	soap_element_result(soap, "return");
	soap_out_std__string(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse * SOAP_FMAC4 soap_get_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse * SOAP_FMAC4 soap_in_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, const char *tag, struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse, sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse, 0, sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse), 0, soap_copy_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse * SOAP_FMAC6 soap_new_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse * SOAP_FMAC4 soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse;
		if (size)
			*size = sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse %p -> %p\n", q, p));
	*(struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse*)p = *(struct ns1__color_USCOREpathway_USCOREby_USCOREelementsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->pathway_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway);
	if (soap_out_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway), type);
	soap_out_std__string(soap, "pathway_id", -1, &a->pathway_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway * SOAP_FMAC4 soap_get_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway * SOAP_FMAC4 soap_in_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(struct soap *soap, const char *tag, struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway *a, const char *type)
{
	short soap_flag_pathway_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway, sizeof(struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathway_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pathway_id", &a->pathway_USCOREid, "xsd:string"))
				{	soap_flag_pathway_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathway_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway, 0, sizeof(struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway), 0, soap_copy_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway * SOAP_FMAC6 soap_new_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway;
		if (size)
			*size = sizeof(struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway %p -> %p\n", q, p));
	*(struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway*)p = *(struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathway*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfPathwayElementRelation(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse);
	if (soap_out_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfPathwayElementRelation(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse, sizeof(struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfPathwayElementRelation(soap, "return", &a->return_, "ns1:PathwayElementRelation"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse, 0, sizeof(struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse*)p = *(struct ns1__get_USCOREelement_USCORErelations_USCOREby_USCOREpathwayResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREelements_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREelements_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->pathway_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREelements_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREelements_USCOREby_USCOREpathway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->pathway_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREelements_USCOREby_USCOREpathway(struct soap *soap, const struct ns1__get_USCOREelements_USCOREby_USCOREpathway *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathway);
	if (soap_out_ns1__get_USCOREelements_USCOREby_USCOREpathway(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREelements_USCOREby_USCOREpathway(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREelements_USCOREby_USCOREpathway *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathway), type);
	soap_out_std__string(soap, "pathway_id", -1, &a->pathway_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREelements_USCOREby_USCOREpathway * SOAP_FMAC4 soap_get_ns1__get_USCOREelements_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREelements_USCOREby_USCOREpathway *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREelements_USCOREby_USCOREpathway(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREelements_USCOREby_USCOREpathway * SOAP_FMAC4 soap_in_ns1__get_USCOREelements_USCOREby_USCOREpathway(struct soap *soap, const char *tag, struct ns1__get_USCOREelements_USCOREby_USCOREpathway *a, const char *type)
{
	short soap_flag_pathway_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREelements_USCOREby_USCOREpathway *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathway, sizeof(struct ns1__get_USCOREelements_USCOREby_USCOREpathway), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREelements_USCOREby_USCOREpathway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathway_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pathway_id", &a->pathway_USCOREid, "xsd:string"))
				{	soap_flag_pathway_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pathway_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREelements_USCOREby_USCOREpathway *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathway, 0, sizeof(struct ns1__get_USCOREelements_USCOREby_USCOREpathway), 0, soap_copy_ns1__get_USCOREelements_USCOREby_USCOREpathway);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREelements_USCOREby_USCOREpathway * SOAP_FMAC6 soap_new_ns1__get_USCOREelements_USCOREby_USCOREpathway(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREelements_USCOREby_USCOREpathway(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREelements_USCOREby_USCOREpathway(struct soap *soap, struct ns1__get_USCOREelements_USCOREby_USCOREpathway *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREelements_USCOREby_USCOREpathway * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREelements_USCOREby_USCOREpathway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREelements_USCOREby_USCOREpathway(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathway, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREelements_USCOREby_USCOREpathway;
		if (size)
			*size = sizeof(struct ns1__get_USCOREelements_USCOREby_USCOREpathway);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREelements_USCOREby_USCOREpathway[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREelements_USCOREby_USCOREpathway);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREelements_USCOREby_USCOREpathway*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREelements_USCOREby_USCOREpathway(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREelements_USCOREby_USCOREpathway %p -> %p\n", q, p));
	*(struct ns1__get_USCOREelements_USCOREby_USCOREpathway*)p = *(struct ns1__get_USCOREelements_USCOREby_USCOREpathway*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfPathwayElement(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(struct soap *soap, const struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse);
	if (soap_out_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfPathwayElement(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse, sizeof(struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfPathwayElement(soap, "return", &a->return_, "ns1:PathwayElement"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse, 0, sizeof(struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(struct soap *soap, struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse*)p = *(struct ns1__get_USCOREelements_USCOREby_USCOREpathwayResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->genes_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->genes_USCOREid);
	soap_embedded(soap, &a->start, SOAP_TYPE_int);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->genes_USCOREid);
	soap_default_int(soap, &a->start);
	soap_default_int(soap, &a->max_USCOREresults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene);
	if (soap_out_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene), type);
	soap_out_std__string(soap, "genes_id", -1, &a->genes_USCOREid, "");
	soap_out_int(soap, "start", -1, &a->start, "");
	soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene * SOAP_FMAC4 soap_get_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene * SOAP_FMAC4 soap_in_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, const char *tag, struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene *a, const char *type)
{
	short soap_flag_genes_USCOREid = 1, soap_flag_start = 1, soap_flag_max_USCOREresults = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene, sizeof(struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genes_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genes_id", &a->genes_USCOREid, "xsd:string"))
				{	soap_flag_genes_USCOREid--;
					continue;
				}
			if (soap_flag_start && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start", &a->start, "xsd:int"))
				{	soap_flag_start--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genes_USCOREid > 0 || soap_flag_start > 0 || soap_flag_max_USCOREresults > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene, 0, sizeof(struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene), 0, soap_copy_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene * SOAP_FMAC6 soap_new_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene;
		if (size)
			*size = sizeof(struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene %p -> %p\n", q, p));
	*(struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene*)p = *(struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse);
	if (soap_out_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse, sizeof(struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse, 0, sizeof(struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse*)p = *(struct ns1__get_USCOREpc_USCOREmembers_USCOREby_USCOREgeneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->genes_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->genes_USCOREid);
	soap_embedded(soap, &a->start, SOAP_TYPE_int);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->genes_USCOREid);
	soap_default_int(soap, &a->start);
	soap_default_int(soap, &a->max_USCOREresults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene);
	if (soap_out_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene), type);
	soap_out_std__string(soap, "genes_id", -1, &a->genes_USCOREid, "");
	soap_out_int(soap, "start", -1, &a->start, "");
	soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene * SOAP_FMAC4 soap_get_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene * SOAP_FMAC4 soap_in_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, const char *tag, struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene *a, const char *type)
{
	short soap_flag_genes_USCOREid = 1, soap_flag_start = 1, soap_flag_max_USCOREresults = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene, sizeof(struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genes_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genes_id", &a->genes_USCOREid, "xsd:string"))
				{	soap_flag_genes_USCOREid--;
					continue;
				}
			if (soap_flag_start && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start", &a->start, "xsd:int"))
				{	soap_flag_start--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genes_USCOREid > 0 || soap_flag_start > 0 || soap_flag_max_USCOREresults > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene, 0, sizeof(struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene), 0, soap_copy_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene * SOAP_FMAC6 soap_new_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene;
		if (size)
			*size = sizeof(struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene %p -> %p\n", q, p));
	*(struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene*)p = *(struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse);
	if (soap_out_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse, sizeof(struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse, 0, sizeof(struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse*)p = *(struct ns1__get_USCOREoc_USCOREmembers_USCOREby_USCOREgeneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->class_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->class_USCOREid);
	soap_embedded(soap, &a->org, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->org);
	soap_embedded(soap, &a->start, SOAP_TYPE_int);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->class_USCOREid);
	soap_default_std__string(soap, &a->org);
	soap_default_int(soap, &a->start);
	soap_default_int(soap, &a->max_USCOREresults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass);
	if (soap_out_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass), type);
	soap_out_std__string(soap, "class_id", -1, &a->class_USCOREid, "");
	soap_out_std__string(soap, "org", -1, &a->org, "");
	soap_out_int(soap, "start", -1, &a->start, "");
	soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass * SOAP_FMAC4 soap_get_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass * SOAP_FMAC4 soap_in_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(struct soap *soap, const char *tag, struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass *a, const char *type)
{
	short soap_flag_class_USCOREid = 1, soap_flag_org = 1, soap_flag_start = 1, soap_flag_max_USCOREresults = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_class_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "class_id", &a->class_USCOREid, "xsd:string"))
				{	soap_flag_class_USCOREid--;
					continue;
				}
			if (soap_flag_org && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "org", &a->org, "xsd:string"))
				{	soap_flag_org--;
					continue;
				}
			if (soap_flag_start && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start", &a->start, "xsd:int"))
				{	soap_flag_start--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_class_USCOREid > 0 || soap_flag_org > 0 || soap_flag_start > 0 || soap_flag_max_USCOREresults > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass, 0, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass), 0, soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass * SOAP_FMAC6 soap_new_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass;
		if (size)
			*size = sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass %p -> %p\n", q, p));
	*(struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass*)p = *(struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclass*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfDefinition(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse);
	if (soap_out_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfDefinition(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfDefinition(soap, "return", &a->return_, "ns1:Definition"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse, 0, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse*)p = *(struct ns1__get_USCOREgenes_USCOREby_USCOREko_USCOREclassResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREko(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREko *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ko_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->ko_USCOREid);
	soap_embedded(soap, &a->org, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->org);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREgenes_USCOREby_USCOREko(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREko *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->ko_USCOREid);
	soap_default_std__string(soap, &a->org);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREgenes_USCOREby_USCOREko(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREko *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko);
	if (soap_out_ns1__get_USCOREgenes_USCOREby_USCOREko(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREgenes_USCOREby_USCOREko(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREgenes_USCOREby_USCOREko *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko), type);
	soap_out_std__string(soap, "ko_id", -1, &a->ko_USCOREid, "");
	soap_out_std__string(soap, "org", -1, &a->org, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREko * SOAP_FMAC4 soap_get_ns1__get_USCOREgenes_USCOREby_USCOREko(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREko *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREgenes_USCOREby_USCOREko(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREko * SOAP_FMAC4 soap_in_ns1__get_USCOREgenes_USCOREby_USCOREko(struct soap *soap, const char *tag, struct ns1__get_USCOREgenes_USCOREby_USCOREko *a, const char *type)
{
	short soap_flag_ko_USCOREid = 1, soap_flag_org = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREko *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREko), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREgenes_USCOREby_USCOREko(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ko_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ko_id", &a->ko_USCOREid, "xsd:string"))
				{	soap_flag_ko_USCOREid--;
					continue;
				}
			if (soap_flag_org && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "org", &a->org, "xsd:string"))
				{	soap_flag_org--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ko_USCOREid > 0 || soap_flag_org > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREko *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko, 0, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREko), 0, soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREko);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREgenes_USCOREby_USCOREko * SOAP_FMAC6 soap_new_ns1__get_USCOREgenes_USCOREby_USCOREko(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREko(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREgenes_USCOREby_USCOREko(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREko *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREko * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREko(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREko(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREko, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREko;
		if (size)
			*size = sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREko);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREko[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREko);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREgenes_USCOREby_USCOREko*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREko(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREgenes_USCOREby_USCOREko %p -> %p\n", q, p));
	*(struct ns1__get_USCOREgenes_USCOREby_USCOREko*)p = *(struct ns1__get_USCOREgenes_USCOREby_USCOREko*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfDefinition(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse);
	if (soap_out_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfDefinition(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfDefinition(soap, "return", &a->return_, "ns1:Definition"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse, 0, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREkoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse*)p = *(struct ns1__get_USCOREgenes_USCOREby_USCOREkoResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(struct soap *soap, const struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->class_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->class_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(struct soap *soap, struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->class_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(struct soap *soap, const struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass);
	if (soap_out_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass), type);
	soap_out_std__string(soap, "class_id", -1, &a->class_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass * SOAP_FMAC4 soap_get_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(struct soap *soap, struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass * SOAP_FMAC4 soap_in_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(struct soap *soap, const char *tag, struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass *a, const char *type)
{
	short soap_flag_class_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass, sizeof(struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_class_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "class_id", &a->class_USCOREid, "xsd:string"))
				{	soap_flag_class_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_class_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass, 0, sizeof(struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass), 0, soap_copy_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass * SOAP_FMAC6 soap_new_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(struct soap *soap, struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass;
		if (size)
			*size = sizeof(struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass %p -> %p\n", q, p));
	*(struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass*)p = *(struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclass*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, const struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfDefinition(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, const struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse);
	if (soap_out_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfDefinition(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse, sizeof(struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfDefinition(soap, "return", &a->return_, "ns1:Definition"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse, 0, sizeof(struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse*)p = *(struct ns1__get_USCOREko_USCOREby_USCOREko_USCOREclassResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREko_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREko_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->genes_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->genes_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREko_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREko_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->genes_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREko_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREko_USCOREby_USCOREgene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgene);
	if (soap_out_ns1__get_USCOREko_USCOREby_USCOREgene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREko_USCOREby_USCOREgene(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREko_USCOREby_USCOREgene *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgene), type);
	soap_out_std__string(soap, "genes_id", -1, &a->genes_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREko_USCOREby_USCOREgene * SOAP_FMAC4 soap_get_ns1__get_USCOREko_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREko_USCOREby_USCOREgene *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREko_USCOREby_USCOREgene(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREko_USCOREby_USCOREgene * SOAP_FMAC4 soap_in_ns1__get_USCOREko_USCOREby_USCOREgene(struct soap *soap, const char *tag, struct ns1__get_USCOREko_USCOREby_USCOREgene *a, const char *type)
{
	short soap_flag_genes_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREko_USCOREby_USCOREgene *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgene, sizeof(struct ns1__get_USCOREko_USCOREby_USCOREgene), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREko_USCOREby_USCOREgene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genes_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genes_id", &a->genes_USCOREid, "xsd:string"))
				{	soap_flag_genes_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genes_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREko_USCOREby_USCOREgene *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgene, 0, sizeof(struct ns1__get_USCOREko_USCOREby_USCOREgene), 0, soap_copy_ns1__get_USCOREko_USCOREby_USCOREgene);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREko_USCOREby_USCOREgene * SOAP_FMAC6 soap_new_ns1__get_USCOREko_USCOREby_USCOREgene(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREgene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREko_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREko_USCOREby_USCOREgene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREko_USCOREby_USCOREgene * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREgene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREgene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREko_USCOREby_USCOREgene;
		if (size)
			*size = sizeof(struct ns1__get_USCOREko_USCOREby_USCOREgene);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREko_USCOREby_USCOREgene[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREko_USCOREby_USCOREgene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREko_USCOREby_USCOREgene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREko_USCOREby_USCOREgene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREko_USCOREby_USCOREgene %p -> %p\n", q, p));
	*(struct ns1__get_USCOREko_USCOREby_USCOREgene*)p = *(struct ns1__get_USCOREko_USCOREby_USCOREgene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgeneResponse);
	if (soap_out_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgeneResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfstring(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgeneResponse, sizeof(struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgeneResponse, 0, sizeof(struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREko_USCOREby_USCOREgeneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREko_USCOREby_USCOREgeneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse*)p = *(struct ns1__get_USCOREko_USCOREby_USCOREgeneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->motif_USCOREid_USCORElist);
	soap_embedded(soap, &a->start, SOAP_TYPE_int);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->motif_USCOREid_USCORElist = NULL;
	soap_default_int(soap, &a->start);
	soap_default_int(soap, &a->max_USCOREresults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifs);
	if (soap_out_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifs), type);
	soap_out_PointerToArrayOfstring(soap, "motif_id_list", -1, &a->motif_USCOREid_USCORElist, "");
	soap_out_int(soap, "start", -1, &a->start, "");
	soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs * SOAP_FMAC4 soap_get_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs * SOAP_FMAC4 soap_in_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(struct soap *soap, const char *tag, struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs *a, const char *type)
{
	short soap_flag_motif_USCOREid_USCORElist = 1, soap_flag_start = 1, soap_flag_max_USCOREresults = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifs, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_motif_USCOREid_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "motif_id_list", &a->motif_USCOREid_USCORElist, "xsd:string"))
				{	soap_flag_motif_USCOREid_USCORElist--;
					continue;
				}
			if (soap_flag_start && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start", &a->start, "xsd:int"))
				{	soap_flag_start--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_start > 0 || soap_flag_max_USCOREresults > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifs, 0, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs * SOAP_FMAC6 soap_new_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs;
		if (size)
			*size = sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREmotifs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs %p -> %p\n", q, p));
	*(struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs*)p = *(struct ns1__get_USCOREgenes_USCOREby_USCOREmotifs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfDefinition(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(struct soap *soap, const struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse);
	if (soap_out_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfDefinition(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfDefinition(soap, "return", &a->return_, "ns1:Definition"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse, 0, sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(struct soap *soap, struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse*)p = *(struct ns1__get_USCOREgenes_USCOREby_USCOREmotifsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmotifs_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREmotifs_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->genes_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->genes_USCOREid);
	soap_embedded(soap, &a->db, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->db);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmotifs_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREmotifs_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->genes_USCOREid);
	soap_default_std__string(soap, &a->db);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmotifs_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREmotifs_USCOREby_USCOREgene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgene);
	if (soap_out_ns1__get_USCOREmotifs_USCOREby_USCOREgene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmotifs_USCOREby_USCOREgene(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmotifs_USCOREby_USCOREgene *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgene), type);
	soap_out_std__string(soap, "genes_id", -1, &a->genes_USCOREid, "");
	soap_out_std__string(soap, "db", -1, &a->db, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREmotifs_USCOREby_USCOREgene * SOAP_FMAC4 soap_get_ns1__get_USCOREmotifs_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREmotifs_USCOREby_USCOREgene *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmotifs_USCOREby_USCOREgene(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmotifs_USCOREby_USCOREgene * SOAP_FMAC4 soap_in_ns1__get_USCOREmotifs_USCOREby_USCOREgene(struct soap *soap, const char *tag, struct ns1__get_USCOREmotifs_USCOREby_USCOREgene *a, const char *type)
{
	short soap_flag_genes_USCOREid = 1, soap_flag_db = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREmotifs_USCOREby_USCOREgene *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgene, sizeof(struct ns1__get_USCOREmotifs_USCOREby_USCOREgene), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmotifs_USCOREby_USCOREgene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genes_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genes_id", &a->genes_USCOREid, "xsd:string"))
				{	soap_flag_genes_USCOREid--;
					continue;
				}
			if (soap_flag_db && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "db", &a->db, "xsd:string"))
				{	soap_flag_db--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genes_USCOREid > 0 || soap_flag_db > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmotifs_USCOREby_USCOREgene *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgene, 0, sizeof(struct ns1__get_USCOREmotifs_USCOREby_USCOREgene), 0, soap_copy_ns1__get_USCOREmotifs_USCOREby_USCOREgene);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREmotifs_USCOREby_USCOREgene * SOAP_FMAC6 soap_new_ns1__get_USCOREmotifs_USCOREby_USCOREgene(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREmotifs_USCOREby_USCOREgene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREmotifs_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREmotifs_USCOREby_USCOREgene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREmotifs_USCOREby_USCOREgene * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREmotifs_USCOREby_USCOREgene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREmotifs_USCOREby_USCOREgene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREmotifs_USCOREby_USCOREgene;
		if (size)
			*size = sizeof(struct ns1__get_USCOREmotifs_USCOREby_USCOREgene);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREmotifs_USCOREby_USCOREgene[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREmotifs_USCOREby_USCOREgene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREmotifs_USCOREby_USCOREgene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREmotifs_USCOREby_USCOREgene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREmotifs_USCOREby_USCOREgene %p -> %p\n", q, p));
	*(struct ns1__get_USCOREmotifs_USCOREby_USCOREgene*)p = *(struct ns1__get_USCOREmotifs_USCOREby_USCOREgene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfMotifResult(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse);
	if (soap_out_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfMotifResult(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse, sizeof(struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfMotifResult(soap, "return", &a->return_, "ns1:MotifResult"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse, 0, sizeof(struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse*)p = *(struct ns1__get_USCOREmotifs_USCOREby_USCOREgeneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREparalogs_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREparalogs_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->genes_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->genes_USCOREid);
	soap_embedded(soap, &a->start, SOAP_TYPE_int);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREparalogs_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREparalogs_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->genes_USCOREid);
	soap_default_int(soap, &a->start);
	soap_default_int(soap, &a->max_USCOREresults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREparalogs_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREparalogs_USCOREby_USCOREgene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgene);
	if (soap_out_ns1__get_USCOREparalogs_USCOREby_USCOREgene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREparalogs_USCOREby_USCOREgene(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREparalogs_USCOREby_USCOREgene *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgene), type);
	soap_out_std__string(soap, "genes_id", -1, &a->genes_USCOREid, "");
	soap_out_int(soap, "start", -1, &a->start, "");
	soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREparalogs_USCOREby_USCOREgene * SOAP_FMAC4 soap_get_ns1__get_USCOREparalogs_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREparalogs_USCOREby_USCOREgene *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREparalogs_USCOREby_USCOREgene(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREparalogs_USCOREby_USCOREgene * SOAP_FMAC4 soap_in_ns1__get_USCOREparalogs_USCOREby_USCOREgene(struct soap *soap, const char *tag, struct ns1__get_USCOREparalogs_USCOREby_USCOREgene *a, const char *type)
{
	short soap_flag_genes_USCOREid = 1, soap_flag_start = 1, soap_flag_max_USCOREresults = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREparalogs_USCOREby_USCOREgene *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgene, sizeof(struct ns1__get_USCOREparalogs_USCOREby_USCOREgene), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREparalogs_USCOREby_USCOREgene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genes_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genes_id", &a->genes_USCOREid, "xsd:string"))
				{	soap_flag_genes_USCOREid--;
					continue;
				}
			if (soap_flag_start && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start", &a->start, "xsd:int"))
				{	soap_flag_start--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genes_USCOREid > 0 || soap_flag_start > 0 || soap_flag_max_USCOREresults > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREparalogs_USCOREby_USCOREgene *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgene, 0, sizeof(struct ns1__get_USCOREparalogs_USCOREby_USCOREgene), 0, soap_copy_ns1__get_USCOREparalogs_USCOREby_USCOREgene);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREparalogs_USCOREby_USCOREgene * SOAP_FMAC6 soap_new_ns1__get_USCOREparalogs_USCOREby_USCOREgene(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREparalogs_USCOREby_USCOREgene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREparalogs_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREparalogs_USCOREby_USCOREgene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREparalogs_USCOREby_USCOREgene * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREparalogs_USCOREby_USCOREgene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREparalogs_USCOREby_USCOREgene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREparalogs_USCOREby_USCOREgene;
		if (size)
			*size = sizeof(struct ns1__get_USCOREparalogs_USCOREby_USCOREgene);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREparalogs_USCOREby_USCOREgene[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREparalogs_USCOREby_USCOREgene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREparalogs_USCOREby_USCOREgene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREparalogs_USCOREby_USCOREgene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREparalogs_USCOREby_USCOREgene %p -> %p\n", q, p));
	*(struct ns1__get_USCOREparalogs_USCOREby_USCOREgene*)p = *(struct ns1__get_USCOREparalogs_USCOREby_USCOREgene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfSSDBRelation(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse);
	if (soap_out_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfSSDBRelation(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse, sizeof(struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfSSDBRelation(soap, "return", &a->return_, "ns1:SSDBRelation"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse, 0, sizeof(struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse*)p = *(struct ns1__get_USCOREparalogs_USCOREby_USCOREgeneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->genes_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->genes_USCOREid);
	soap_embedded(soap, &a->start, SOAP_TYPE_int);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->genes_USCOREid);
	soap_default_int(soap, &a->start);
	soap_default_int(soap, &a->max_USCOREresults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene);
	if (soap_out_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene), type);
	soap_out_std__string(soap, "genes_id", -1, &a->genes_USCOREid, "");
	soap_out_int(soap, "start", -1, &a->start, "");
	soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene * SOAP_FMAC4 soap_get_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene * SOAP_FMAC4 soap_in_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, const char *tag, struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *a, const char *type)
{
	short soap_flag_genes_USCOREid = 1, soap_flag_start = 1, soap_flag_max_USCOREresults = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene, sizeof(struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genes_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genes_id", &a->genes_USCOREid, "xsd:string"))
				{	soap_flag_genes_USCOREid--;
					continue;
				}
			if (soap_flag_start && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start", &a->start, "xsd:int"))
				{	soap_flag_start--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genes_USCOREid > 0 || soap_flag_start > 0 || soap_flag_max_USCOREresults > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene, 0, sizeof(struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene), 0, soap_copy_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene * SOAP_FMAC6 soap_new_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene;
		if (size)
			*size = sizeof(struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene %p -> %p\n", q, p));
	*(struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene*)p = *(struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfSSDBRelation(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse);
	if (soap_out_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfSSDBRelation(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse, sizeof(struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfSSDBRelation(soap, "return", &a->return_, "ns1:SSDBRelation"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse, 0, sizeof(struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse*)p = *(struct ns1__get_USCOREreverse_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->genes_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->genes_USCOREid);
	soap_embedded(soap, &a->start, SOAP_TYPE_int);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->genes_USCOREid);
	soap_default_int(soap, &a->start);
	soap_default_int(soap, &a->max_USCOREresults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene);
	if (soap_out_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene), type);
	soap_out_std__string(soap, "genes_id", -1, &a->genes_USCOREid, "");
	soap_out_int(soap, "start", -1, &a->start, "");
	soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene * SOAP_FMAC4 soap_get_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene * SOAP_FMAC4 soap_in_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, const char *tag, struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *a, const char *type)
{
	short soap_flag_genes_USCOREid = 1, soap_flag_start = 1, soap_flag_max_USCOREresults = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene, sizeof(struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genes_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genes_id", &a->genes_USCOREid, "xsd:string"))
				{	soap_flag_genes_USCOREid--;
					continue;
				}
			if (soap_flag_start && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start", &a->start, "xsd:int"))
				{	soap_flag_start--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genes_USCOREid > 0 || soap_flag_start > 0 || soap_flag_max_USCOREresults > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene, 0, sizeof(struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene), 0, soap_copy_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene * SOAP_FMAC6 soap_new_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene;
		if (size)
			*size = sizeof(struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene %p -> %p\n", q, p));
	*(struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene*)p = *(struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfSSDBRelation(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse);
	if (soap_out_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfSSDBRelation(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse, sizeof(struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfSSDBRelation(soap, "return", &a->return_, "ns1:SSDBRelation"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse, 0, sizeof(struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse*)p = *(struct ns1__get_USCOREbest_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->genes_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->genes_USCOREid);
	soap_embedded(soap, &a->start, SOAP_TYPE_int);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->genes_USCOREid);
	soap_default_int(soap, &a->start);
	soap_default_int(soap, &a->max_USCOREresults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, const struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene);
	if (soap_out_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene), type);
	soap_out_std__string(soap, "genes_id", -1, &a->genes_USCOREid, "");
	soap_out_int(soap, "start", -1, &a->start, "");
	soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene * SOAP_FMAC4 soap_get_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene * SOAP_FMAC4 soap_in_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, const char *tag, struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *a, const char *type)
{
	short soap_flag_genes_USCOREid = 1, soap_flag_start = 1, soap_flag_max_USCOREresults = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene, sizeof(struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genes_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genes_id", &a->genes_USCOREid, "xsd:string"))
				{	soap_flag_genes_USCOREid--;
					continue;
				}
			if (soap_flag_start && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start", &a->start, "xsd:int"))
				{	soap_flag_start--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genes_USCOREid > 0 || soap_flag_start > 0 || soap_flag_max_USCOREresults > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene, 0, sizeof(struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene), 0, soap_copy_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene * SOAP_FMAC6 soap_new_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene;
		if (size)
			*size = sizeof(struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene %p -> %p\n", q, p));
	*(struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene*)p = *(struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfSSDBRelation(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, const struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse);
	if (soap_out_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfSSDBRelation(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse, sizeof(struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfSSDBRelation(soap, "return", &a->return_, "ns1:SSDBRelation"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse, 0, sizeof(struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse * SOAP_FMAC6 soap_new_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse*)p = *(struct ns1__get_USCOREbest_USCOREneighbors_USCOREby_USCOREgeneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCORElinkdb_USCOREby_USCOREentry(struct soap *soap, const struct ns1__get_USCORElinkdb_USCOREby_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->entry_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->entry_USCOREid);
	soap_embedded(soap, &a->db, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->db);
	soap_embedded(soap, &a->start, SOAP_TYPE_int);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCORElinkdb_USCOREby_USCOREentry(struct soap *soap, struct ns1__get_USCORElinkdb_USCOREby_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->entry_USCOREid);
	soap_default_std__string(soap, &a->db);
	soap_default_int(soap, &a->start);
	soap_default_int(soap, &a->max_USCOREresults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCORElinkdb_USCOREby_USCOREentry(struct soap *soap, const struct ns1__get_USCORElinkdb_USCOREby_USCOREentry *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentry);
	if (soap_out_ns1__get_USCORElinkdb_USCOREby_USCOREentry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCORElinkdb_USCOREby_USCOREentry(struct soap *soap, const char *tag, int id, const struct ns1__get_USCORElinkdb_USCOREby_USCOREentry *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentry), type);
	soap_out_std__string(soap, "entry_id", -1, &a->entry_USCOREid, "");
	soap_out_std__string(soap, "db", -1, &a->db, "");
	soap_out_int(soap, "start", -1, &a->start, "");
	soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCORElinkdb_USCOREby_USCOREentry * SOAP_FMAC4 soap_get_ns1__get_USCORElinkdb_USCOREby_USCOREentry(struct soap *soap, struct ns1__get_USCORElinkdb_USCOREby_USCOREentry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCORElinkdb_USCOREby_USCOREentry(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCORElinkdb_USCOREby_USCOREentry * SOAP_FMAC4 soap_in_ns1__get_USCORElinkdb_USCOREby_USCOREentry(struct soap *soap, const char *tag, struct ns1__get_USCORElinkdb_USCOREby_USCOREentry *a, const char *type)
{
	short soap_flag_entry_USCOREid = 1, soap_flag_db = 1, soap_flag_start = 1, soap_flag_max_USCOREresults = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCORElinkdb_USCOREby_USCOREentry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentry, sizeof(struct ns1__get_USCORElinkdb_USCOREby_USCOREentry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCORElinkdb_USCOREby_USCOREentry(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entry_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "entry_id", &a->entry_USCOREid, "xsd:string"))
				{	soap_flag_entry_USCOREid--;
					continue;
				}
			if (soap_flag_db && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "db", &a->db, "xsd:string"))
				{	soap_flag_db--;
					continue;
				}
			if (soap_flag_start && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "start", &a->start, "xsd:int"))
				{	soap_flag_start--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entry_USCOREid > 0 || soap_flag_db > 0 || soap_flag_start > 0 || soap_flag_max_USCOREresults > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORElinkdb_USCOREby_USCOREentry *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentry, 0, sizeof(struct ns1__get_USCORElinkdb_USCOREby_USCOREentry), 0, soap_copy_ns1__get_USCORElinkdb_USCOREby_USCOREentry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCORElinkdb_USCOREby_USCOREentry * SOAP_FMAC6 soap_new_ns1__get_USCORElinkdb_USCOREby_USCOREentry(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCORElinkdb_USCOREby_USCOREentry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCORElinkdb_USCOREby_USCOREentry(struct soap *soap, struct ns1__get_USCORElinkdb_USCOREby_USCOREentry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCORElinkdb_USCOREby_USCOREentry * SOAP_FMAC4 soap_instantiate_ns1__get_USCORElinkdb_USCOREby_USCOREentry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCORElinkdb_USCOREby_USCOREentry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCORElinkdb_USCOREby_USCOREentry;
		if (size)
			*size = sizeof(struct ns1__get_USCORElinkdb_USCOREby_USCOREentry);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCORElinkdb_USCOREby_USCOREentry[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCORElinkdb_USCOREby_USCOREentry);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCORElinkdb_USCOREby_USCOREentry*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCORElinkdb_USCOREby_USCOREentry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCORElinkdb_USCOREby_USCOREentry %p -> %p\n", q, p));
	*(struct ns1__get_USCORElinkdb_USCOREby_USCOREentry*)p = *(struct ns1__get_USCORElinkdb_USCOREby_USCOREentry*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(struct soap *soap, const struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfLinkDBRelation(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(struct soap *soap, struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(struct soap *soap, const struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse);
	if (soap_out_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfLinkDBRelation(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse * SOAP_FMAC4 soap_get_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(struct soap *soap, struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse * SOAP_FMAC4 soap_in_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(struct soap *soap, const char *tag, struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse, sizeof(struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfLinkDBRelation(soap, "return", &a->return_, "ns1:LinkDBRelation"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse, 0, sizeof(struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse * SOAP_FMAC6 soap_new_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(struct soap *soap, struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse * SOAP_FMAC4 soap_instantiate_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse;
		if (size)
			*size = sizeof(struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse %p -> %p\n", q, p));
	*(struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse*)p = *(struct ns1__get_USCORElinkdb_USCOREby_USCOREentryResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__bconv(struct soap *soap, const struct ns1__bconv *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->string, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->string);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__bconv(struct soap *soap, struct ns1__bconv *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__bconv(struct soap *soap, const struct ns1__bconv *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__bconv);
	if (soap_out_ns1__bconv(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__bconv(struct soap *soap, const char *tag, int id, const struct ns1__bconv *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__bconv), type);
	soap_out_std__string(soap, "string", -1, &a->string, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__bconv * SOAP_FMAC4 soap_get_ns1__bconv(struct soap *soap, struct ns1__bconv *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__bconv(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__bconv * SOAP_FMAC4 soap_in_ns1__bconv(struct soap *soap, const char *tag, struct ns1__bconv *a, const char *type)
{
	short soap_flag_string = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__bconv *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__bconv, sizeof(struct ns1__bconv), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__bconv(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_string && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "string", &a->string, "xsd:string"))
				{	soap_flag_string--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_string > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__bconv *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__bconv, 0, sizeof(struct ns1__bconv), 0, soap_copy_ns1__bconv);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__bconv * SOAP_FMAC6 soap_new_ns1__bconv(struct soap *soap, int n)
{	return soap_instantiate_ns1__bconv(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__bconv(struct soap *soap, struct ns1__bconv *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__bconv * SOAP_FMAC4 soap_instantiate_ns1__bconv(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__bconv(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__bconv, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__bconv;
		if (size)
			*size = sizeof(struct ns1__bconv);
	}
	else
	{	cp->ptr = (void*)new struct ns1__bconv[n];
		if (size)
			*size = n * sizeof(struct ns1__bconv);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__bconv*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__bconv(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__bconv %p -> %p\n", q, p));
	*(struct ns1__bconv*)p = *(struct ns1__bconv*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__bconvResponse(struct soap *soap, const struct ns1__bconvResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__bconvResponse(struct soap *soap, struct ns1__bconvResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__bconvResponse(struct soap *soap, const struct ns1__bconvResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__bconvResponse);
	if (soap_out_ns1__bconvResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__bconvResponse(struct soap *soap, const char *tag, int id, const struct ns1__bconvResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__bconvResponse), type);
	soap_element_result(soap, "return");
	soap_out_std__string(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__bconvResponse * SOAP_FMAC4 soap_get_ns1__bconvResponse(struct soap *soap, struct ns1__bconvResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__bconvResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__bconvResponse * SOAP_FMAC4 soap_in_ns1__bconvResponse(struct soap *soap, const char *tag, struct ns1__bconvResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__bconvResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__bconvResponse, sizeof(struct ns1__bconvResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__bconvResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__bconvResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__bconvResponse, 0, sizeof(struct ns1__bconvResponse), 0, soap_copy_ns1__bconvResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__bconvResponse * SOAP_FMAC6 soap_new_ns1__bconvResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__bconvResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__bconvResponse(struct soap *soap, struct ns1__bconvResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__bconvResponse * SOAP_FMAC4 soap_instantiate_ns1__bconvResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__bconvResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__bconvResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__bconvResponse;
		if (size)
			*size = sizeof(struct ns1__bconvResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__bconvResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__bconvResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__bconvResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__bconvResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__bconvResponse %p -> %p\n", q, p));
	*(struct ns1__bconvResponse*)p = *(struct ns1__bconvResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__btit(struct soap *soap, const struct ns1__btit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->string, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->string);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__btit(struct soap *soap, struct ns1__btit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__btit(struct soap *soap, const struct ns1__btit *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__btit);
	if (soap_out_ns1__btit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__btit(struct soap *soap, const char *tag, int id, const struct ns1__btit *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__btit), type);
	soap_out_std__string(soap, "string", -1, &a->string, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__btit * SOAP_FMAC4 soap_get_ns1__btit(struct soap *soap, struct ns1__btit *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__btit(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__btit * SOAP_FMAC4 soap_in_ns1__btit(struct soap *soap, const char *tag, struct ns1__btit *a, const char *type)
{
	short soap_flag_string = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__btit *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__btit, sizeof(struct ns1__btit), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__btit(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_string && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "string", &a->string, "xsd:string"))
				{	soap_flag_string--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_string > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__btit *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__btit, 0, sizeof(struct ns1__btit), 0, soap_copy_ns1__btit);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__btit * SOAP_FMAC6 soap_new_ns1__btit(struct soap *soap, int n)
{	return soap_instantiate_ns1__btit(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__btit(struct soap *soap, struct ns1__btit *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__btit * SOAP_FMAC4 soap_instantiate_ns1__btit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__btit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__btit, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__btit;
		if (size)
			*size = sizeof(struct ns1__btit);
	}
	else
	{	cp->ptr = (void*)new struct ns1__btit[n];
		if (size)
			*size = n * sizeof(struct ns1__btit);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__btit*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__btit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__btit %p -> %p\n", q, p));
	*(struct ns1__btit*)p = *(struct ns1__btit*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__btitResponse(struct soap *soap, const struct ns1__btitResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__btitResponse(struct soap *soap, struct ns1__btitResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__btitResponse(struct soap *soap, const struct ns1__btitResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__btitResponse);
	if (soap_out_ns1__btitResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__btitResponse(struct soap *soap, const char *tag, int id, const struct ns1__btitResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__btitResponse), type);
	soap_element_result(soap, "return");
	soap_out_std__string(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__btitResponse * SOAP_FMAC4 soap_get_ns1__btitResponse(struct soap *soap, struct ns1__btitResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__btitResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__btitResponse * SOAP_FMAC4 soap_in_ns1__btitResponse(struct soap *soap, const char *tag, struct ns1__btitResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__btitResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__btitResponse, sizeof(struct ns1__btitResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__btitResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__btitResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__btitResponse, 0, sizeof(struct ns1__btitResponse), 0, soap_copy_ns1__btitResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__btitResponse * SOAP_FMAC6 soap_new_ns1__btitResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__btitResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__btitResponse(struct soap *soap, struct ns1__btitResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__btitResponse * SOAP_FMAC4 soap_instantiate_ns1__btitResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__btitResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__btitResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__btitResponse;
		if (size)
			*size = sizeof(struct ns1__btitResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__btitResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__btitResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__btitResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__btitResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__btitResponse %p -> %p\n", q, p));
	*(struct ns1__btitResponse*)p = *(struct ns1__btitResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__bfind(struct soap *soap, const struct ns1__bfind *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->string, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->string);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__bfind(struct soap *soap, struct ns1__bfind *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__bfind(struct soap *soap, const struct ns1__bfind *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__bfind);
	if (soap_out_ns1__bfind(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__bfind(struct soap *soap, const char *tag, int id, const struct ns1__bfind *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__bfind), type);
	soap_out_std__string(soap, "string", -1, &a->string, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__bfind * SOAP_FMAC4 soap_get_ns1__bfind(struct soap *soap, struct ns1__bfind *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__bfind(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__bfind * SOAP_FMAC4 soap_in_ns1__bfind(struct soap *soap, const char *tag, struct ns1__bfind *a, const char *type)
{
	short soap_flag_string = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__bfind *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__bfind, sizeof(struct ns1__bfind), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__bfind(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_string && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "string", &a->string, "xsd:string"))
				{	soap_flag_string--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_string > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__bfind *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__bfind, 0, sizeof(struct ns1__bfind), 0, soap_copy_ns1__bfind);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__bfind * SOAP_FMAC6 soap_new_ns1__bfind(struct soap *soap, int n)
{	return soap_instantiate_ns1__bfind(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__bfind(struct soap *soap, struct ns1__bfind *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__bfind * SOAP_FMAC4 soap_instantiate_ns1__bfind(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__bfind(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__bfind, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__bfind;
		if (size)
			*size = sizeof(struct ns1__bfind);
	}
	else
	{	cp->ptr = (void*)new struct ns1__bfind[n];
		if (size)
			*size = n * sizeof(struct ns1__bfind);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__bfind*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__bfind(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__bfind %p -> %p\n", q, p));
	*(struct ns1__bfind*)p = *(struct ns1__bfind*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__bfindResponse(struct soap *soap, const struct ns1__bfindResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__bfindResponse(struct soap *soap, struct ns1__bfindResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__bfindResponse(struct soap *soap, const struct ns1__bfindResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__bfindResponse);
	if (soap_out_ns1__bfindResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__bfindResponse(struct soap *soap, const char *tag, int id, const struct ns1__bfindResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__bfindResponse), type);
	soap_element_result(soap, "return");
	soap_out_std__string(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__bfindResponse * SOAP_FMAC4 soap_get_ns1__bfindResponse(struct soap *soap, struct ns1__bfindResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__bfindResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__bfindResponse * SOAP_FMAC4 soap_in_ns1__bfindResponse(struct soap *soap, const char *tag, struct ns1__bfindResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__bfindResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__bfindResponse, sizeof(struct ns1__bfindResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__bfindResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__bfindResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__bfindResponse, 0, sizeof(struct ns1__bfindResponse), 0, soap_copy_ns1__bfindResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__bfindResponse * SOAP_FMAC6 soap_new_ns1__bfindResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__bfindResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__bfindResponse(struct soap *soap, struct ns1__bfindResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__bfindResponse * SOAP_FMAC4 soap_instantiate_ns1__bfindResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__bfindResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__bfindResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__bfindResponse;
		if (size)
			*size = sizeof(struct ns1__bfindResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__bfindResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__bfindResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__bfindResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__bfindResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__bfindResponse %p -> %p\n", q, p));
	*(struct ns1__bfindResponse*)p = *(struct ns1__bfindResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__bget(struct soap *soap, const struct ns1__bget *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->string, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->string);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__bget(struct soap *soap, struct ns1__bget *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__bget(struct soap *soap, const struct ns1__bget *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__bget);
	if (soap_out_ns1__bget(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__bget(struct soap *soap, const char *tag, int id, const struct ns1__bget *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__bget), type);
	soap_out_std__string(soap, "string", -1, &a->string, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__bget * SOAP_FMAC4 soap_get_ns1__bget(struct soap *soap, struct ns1__bget *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__bget(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__bget * SOAP_FMAC4 soap_in_ns1__bget(struct soap *soap, const char *tag, struct ns1__bget *a, const char *type)
{
	short soap_flag_string = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__bget *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__bget, sizeof(struct ns1__bget), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__bget(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_string && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "string", &a->string, "xsd:string"))
				{	soap_flag_string--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_string > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__bget *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__bget, 0, sizeof(struct ns1__bget), 0, soap_copy_ns1__bget);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__bget * SOAP_FMAC6 soap_new_ns1__bget(struct soap *soap, int n)
{	return soap_instantiate_ns1__bget(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__bget(struct soap *soap, struct ns1__bget *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__bget * SOAP_FMAC4 soap_instantiate_ns1__bget(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__bget(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__bget, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__bget;
		if (size)
			*size = sizeof(struct ns1__bget);
	}
	else
	{	cp->ptr = (void*)new struct ns1__bget[n];
		if (size)
			*size = n * sizeof(struct ns1__bget);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__bget*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__bget(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__bget %p -> %p\n", q, p));
	*(struct ns1__bget*)p = *(struct ns1__bget*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__bgetResponse(struct soap *soap, const struct ns1__bgetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__bgetResponse(struct soap *soap, struct ns1__bgetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__bgetResponse(struct soap *soap, const struct ns1__bgetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__bgetResponse);
	if (soap_out_ns1__bgetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__bgetResponse(struct soap *soap, const char *tag, int id, const struct ns1__bgetResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__bgetResponse), type);
	soap_element_result(soap, "return");
	soap_out_std__string(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__bgetResponse * SOAP_FMAC4 soap_get_ns1__bgetResponse(struct soap *soap, struct ns1__bgetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__bgetResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__bgetResponse * SOAP_FMAC4 soap_in_ns1__bgetResponse(struct soap *soap, const char *tag, struct ns1__bgetResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__bgetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__bgetResponse, sizeof(struct ns1__bgetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__bgetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__bgetResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__bgetResponse, 0, sizeof(struct ns1__bgetResponse), 0, soap_copy_ns1__bgetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__bgetResponse * SOAP_FMAC6 soap_new_ns1__bgetResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__bgetResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__bgetResponse(struct soap *soap, struct ns1__bgetResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__bgetResponse * SOAP_FMAC4 soap_instantiate_ns1__bgetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__bgetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__bgetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__bgetResponse;
		if (size)
			*size = sizeof(struct ns1__bgetResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__bgetResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__bgetResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__bgetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__bgetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__bgetResponse %p -> %p\n", q, p));
	*(struct ns1__bgetResponse*)p = *(struct ns1__bgetResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__binfo(struct soap *soap, const struct ns1__binfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->db, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->db);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__binfo(struct soap *soap, struct ns1__binfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->db);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__binfo(struct soap *soap, const struct ns1__binfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__binfo);
	if (soap_out_ns1__binfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__binfo(struct soap *soap, const char *tag, int id, const struct ns1__binfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__binfo), type);
	soap_out_std__string(soap, "db", -1, &a->db, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__binfo * SOAP_FMAC4 soap_get_ns1__binfo(struct soap *soap, struct ns1__binfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__binfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__binfo * SOAP_FMAC4 soap_in_ns1__binfo(struct soap *soap, const char *tag, struct ns1__binfo *a, const char *type)
{
	short soap_flag_db = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__binfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__binfo, sizeof(struct ns1__binfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__binfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_db && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "db", &a->db, "xsd:string"))
				{	soap_flag_db--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_db > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__binfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__binfo, 0, sizeof(struct ns1__binfo), 0, soap_copy_ns1__binfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__binfo * SOAP_FMAC6 soap_new_ns1__binfo(struct soap *soap, int n)
{	return soap_instantiate_ns1__binfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__binfo(struct soap *soap, struct ns1__binfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__binfo * SOAP_FMAC4 soap_instantiate_ns1__binfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__binfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__binfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__binfo;
		if (size)
			*size = sizeof(struct ns1__binfo);
	}
	else
	{	cp->ptr = (void*)new struct ns1__binfo[n];
		if (size)
			*size = n * sizeof(struct ns1__binfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__binfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__binfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__binfo %p -> %p\n", q, p));
	*(struct ns1__binfo*)p = *(struct ns1__binfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__binfoResponse(struct soap *soap, const struct ns1__binfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__binfoResponse(struct soap *soap, struct ns1__binfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__binfoResponse(struct soap *soap, const struct ns1__binfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__binfoResponse);
	if (soap_out_ns1__binfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__binfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__binfoResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__binfoResponse), type);
	soap_element_result(soap, "return");
	soap_out_std__string(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__binfoResponse * SOAP_FMAC4 soap_get_ns1__binfoResponse(struct soap *soap, struct ns1__binfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__binfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__binfoResponse * SOAP_FMAC4 soap_in_ns1__binfoResponse(struct soap *soap, const char *tag, struct ns1__binfoResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__binfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__binfoResponse, sizeof(struct ns1__binfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__binfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__binfoResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__binfoResponse, 0, sizeof(struct ns1__binfoResponse), 0, soap_copy_ns1__binfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__binfoResponse * SOAP_FMAC6 soap_new_ns1__binfoResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__binfoResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__binfoResponse(struct soap *soap, struct ns1__binfoResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__binfoResponse * SOAP_FMAC4 soap_instantiate_ns1__binfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__binfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__binfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__binfoResponse;
		if (size)
			*size = sizeof(struct ns1__binfoResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__binfoResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__binfoResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__binfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__binfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__binfoResponse %p -> %p\n", q, p));
	*(struct ns1__binfoResponse*)p = *(struct ns1__binfoResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__list_USCOREko_USCOREclasses(struct soap *soap, const struct ns1__list_USCOREko_USCOREclasses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->class_USCOREid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->class_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__list_USCOREko_USCOREclasses(struct soap *soap, struct ns1__list_USCOREko_USCOREclasses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->class_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__list_USCOREko_USCOREclasses(struct soap *soap, const struct ns1__list_USCOREko_USCOREclasses *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__list_USCOREko_USCOREclasses);
	if (soap_out_ns1__list_USCOREko_USCOREclasses(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__list_USCOREko_USCOREclasses(struct soap *soap, const char *tag, int id, const struct ns1__list_USCOREko_USCOREclasses *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__list_USCOREko_USCOREclasses), type);
	soap_out_std__string(soap, "class_id", -1, &a->class_USCOREid, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__list_USCOREko_USCOREclasses * SOAP_FMAC4 soap_get_ns1__list_USCOREko_USCOREclasses(struct soap *soap, struct ns1__list_USCOREko_USCOREclasses *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__list_USCOREko_USCOREclasses(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__list_USCOREko_USCOREclasses * SOAP_FMAC4 soap_in_ns1__list_USCOREko_USCOREclasses(struct soap *soap, const char *tag, struct ns1__list_USCOREko_USCOREclasses *a, const char *type)
{
	short soap_flag_class_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__list_USCOREko_USCOREclasses *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__list_USCOREko_USCOREclasses, sizeof(struct ns1__list_USCOREko_USCOREclasses), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__list_USCOREko_USCOREclasses(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_class_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "class_id", &a->class_USCOREid, "xsd:string"))
				{	soap_flag_class_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_class_USCOREid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__list_USCOREko_USCOREclasses *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__list_USCOREko_USCOREclasses, 0, sizeof(struct ns1__list_USCOREko_USCOREclasses), 0, soap_copy_ns1__list_USCOREko_USCOREclasses);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__list_USCOREko_USCOREclasses * SOAP_FMAC6 soap_new_ns1__list_USCOREko_USCOREclasses(struct soap *soap, int n)
{	return soap_instantiate_ns1__list_USCOREko_USCOREclasses(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__list_USCOREko_USCOREclasses(struct soap *soap, struct ns1__list_USCOREko_USCOREclasses *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__list_USCOREko_USCOREclasses * SOAP_FMAC4 soap_instantiate_ns1__list_USCOREko_USCOREclasses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__list_USCOREko_USCOREclasses(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__list_USCOREko_USCOREclasses, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__list_USCOREko_USCOREclasses;
		if (size)
			*size = sizeof(struct ns1__list_USCOREko_USCOREclasses);
	}
	else
	{	cp->ptr = (void*)new struct ns1__list_USCOREko_USCOREclasses[n];
		if (size)
			*size = n * sizeof(struct ns1__list_USCOREko_USCOREclasses);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__list_USCOREko_USCOREclasses*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__list_USCOREko_USCOREclasses(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__list_USCOREko_USCOREclasses %p -> %p\n", q, p));
	*(struct ns1__list_USCOREko_USCOREclasses*)p = *(struct ns1__list_USCOREko_USCOREclasses*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__list_USCOREko_USCOREclassesResponse(struct soap *soap, const struct ns1__list_USCOREko_USCOREclassesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfDefinition(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__list_USCOREko_USCOREclassesResponse(struct soap *soap, struct ns1__list_USCOREko_USCOREclassesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__list_USCOREko_USCOREclassesResponse(struct soap *soap, const struct ns1__list_USCOREko_USCOREclassesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__list_USCOREko_USCOREclassesResponse);
	if (soap_out_ns1__list_USCOREko_USCOREclassesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__list_USCOREko_USCOREclassesResponse(struct soap *soap, const char *tag, int id, const struct ns1__list_USCOREko_USCOREclassesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__list_USCOREko_USCOREclassesResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfDefinition(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__list_USCOREko_USCOREclassesResponse * SOAP_FMAC4 soap_get_ns1__list_USCOREko_USCOREclassesResponse(struct soap *soap, struct ns1__list_USCOREko_USCOREclassesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__list_USCOREko_USCOREclassesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__list_USCOREko_USCOREclassesResponse * SOAP_FMAC4 soap_in_ns1__list_USCOREko_USCOREclassesResponse(struct soap *soap, const char *tag, struct ns1__list_USCOREko_USCOREclassesResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__list_USCOREko_USCOREclassesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__list_USCOREko_USCOREclassesResponse, sizeof(struct ns1__list_USCOREko_USCOREclassesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__list_USCOREko_USCOREclassesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfDefinition(soap, "return", &a->return_, "ns1:Definition"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__list_USCOREko_USCOREclassesResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__list_USCOREko_USCOREclassesResponse, 0, sizeof(struct ns1__list_USCOREko_USCOREclassesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__list_USCOREko_USCOREclassesResponse * SOAP_FMAC6 soap_new_ns1__list_USCOREko_USCOREclassesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__list_USCOREko_USCOREclassesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__list_USCOREko_USCOREclassesResponse(struct soap *soap, struct ns1__list_USCOREko_USCOREclassesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__list_USCOREko_USCOREclassesResponse * SOAP_FMAC4 soap_instantiate_ns1__list_USCOREko_USCOREclassesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__list_USCOREko_USCOREclassesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__list_USCOREko_USCOREclassesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__list_USCOREko_USCOREclassesResponse;
		if (size)
			*size = sizeof(struct ns1__list_USCOREko_USCOREclassesResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__list_USCOREko_USCOREclassesResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__list_USCOREko_USCOREclassesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__list_USCOREko_USCOREclassesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__list_USCOREko_USCOREclassesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__list_USCOREko_USCOREclassesResponse %p -> %p\n", q, p));
	*(struct ns1__list_USCOREko_USCOREclassesResponse*)p = *(struct ns1__list_USCOREko_USCOREclassesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__list_USCOREpathways(struct soap *soap, const struct ns1__list_USCOREpathways *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->org, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->org);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__list_USCOREpathways(struct soap *soap, struct ns1__list_USCOREpathways *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->org);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__list_USCOREpathways(struct soap *soap, const struct ns1__list_USCOREpathways *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__list_USCOREpathways);
	if (soap_out_ns1__list_USCOREpathways(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__list_USCOREpathways(struct soap *soap, const char *tag, int id, const struct ns1__list_USCOREpathways *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__list_USCOREpathways), type);
	soap_out_std__string(soap, "org", -1, &a->org, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__list_USCOREpathways * SOAP_FMAC4 soap_get_ns1__list_USCOREpathways(struct soap *soap, struct ns1__list_USCOREpathways *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__list_USCOREpathways(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__list_USCOREpathways * SOAP_FMAC4 soap_in_ns1__list_USCOREpathways(struct soap *soap, const char *tag, struct ns1__list_USCOREpathways *a, const char *type)
{
	short soap_flag_org = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__list_USCOREpathways *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__list_USCOREpathways, sizeof(struct ns1__list_USCOREpathways), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__list_USCOREpathways(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_org && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "org", &a->org, "xsd:string"))
				{	soap_flag_org--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_org > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__list_USCOREpathways *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__list_USCOREpathways, 0, sizeof(struct ns1__list_USCOREpathways), 0, soap_copy_ns1__list_USCOREpathways);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__list_USCOREpathways * SOAP_FMAC6 soap_new_ns1__list_USCOREpathways(struct soap *soap, int n)
{	return soap_instantiate_ns1__list_USCOREpathways(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__list_USCOREpathways(struct soap *soap, struct ns1__list_USCOREpathways *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__list_USCOREpathways * SOAP_FMAC4 soap_instantiate_ns1__list_USCOREpathways(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__list_USCOREpathways(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__list_USCOREpathways, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__list_USCOREpathways;
		if (size)
			*size = sizeof(struct ns1__list_USCOREpathways);
	}
	else
	{	cp->ptr = (void*)new struct ns1__list_USCOREpathways[n];
		if (size)
			*size = n * sizeof(struct ns1__list_USCOREpathways);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__list_USCOREpathways*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__list_USCOREpathways(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__list_USCOREpathways %p -> %p\n", q, p));
	*(struct ns1__list_USCOREpathways*)p = *(struct ns1__list_USCOREpathways*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__list_USCOREpathwaysResponse(struct soap *soap, const struct ns1__list_USCOREpathwaysResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfDefinition(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__list_USCOREpathwaysResponse(struct soap *soap, struct ns1__list_USCOREpathwaysResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__list_USCOREpathwaysResponse(struct soap *soap, const struct ns1__list_USCOREpathwaysResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__list_USCOREpathwaysResponse);
	if (soap_out_ns1__list_USCOREpathwaysResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__list_USCOREpathwaysResponse(struct soap *soap, const char *tag, int id, const struct ns1__list_USCOREpathwaysResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__list_USCOREpathwaysResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfDefinition(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__list_USCOREpathwaysResponse * SOAP_FMAC4 soap_get_ns1__list_USCOREpathwaysResponse(struct soap *soap, struct ns1__list_USCOREpathwaysResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__list_USCOREpathwaysResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__list_USCOREpathwaysResponse * SOAP_FMAC4 soap_in_ns1__list_USCOREpathwaysResponse(struct soap *soap, const char *tag, struct ns1__list_USCOREpathwaysResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__list_USCOREpathwaysResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__list_USCOREpathwaysResponse, sizeof(struct ns1__list_USCOREpathwaysResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__list_USCOREpathwaysResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfDefinition(soap, "return", &a->return_, "ns1:Definition"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__list_USCOREpathwaysResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__list_USCOREpathwaysResponse, 0, sizeof(struct ns1__list_USCOREpathwaysResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__list_USCOREpathwaysResponse * SOAP_FMAC6 soap_new_ns1__list_USCOREpathwaysResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__list_USCOREpathwaysResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__list_USCOREpathwaysResponse(struct soap *soap, struct ns1__list_USCOREpathwaysResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__list_USCOREpathwaysResponse * SOAP_FMAC4 soap_instantiate_ns1__list_USCOREpathwaysResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__list_USCOREpathwaysResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__list_USCOREpathwaysResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__list_USCOREpathwaysResponse;
		if (size)
			*size = sizeof(struct ns1__list_USCOREpathwaysResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__list_USCOREpathwaysResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__list_USCOREpathwaysResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__list_USCOREpathwaysResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__list_USCOREpathwaysResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__list_USCOREpathwaysResponse %p -> %p\n", q, p));
	*(struct ns1__list_USCOREpathwaysResponse*)p = *(struct ns1__list_USCOREpathwaysResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__list_USCOREorganisms(struct soap *soap, const struct ns1__list_USCOREorganisms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__list_USCOREorganisms(struct soap *soap, struct ns1__list_USCOREorganisms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__list_USCOREorganisms(struct soap *soap, const struct ns1__list_USCOREorganisms *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__list_USCOREorganisms);
	if (soap_out_ns1__list_USCOREorganisms(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__list_USCOREorganisms(struct soap *soap, const char *tag, int id, const struct ns1__list_USCOREorganisms *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__list_USCOREorganisms), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__list_USCOREorganisms * SOAP_FMAC4 soap_get_ns1__list_USCOREorganisms(struct soap *soap, struct ns1__list_USCOREorganisms *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__list_USCOREorganisms(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__list_USCOREorganisms * SOAP_FMAC4 soap_in_ns1__list_USCOREorganisms(struct soap *soap, const char *tag, struct ns1__list_USCOREorganisms *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__list_USCOREorganisms *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__list_USCOREorganisms, sizeof(struct ns1__list_USCOREorganisms), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__list_USCOREorganisms(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__list_USCOREorganisms *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__list_USCOREorganisms, 0, sizeof(struct ns1__list_USCOREorganisms), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__list_USCOREorganisms * SOAP_FMAC6 soap_new_ns1__list_USCOREorganisms(struct soap *soap, int n)
{	return soap_instantiate_ns1__list_USCOREorganisms(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__list_USCOREorganisms(struct soap *soap, struct ns1__list_USCOREorganisms *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__list_USCOREorganisms * SOAP_FMAC4 soap_instantiate_ns1__list_USCOREorganisms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__list_USCOREorganisms(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__list_USCOREorganisms, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__list_USCOREorganisms;
		if (size)
			*size = sizeof(struct ns1__list_USCOREorganisms);
	}
	else
	{	cp->ptr = (void*)new struct ns1__list_USCOREorganisms[n];
		if (size)
			*size = n * sizeof(struct ns1__list_USCOREorganisms);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__list_USCOREorganisms*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__list_USCOREorganisms(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__list_USCOREorganisms %p -> %p\n", q, p));
	*(struct ns1__list_USCOREorganisms*)p = *(struct ns1__list_USCOREorganisms*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__list_USCOREorganismsResponse(struct soap *soap, const struct ns1__list_USCOREorganismsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfDefinition(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__list_USCOREorganismsResponse(struct soap *soap, struct ns1__list_USCOREorganismsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__list_USCOREorganismsResponse(struct soap *soap, const struct ns1__list_USCOREorganismsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__list_USCOREorganismsResponse);
	if (soap_out_ns1__list_USCOREorganismsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__list_USCOREorganismsResponse(struct soap *soap, const char *tag, int id, const struct ns1__list_USCOREorganismsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__list_USCOREorganismsResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfDefinition(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__list_USCOREorganismsResponse * SOAP_FMAC4 soap_get_ns1__list_USCOREorganismsResponse(struct soap *soap, struct ns1__list_USCOREorganismsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__list_USCOREorganismsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__list_USCOREorganismsResponse * SOAP_FMAC4 soap_in_ns1__list_USCOREorganismsResponse(struct soap *soap, const char *tag, struct ns1__list_USCOREorganismsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__list_USCOREorganismsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__list_USCOREorganismsResponse, sizeof(struct ns1__list_USCOREorganismsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__list_USCOREorganismsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfDefinition(soap, "return", &a->return_, "ns1:Definition"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__list_USCOREorganismsResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__list_USCOREorganismsResponse, 0, sizeof(struct ns1__list_USCOREorganismsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__list_USCOREorganismsResponse * SOAP_FMAC6 soap_new_ns1__list_USCOREorganismsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__list_USCOREorganismsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__list_USCOREorganismsResponse(struct soap *soap, struct ns1__list_USCOREorganismsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__list_USCOREorganismsResponse * SOAP_FMAC4 soap_instantiate_ns1__list_USCOREorganismsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__list_USCOREorganismsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__list_USCOREorganismsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__list_USCOREorganismsResponse;
		if (size)
			*size = sizeof(struct ns1__list_USCOREorganismsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__list_USCOREorganismsResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__list_USCOREorganismsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__list_USCOREorganismsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__list_USCOREorganismsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__list_USCOREorganismsResponse %p -> %p\n", q, p));
	*(struct ns1__list_USCOREorganismsResponse*)p = *(struct ns1__list_USCOREorganismsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__list_USCOREdatabases(struct soap *soap, const struct ns1__list_USCOREdatabases *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__list_USCOREdatabases(struct soap *soap, struct ns1__list_USCOREdatabases *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__list_USCOREdatabases(struct soap *soap, const struct ns1__list_USCOREdatabases *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__list_USCOREdatabases);
	if (soap_out_ns1__list_USCOREdatabases(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__list_USCOREdatabases(struct soap *soap, const char *tag, int id, const struct ns1__list_USCOREdatabases *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__list_USCOREdatabases), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__list_USCOREdatabases * SOAP_FMAC4 soap_get_ns1__list_USCOREdatabases(struct soap *soap, struct ns1__list_USCOREdatabases *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__list_USCOREdatabases(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__list_USCOREdatabases * SOAP_FMAC4 soap_in_ns1__list_USCOREdatabases(struct soap *soap, const char *tag, struct ns1__list_USCOREdatabases *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__list_USCOREdatabases *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__list_USCOREdatabases, sizeof(struct ns1__list_USCOREdatabases), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__list_USCOREdatabases(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__list_USCOREdatabases *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__list_USCOREdatabases, 0, sizeof(struct ns1__list_USCOREdatabases), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__list_USCOREdatabases * SOAP_FMAC6 soap_new_ns1__list_USCOREdatabases(struct soap *soap, int n)
{	return soap_instantiate_ns1__list_USCOREdatabases(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__list_USCOREdatabases(struct soap *soap, struct ns1__list_USCOREdatabases *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__list_USCOREdatabases * SOAP_FMAC4 soap_instantiate_ns1__list_USCOREdatabases(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__list_USCOREdatabases(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__list_USCOREdatabases, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__list_USCOREdatabases;
		if (size)
			*size = sizeof(struct ns1__list_USCOREdatabases);
	}
	else
	{	cp->ptr = (void*)new struct ns1__list_USCOREdatabases[n];
		if (size)
			*size = n * sizeof(struct ns1__list_USCOREdatabases);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__list_USCOREdatabases*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__list_USCOREdatabases(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__list_USCOREdatabases %p -> %p\n", q, p));
	*(struct ns1__list_USCOREdatabases*)p = *(struct ns1__list_USCOREdatabases*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__list_USCOREdatabasesResponse(struct soap *soap, const struct ns1__list_USCOREdatabasesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfDefinition(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__list_USCOREdatabasesResponse(struct soap *soap, struct ns1__list_USCOREdatabasesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__list_USCOREdatabasesResponse(struct soap *soap, const struct ns1__list_USCOREdatabasesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__list_USCOREdatabasesResponse);
	if (soap_out_ns1__list_USCOREdatabasesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__list_USCOREdatabasesResponse(struct soap *soap, const char *tag, int id, const struct ns1__list_USCOREdatabasesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__list_USCOREdatabasesResponse), type);
	if (a->return_)
		soap_element_result(soap, "return");
	soap_out_PointerToArrayOfDefinition(soap, "return", -1, &a->return_, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns1__list_USCOREdatabasesResponse * SOAP_FMAC4 soap_get_ns1__list_USCOREdatabasesResponse(struct soap *soap, struct ns1__list_USCOREdatabasesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__list_USCOREdatabasesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns1__list_USCOREdatabasesResponse * SOAP_FMAC4 soap_in_ns1__list_USCOREdatabasesResponse(struct soap *soap, const char *tag, struct ns1__list_USCOREdatabasesResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns1__list_USCOREdatabasesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__list_USCOREdatabasesResponse, sizeof(struct ns1__list_USCOREdatabasesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__list_USCOREdatabasesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfDefinition(soap, "return", &a->return_, "ns1:Definition"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__list_USCOREdatabasesResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns1__list_USCOREdatabasesResponse, 0, sizeof(struct ns1__list_USCOREdatabasesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__list_USCOREdatabasesResponse * SOAP_FMAC6 soap_new_ns1__list_USCOREdatabasesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__list_USCOREdatabasesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__list_USCOREdatabasesResponse(struct soap *soap, struct ns1__list_USCOREdatabasesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__list_USCOREdatabasesResponse * SOAP_FMAC4 soap_instantiate_ns1__list_USCOREdatabasesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__list_USCOREdatabasesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__list_USCOREdatabasesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__list_USCOREdatabasesResponse;
		if (size)
			*size = sizeof(struct ns1__list_USCOREdatabasesResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__list_USCOREdatabasesResponse[n];
		if (size)
			*size = n * sizeof(struct ns1__list_USCOREdatabasesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__list_USCOREdatabasesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__list_USCOREdatabasesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__list_USCOREdatabasesResponse %p -> %p\n", q, p));
	*(struct ns1__list_USCOREdatabasesResponse*)p = *(struct ns1__list_USCOREdatabasesResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfPathwayElementRelation(struct soap *soap, ArrayOfPathwayElementRelation *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfPathwayElementRelation(struct soap *soap, ArrayOfPathwayElementRelation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfPathwayElementRelation);
	if (soap_out_PointerToArrayOfPathwayElementRelation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfPathwayElementRelation(struct soap *soap, const char *tag, int id, ArrayOfPathwayElementRelation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfPathwayElementRelation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfPathwayElementRelation ** SOAP_FMAC4 soap_get_PointerToArrayOfPathwayElementRelation(struct soap *soap, ArrayOfPathwayElementRelation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfPathwayElementRelation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfPathwayElementRelation ** SOAP_FMAC4 soap_in_PointerToArrayOfPathwayElementRelation(struct soap *soap, const char *tag, ArrayOfPathwayElementRelation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfPathwayElementRelation **)soap_malloc(soap, sizeof(ArrayOfPathwayElementRelation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfPathwayElementRelation *)soap_instantiate_ArrayOfPathwayElementRelation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfPathwayElementRelation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfPathwayElementRelation, sizeof(ArrayOfPathwayElementRelation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfPathwayElement(struct soap *soap, ArrayOfPathwayElement *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfPathwayElement(struct soap *soap, ArrayOfPathwayElement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfPathwayElement);
	if (soap_out_PointerToArrayOfPathwayElement(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfPathwayElement(struct soap *soap, const char *tag, int id, ArrayOfPathwayElement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfPathwayElement);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfPathwayElement ** SOAP_FMAC4 soap_get_PointerToArrayOfPathwayElement(struct soap *soap, ArrayOfPathwayElement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfPathwayElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfPathwayElement ** SOAP_FMAC4 soap_in_PointerToArrayOfPathwayElement(struct soap *soap, const char *tag, ArrayOfPathwayElement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfPathwayElement **)soap_malloc(soap, sizeof(ArrayOfPathwayElement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfPathwayElement *)soap_instantiate_ArrayOfPathwayElement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfPathwayElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfPathwayElement, sizeof(ArrayOfPathwayElement), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfMotifResult(struct soap *soap, ArrayOfMotifResult *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfMotifResult(struct soap *soap, ArrayOfMotifResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfMotifResult);
	if (soap_out_PointerToArrayOfMotifResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfMotifResult(struct soap *soap, const char *tag, int id, ArrayOfMotifResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfMotifResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfMotifResult ** SOAP_FMAC4 soap_get_PointerToArrayOfMotifResult(struct soap *soap, ArrayOfMotifResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfMotifResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfMotifResult ** SOAP_FMAC4 soap_in_PointerToArrayOfMotifResult(struct soap *soap, const char *tag, ArrayOfMotifResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfMotifResult **)soap_malloc(soap, sizeof(ArrayOfMotifResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfMotifResult *)soap_instantiate_ArrayOfMotifResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfMotifResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfMotifResult, sizeof(ArrayOfMotifResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfSSDBRelation(struct soap *soap, ArrayOfSSDBRelation *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfSSDBRelation(struct soap *soap, ArrayOfSSDBRelation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfSSDBRelation);
	if (soap_out_PointerToArrayOfSSDBRelation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfSSDBRelation(struct soap *soap, const char *tag, int id, ArrayOfSSDBRelation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfSSDBRelation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfSSDBRelation ** SOAP_FMAC4 soap_get_PointerToArrayOfSSDBRelation(struct soap *soap, ArrayOfSSDBRelation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfSSDBRelation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfSSDBRelation ** SOAP_FMAC4 soap_in_PointerToArrayOfSSDBRelation(struct soap *soap, const char *tag, ArrayOfSSDBRelation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfSSDBRelation **)soap_malloc(soap, sizeof(ArrayOfSSDBRelation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfSSDBRelation *)soap_instantiate_ArrayOfSSDBRelation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfSSDBRelation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfSSDBRelation, sizeof(ArrayOfSSDBRelation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfLinkDBRelation(struct soap *soap, ArrayOfLinkDBRelation *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfLinkDBRelation(struct soap *soap, ArrayOfLinkDBRelation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfLinkDBRelation);
	if (soap_out_PointerToArrayOfLinkDBRelation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfLinkDBRelation(struct soap *soap, const char *tag, int id, ArrayOfLinkDBRelation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfLinkDBRelation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfLinkDBRelation ** SOAP_FMAC4 soap_get_PointerToArrayOfLinkDBRelation(struct soap *soap, ArrayOfLinkDBRelation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfLinkDBRelation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfLinkDBRelation ** SOAP_FMAC4 soap_in_PointerToArrayOfLinkDBRelation(struct soap *soap, const char *tag, ArrayOfLinkDBRelation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfLinkDBRelation **)soap_malloc(soap, sizeof(ArrayOfLinkDBRelation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfLinkDBRelation *)soap_instantiate_ArrayOfLinkDBRelation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfLinkDBRelation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfLinkDBRelation, sizeof(ArrayOfLinkDBRelation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfDefinition(struct soap *soap, ArrayOfDefinition *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfDefinition(struct soap *soap, ArrayOfDefinition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfDefinition);
	if (soap_out_PointerToArrayOfDefinition(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfDefinition(struct soap *soap, const char *tag, int id, ArrayOfDefinition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfDefinition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfDefinition ** SOAP_FMAC4 soap_get_PointerToArrayOfDefinition(struct soap *soap, ArrayOfDefinition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfDefinition(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfDefinition ** SOAP_FMAC4 soap_in_PointerToArrayOfDefinition(struct soap *soap, const char *tag, ArrayOfDefinition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfDefinition **)soap_malloc(soap, sizeof(ArrayOfDefinition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfDefinition *)soap_instantiate_ArrayOfDefinition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfDefinition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfDefinition, sizeof(ArrayOfDefinition), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Subtype(struct soap *soap, ns1__Subtype **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Subtype))
		soap_serialize_PointerTons1__Subtype(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Subtype(struct soap *soap, ns1__Subtype **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Subtype);
	if (soap_out_PointerToPointerTons1__Subtype(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Subtype(struct soap *soap, const char *tag, int id, ns1__Subtype **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Subtype);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Subtype(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Subtype *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Subtype(struct soap *soap, ns1__Subtype ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Subtype(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Subtype *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Subtype(struct soap *soap, const char *tag, ns1__Subtype ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns1__Subtype ***)soap_malloc(soap, sizeof(ns1__Subtype **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Subtype(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Subtype ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Subtype, sizeof(ns1__Subtype *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Subtype(struct soap *soap, ns1__Subtype *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Subtype))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Subtype(struct soap *soap, ns1__Subtype *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Subtype);
	if (soap_out_PointerTons1__Subtype(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Subtype(struct soap *soap, const char *tag, int id, ns1__Subtype *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Subtype);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Subtype ** SOAP_FMAC4 soap_get_PointerTons1__Subtype(struct soap *soap, ns1__Subtype **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Subtype(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Subtype ** SOAP_FMAC4 soap_in_PointerTons1__Subtype(struct soap *soap, const char *tag, ns1__Subtype **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns1__Subtype **)soap_malloc(soap, sizeof(ns1__Subtype *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Subtype *)soap_instantiate_ns1__Subtype(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__Subtype **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Subtype, sizeof(ns1__Subtype), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__PathwayElementRelation(struct soap *soap, ns1__PathwayElementRelation **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__PathwayElementRelation))
		soap_serialize_PointerTons1__PathwayElementRelation(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__PathwayElementRelation(struct soap *soap, ns1__PathwayElementRelation **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__PathwayElementRelation);
	if (soap_out_PointerToPointerTons1__PathwayElementRelation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__PathwayElementRelation(struct soap *soap, const char *tag, int id, ns1__PathwayElementRelation **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__PathwayElementRelation);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__PathwayElementRelation(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__PathwayElementRelation *** SOAP_FMAC4 soap_get_PointerToPointerTons1__PathwayElementRelation(struct soap *soap, ns1__PathwayElementRelation ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__PathwayElementRelation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__PathwayElementRelation *** SOAP_FMAC4 soap_in_PointerToPointerTons1__PathwayElementRelation(struct soap *soap, const char *tag, ns1__PathwayElementRelation ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns1__PathwayElementRelation ***)soap_malloc(soap, sizeof(ns1__PathwayElementRelation **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__PathwayElementRelation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__PathwayElementRelation ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__PathwayElementRelation, sizeof(ns1__PathwayElementRelation *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PathwayElementRelation(struct soap *soap, ns1__PathwayElementRelation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PathwayElementRelation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PathwayElementRelation(struct soap *soap, ns1__PathwayElementRelation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PathwayElementRelation);
	if (soap_out_PointerTons1__PathwayElementRelation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PathwayElementRelation(struct soap *soap, const char *tag, int id, ns1__PathwayElementRelation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PathwayElementRelation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PathwayElementRelation ** SOAP_FMAC4 soap_get_PointerTons1__PathwayElementRelation(struct soap *soap, ns1__PathwayElementRelation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PathwayElementRelation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__PathwayElementRelation ** SOAP_FMAC4 soap_in_PointerTons1__PathwayElementRelation(struct soap *soap, const char *tag, ns1__PathwayElementRelation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns1__PathwayElementRelation **)soap_malloc(soap, sizeof(ns1__PathwayElementRelation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PathwayElementRelation *)soap_instantiate_ns1__PathwayElementRelation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__PathwayElementRelation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PathwayElementRelation, sizeof(ns1__PathwayElementRelation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__PathwayElement(struct soap *soap, ns1__PathwayElement **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__PathwayElement))
		soap_serialize_PointerTons1__PathwayElement(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__PathwayElement(struct soap *soap, ns1__PathwayElement **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__PathwayElement);
	if (soap_out_PointerToPointerTons1__PathwayElement(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__PathwayElement(struct soap *soap, const char *tag, int id, ns1__PathwayElement **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__PathwayElement);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__PathwayElement(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__PathwayElement *** SOAP_FMAC4 soap_get_PointerToPointerTons1__PathwayElement(struct soap *soap, ns1__PathwayElement ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__PathwayElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__PathwayElement *** SOAP_FMAC4 soap_in_PointerToPointerTons1__PathwayElement(struct soap *soap, const char *tag, ns1__PathwayElement ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns1__PathwayElement ***)soap_malloc(soap, sizeof(ns1__PathwayElement **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__PathwayElement(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__PathwayElement ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__PathwayElement, sizeof(ns1__PathwayElement *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PathwayElement(struct soap *soap, ns1__PathwayElement *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PathwayElement))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PathwayElement(struct soap *soap, ns1__PathwayElement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PathwayElement);
	if (soap_out_PointerTons1__PathwayElement(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PathwayElement(struct soap *soap, const char *tag, int id, ns1__PathwayElement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PathwayElement);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PathwayElement ** SOAP_FMAC4 soap_get_PointerTons1__PathwayElement(struct soap *soap, ns1__PathwayElement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PathwayElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__PathwayElement ** SOAP_FMAC4 soap_in_PointerTons1__PathwayElement(struct soap *soap, const char *tag, ns1__PathwayElement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns1__PathwayElement **)soap_malloc(soap, sizeof(ns1__PathwayElement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PathwayElement *)soap_instantiate_ns1__PathwayElement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__PathwayElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PathwayElement, sizeof(ns1__PathwayElement), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__LinkDBRelation(struct soap *soap, ns1__LinkDBRelation **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__LinkDBRelation))
		soap_serialize_PointerTons1__LinkDBRelation(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__LinkDBRelation(struct soap *soap, ns1__LinkDBRelation **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__LinkDBRelation);
	if (soap_out_PointerToPointerTons1__LinkDBRelation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__LinkDBRelation(struct soap *soap, const char *tag, int id, ns1__LinkDBRelation **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__LinkDBRelation);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__LinkDBRelation(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__LinkDBRelation *** SOAP_FMAC4 soap_get_PointerToPointerTons1__LinkDBRelation(struct soap *soap, ns1__LinkDBRelation ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__LinkDBRelation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__LinkDBRelation *** SOAP_FMAC4 soap_in_PointerToPointerTons1__LinkDBRelation(struct soap *soap, const char *tag, ns1__LinkDBRelation ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns1__LinkDBRelation ***)soap_malloc(soap, sizeof(ns1__LinkDBRelation **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__LinkDBRelation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__LinkDBRelation ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__LinkDBRelation, sizeof(ns1__LinkDBRelation *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LinkDBRelation(struct soap *soap, ns1__LinkDBRelation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LinkDBRelation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LinkDBRelation(struct soap *soap, ns1__LinkDBRelation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__LinkDBRelation);
	if (soap_out_PointerTons1__LinkDBRelation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LinkDBRelation(struct soap *soap, const char *tag, int id, ns1__LinkDBRelation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LinkDBRelation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__LinkDBRelation ** SOAP_FMAC4 soap_get_PointerTons1__LinkDBRelation(struct soap *soap, ns1__LinkDBRelation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LinkDBRelation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__LinkDBRelation ** SOAP_FMAC4 soap_in_PointerTons1__LinkDBRelation(struct soap *soap, const char *tag, ns1__LinkDBRelation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns1__LinkDBRelation **)soap_malloc(soap, sizeof(ns1__LinkDBRelation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LinkDBRelation *)soap_instantiate_ns1__LinkDBRelation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__LinkDBRelation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LinkDBRelation, sizeof(ns1__LinkDBRelation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Definition(struct soap *soap, ns1__Definition **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Definition))
		soap_serialize_PointerTons1__Definition(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Definition(struct soap *soap, ns1__Definition **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__Definition);
	if (soap_out_PointerToPointerTons1__Definition(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Definition(struct soap *soap, const char *tag, int id, ns1__Definition **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Definition);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Definition(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Definition *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Definition(struct soap *soap, ns1__Definition ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Definition(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Definition *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Definition(struct soap *soap, const char *tag, ns1__Definition ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns1__Definition ***)soap_malloc(soap, sizeof(ns1__Definition **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Definition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Definition ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__Definition, sizeof(ns1__Definition *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Definition(struct soap *soap, ns1__Definition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Definition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Definition(struct soap *soap, ns1__Definition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Definition);
	if (soap_out_PointerTons1__Definition(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Definition(struct soap *soap, const char *tag, int id, ns1__Definition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Definition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Definition ** SOAP_FMAC4 soap_get_PointerTons1__Definition(struct soap *soap, ns1__Definition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Definition(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__Definition ** SOAP_FMAC4 soap_in_PointerTons1__Definition(struct soap *soap, const char *tag, ns1__Definition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns1__Definition **)soap_malloc(soap, sizeof(ns1__Definition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Definition *)soap_instantiate_ns1__Definition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__Definition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Definition, sizeof(ns1__Definition), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__MotifResult(struct soap *soap, ns1__MotifResult **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__MotifResult))
		soap_serialize_PointerTons1__MotifResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__MotifResult(struct soap *soap, ns1__MotifResult **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__MotifResult);
	if (soap_out_PointerToPointerTons1__MotifResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__MotifResult(struct soap *soap, const char *tag, int id, ns1__MotifResult **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__MotifResult);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__MotifResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__MotifResult *** SOAP_FMAC4 soap_get_PointerToPointerTons1__MotifResult(struct soap *soap, ns1__MotifResult ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__MotifResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MotifResult *** SOAP_FMAC4 soap_in_PointerToPointerTons1__MotifResult(struct soap *soap, const char *tag, ns1__MotifResult ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns1__MotifResult ***)soap_malloc(soap, sizeof(ns1__MotifResult **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__MotifResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__MotifResult ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__MotifResult, sizeof(ns1__MotifResult *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MotifResult(struct soap *soap, ns1__MotifResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MotifResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MotifResult(struct soap *soap, ns1__MotifResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MotifResult);
	if (soap_out_PointerTons1__MotifResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MotifResult(struct soap *soap, const char *tag, int id, ns1__MotifResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MotifResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MotifResult ** SOAP_FMAC4 soap_get_PointerTons1__MotifResult(struct soap *soap, ns1__MotifResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MotifResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MotifResult ** SOAP_FMAC4 soap_in_PointerTons1__MotifResult(struct soap *soap, const char *tag, ns1__MotifResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns1__MotifResult **)soap_malloc(soap, sizeof(ns1__MotifResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MotifResult *)soap_instantiate_ns1__MotifResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MotifResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MotifResult, sizeof(ns1__MotifResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__SSDBRelation(struct soap *soap, ns1__SSDBRelation **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__SSDBRelation))
		soap_serialize_PointerTons1__SSDBRelation(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__SSDBRelation(struct soap *soap, ns1__SSDBRelation **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__SSDBRelation);
	if (soap_out_PointerToPointerTons1__SSDBRelation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__SSDBRelation(struct soap *soap, const char *tag, int id, ns1__SSDBRelation **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__SSDBRelation);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__SSDBRelation(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__SSDBRelation *** SOAP_FMAC4 soap_get_PointerToPointerTons1__SSDBRelation(struct soap *soap, ns1__SSDBRelation ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__SSDBRelation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SSDBRelation *** SOAP_FMAC4 soap_in_PointerToPointerTons1__SSDBRelation(struct soap *soap, const char *tag, ns1__SSDBRelation ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns1__SSDBRelation ***)soap_malloc(soap, sizeof(ns1__SSDBRelation **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__SSDBRelation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__SSDBRelation ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__SSDBRelation, sizeof(ns1__SSDBRelation *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SSDBRelation(struct soap *soap, ns1__SSDBRelation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SSDBRelation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SSDBRelation(struct soap *soap, ns1__SSDBRelation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SSDBRelation);
	if (soap_out_PointerTons1__SSDBRelation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SSDBRelation(struct soap *soap, const char *tag, int id, ns1__SSDBRelation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SSDBRelation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SSDBRelation ** SOAP_FMAC4 soap_get_PointerTons1__SSDBRelation(struct soap *soap, ns1__SSDBRelation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SSDBRelation(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SSDBRelation ** SOAP_FMAC4 soap_in_PointerTons1__SSDBRelation(struct soap *soap, const char *tag, ns1__SSDBRelation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns1__SSDBRelation **)soap_malloc(soap, sizeof(ns1__SSDBRelation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SSDBRelation *)soap_instantiate_ns1__SSDBRelation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__SSDBRelation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SSDBRelation, sizeof(ns1__SSDBRelation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTostd__string(struct soap *soap, std::string **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTostd__string))
		soap_serialize_PointerTostd__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTostd__string(struct soap *soap, std::string **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTostd__string);
	if (soap_out_PointerToPointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTostd__string(struct soap *soap, const char *tag, int id, std::string **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTostd__string);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTostd__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string *** SOAP_FMAC4 soap_get_PointerToPointerTostd__string(struct soap *soap, std::string ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTostd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string *** SOAP_FMAC4 soap_in_PointerToPointerTostd__string(struct soap *soap, const char *tag, std::string ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (std::string ***)soap_malloc(soap, sizeof(std::string **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTostd__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTostd__string, sizeof(std::string *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfSubtype(struct soap *soap, ArrayOfSubtype *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfSubtype(struct soap *soap, ArrayOfSubtype *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfSubtype);
	if (soap_out_PointerToArrayOfSubtype(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfSubtype(struct soap *soap, const char *tag, int id, ArrayOfSubtype *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfSubtype);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfSubtype ** SOAP_FMAC4 soap_get_PointerToArrayOfSubtype(struct soap *soap, ArrayOfSubtype **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfSubtype(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfSubtype ** SOAP_FMAC4 soap_in_PointerToArrayOfSubtype(struct soap *soap, const char *tag, ArrayOfSubtype **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfSubtype **)soap_malloc(soap, sizeof(ArrayOfSubtype *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfSubtype *)soap_instantiate_ArrayOfSubtype(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfSubtype **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfSubtype, sizeof(ArrayOfSubtype), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfint(struct soap *soap, ArrayOfint *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfint(struct soap *soap, ArrayOfint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfint);
	if (soap_out_PointerToArrayOfint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfint(struct soap *soap, const char *tag, int id, ArrayOfint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfint);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfint ** SOAP_FMAC4 soap_get_PointerToArrayOfint(struct soap *soap, ArrayOfint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfint ** SOAP_FMAC4 soap_in_PointerToArrayOfint(struct soap *soap, const char *tag, ArrayOfint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfint **)soap_malloc(soap, sizeof(ArrayOfint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfint *)soap_instantiate_ArrayOfint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfint, sizeof(ArrayOfint), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfstring(struct soap *soap, ArrayOfstring *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfstring(struct soap *soap, ArrayOfstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfstring);
	if (soap_out_PointerToArrayOfstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfstring(struct soap *soap, const char *tag, int id, ArrayOfstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfstring);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfstring ** SOAP_FMAC4 soap_get_PointerToArrayOfstring(struct soap *soap, ArrayOfstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfstring ** SOAP_FMAC4 soap_in_PointerToArrayOfstring(struct soap *soap, const char *tag, ArrayOfstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfstring **)soap_malloc(soap, sizeof(ArrayOfstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfstring *)soap_instantiate_ArrayOfstring(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfstring, sizeof(ArrayOfstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

/* End of soapC.cpp */
