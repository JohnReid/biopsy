#
# Copyright John Reid 2007
#

"""
Code to parse gapped PSSM format agreed upon with Sascha
"""


import hmm.pssm

class SemiParsedModel(object):
    def __init__(self):
        self.N=None
        self.M=None
        self.initial=[]
        self.transitions=[]
        self.emissions=[]
        self.comments=[]

    def __str__(self):
        return """MODEL:%d,%d\n
%s\n
%s\n
%s\n
%s""" % (
    self.N, self.M,
    "\n".join("#%s" % comment for comment in self.comments),
    "\n".join("INITIAL:%d;%f" % (state, p) for state, p in self.initial),
    "\n".join("TRANSITION:%d;%d;%f" % (s1, s2, p) for s1, s2, p in self.transitions),
    "\n".join("EMISSIONS:%d;%s" % (state, ','.join(str(p) for p in ps)) for state, ps in self.emissions)
)

def build_hmm_from_semi_parsed(
  parsed,
  p_binding_site=.01,
  background_order=0,
  num_background_mosaics=1
):
    """
    Takes a semi-parsed model (generated by parse_models) and builds a full HMM
    model from it.
    """

    # analyse the transitions to discover K and map states
    state_map = dict()
    for s1, s2, p in parsed.transitions:
        if s1 not in state_map:
            state_map[s1] = (0,False)
        if 1. == p:
            state_map[s2] = (state_map[s1][0]+1,False)
        else:
            state_map[s2] = (state_map[s1][0],True)
    K = max(s for s,gap in state_map.values())+1
    #print 'K=%d' % K
    #print '\n'.join( '%d->%d,%s' % (s1,s2,gap and 'True' or 'False') for s1,(s2,gap) in parsed.get_state_map().iteritems() )

    def background_model_creator(order, num_mosaics):
        from hmm.pssm import ModelBuilder
        model_builder = ModelBuilder(order, alphabet_size=4)
        return model_builder.create_uniform_background_model()
    bg_model = background_model_creator(0, 1)

    # create a model that we can fill in the details for
    traits = hmm.pssm.GappedPssmTraits(
      K=K,
        p_binding_site=p_binding_site,
        background_order=background_order,
        num_background_mosaics=num_background_mosaics,
        background_model_creator=background_model_creator
    )
    model = hmm.model_states_2_model(traits.new_model())
    #from IPython.Debugger import Pdb; Pdb().set_trace()

    # blank the emission, gap transitions and initial probs
    for i in xrange(model.N):
        model.set_initial(i, 0.0)
    for k in xrange(K):
        if K-1 != k:
            model.set_transition(traits.kth(k), traits.kth_gap(k), 0.0)
        for m in xrange(model.M):
            model.set_emission(traits.kth(k), m, model.M/1.)
            model.set_emission(traits.kth_gap(k), m, model.M/1.)

    def state_to_i(state):
        k, gap = state_map[state]
        if gap:
            return traits.kth_gap(k)
        else:
            return traits.kth(k)

    # set the probability of being in the initial state
    num_foreground_states = model.N - num_background_mosaics
    for i in xrange(model.N):
        if i in traits.background_states:
            model.set_initial(i, (1. - p_binding_site) / num_background_mosaics)
        else:
            model.set_initial(i, p_binding_site / num_foreground_states)

    for s1, s2, p in parsed.transitions:
        i1 = state_to_i(s1)
        i2 = state_to_i(s2)
        model.set_transition(i1, i2, p)

    for state, ps in parsed.emissions:
        i = state_to_i(state)
        for m, p in enumerate(ps):
            model.set_emission(i, m, p)

    model.normalise()
    return model, traits



def parse_models(f):
    model = None
    for line in f:
        line = line.strip()
        if 0 == len(line):
            continue
        if line.startswith('#'):
            if model != None:
                model.comments.append(line[1:])
        else:
            type, values = line.split(':')
            if 'MODEL' == type:
                if None != model:
                    yield model
                model = SemiParsedModel()
                N, M = values.split(',')
                model.N = int(N)
                model.M = int(M)
            elif 'INITIAL' == type:
                state, p = values.split(';')
                model.initial.append((int(state), float(p)))
            elif 'TRANSITION' == type:
                s1, s2, p = values.split(';')
                model.transitions.append((int(s1), int(s2), float(p)))
            elif 'EMISSIONS' == type:
                state, ps_str = values.split(';')
                ps = [float(p) for p in ps_str.split(',')]
                model.emissions.append((int(state), ps))
            else:
                raise RuntimeError('type "%s" not recognised' % type)
    if None != model:
        yield model

if '__main__' == __name__:
    import os, logging, sys, optparse

    logging.basicConfig(level=logging.INFO)

    #
    # Parse the options
    #
    option_parser = optparse.OptionParser()
    option_parser.add_option(
      "-L",
      "--write-logos",
      dest="write_logos",
      action='store_true',
      default=False,
      help="Write logo images."
    )

    #sys.argv = "latex_report.py -p /home/john/Analysis/GappedPssms/fragments/dummy-output/".split()
    options, args = option_parser.parse_args()
    for option in option_parser.option_list:
        if option.dest:
            logging.info('%32s: %s', option.dest, str(getattr(options, option.dest)))

    for model_file in args:
        logging.info('Parsing %s', model_file)
        for idx, parsed in enumerate(parse_models(open(model_file))):
            logging.info('******************************************************************')
            logging.info(str(parsed))
            model, traits = build_hmm_from_semi_parsed(parsed)
            if options.write_logos:
                traits.write_logo(model, '%s-%d.png' % (model_file, idx))
